<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚永坤的小窝</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-20T14:53:51.596Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>姚永坤</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>453.最小操作次数使数组元素相等</title>
    <link href="http://example.com/2021/10/20/lc-453/"/>
    <id>http://example.com/2021/10/20/lc-453/</id>
    <published>2021-10-20T14:02:36.000Z</published>
    <updated>2021-10-20T14:53:51.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。</p><h1 id="错误解题历程"><a href="#错误解题历程" class="headerlink" title="错误解题历程"></a>错误解题历程</h1><h2 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>根据题目要求找出数组中的最大值，遍历数组中每一个元素如果比最大值小那么就将该值加一，否则不变；</li><li>当首次遇到与最大值相等的值的时候该值不变并标记，下次遇到时加一；</li><li>遍历数组判断是否全部相等；</li></ul><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>当遇到的数组最大值较大或者数组长度较长时的时候循环次数较多导致代码运行超时。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minMoves = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> maxN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        maxN = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">        <span class="keyword">let</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==maxN)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==nums.length)&#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> flag1 = <span class="number">0</span>;</span><br><span class="line">        nums.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(item&lt;maxN)&#123;</span><br><span class="line">                nums[index]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag1==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag1=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums[index]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>反解，每次操作既可以理解为使 n-1个元素增加 1，也可以理解使 1 个元素减少 1。<br>所以，思路如下：</p><ul><li>求出数组中的最小值；</li><li>将数组中的每个值与最小值进行相减；</li><li>将得到的结果累加的和就是最终结果。</li></ul><h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minMoves = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> minN = <span class="number">0</span>;</span><br><span class="line">    minN = <span class="built_in">Math</span>.min(...nums);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        result += item-minN;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十六）迭代器与生成器</title>
    <link href="http://example.com/2021/10/20/js-16/"/>
    <id>http://example.com/2021/10/20/js-16/</id>
    <published>2021-10-20T05:08:52.000Z</published>
    <updated>2021-10-20T14:54:58.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代与迭代器"><a href="#迭代与迭代器" class="headerlink" title="迭代与迭代器"></a>迭代与迭代器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>官方定义的迭代意思是：按照顺序反复多次执行一段程序,通常会有明确的终止条件。</li><li>实际上计数循环就是最简单的迭代。</li><li><strong>循环是迭代机制的基础</strong>，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。</li><li><strong>迭代会在一个有序集合上进行</strong>。(“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到,特别是开始和结束项有明确的定义。)数组是JavaScript 中有序集合的最典型例子。</li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ul><li>迭代器模式（特别是在 ECMAScript这个语境下)描述了一个方案，即<strong>可以把有些结构称为“可迭代对象”( iterable)，因为它们实现了正式的工terable接口，而且可以通过迭代器工terator消费。</strong></li><li>基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对</li></ul><h2 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h2><ul><li><strong>可迭代协议指的是Iterable接口</strong></li><li>实现工terable接口(可迭代协议)要求同时具备两种能力:<strong>支持迭代的自我识别能力和创建实现Iterator接口的对象的能力</strong>。</li><li>实现可迭代协议的所有类型都会白动兼容接收可迭代对象的任何语言特性。</li><li>接收可迭代对象的原牛语言特性句括：<ul><li>for-of循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()</li><li>Promise.race()</li><li>yield*操作符，在生成器中使用</li></ul></li></ul><h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><ul><li><p><strong>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。</strong></p></li><li><p>迭代器API使用next()方法在可迭代对象中遍历数据。</p></li><li><p>每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。若不调用next ()，则无法知道迭代器的当前位置。</p></li><li><p>next()方法返回的迭代器对象IteratorResult包含两个属性: <strong>done和value</strong>：</p><ul><li>done是一个布尔值，表示是否还可以再次调用next ()取得下一个值; </li><li>value包含可迭代对象的下一个值(done为false)、或者undefined ( done为true )。</li><li>done: true状态称为“耗尽”。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><ul><li>不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象；</li><li>如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br></pre></td></tr></table></figure><h2 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h2><ul><li>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此可以把计数器变量放到闭包里，然后通过闭包返回迭代器:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.limit = limit; </span><br><span class="line">    &#125; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">            limit = <span class="built_in">this</span>.limit; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">                <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>每个以这种方式创建的迭代器也实现了Iterable接口。Symbol.iterator属性引用的工厂函数会返回相同的迭代器；</li></ul><h2 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h2><ul><li>return()方法用于指定在迭代器提前关闭时执行的逻辑。</li><li>return()方法必须返回一个有效的工teratorResult对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.limit = limit; </span><br><span class="line">    &#125; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">            limit = <span class="built_in">this</span>.limit; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">                <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="keyword">return</span>() &#123; </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> Counter(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123; </span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> Counter(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123; </span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> Counter(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3; </span><br><span class="line"><span class="comment">// Exiting early </span></span><br></pre></td></tr></table></figure><ul><li>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。</li><li>数组的迭代器就是不能关闭的。</li><li>要知道某个迭代器是否可关闭,可以测试这个迭代器实例的return属性是不是函数对象。</li><li>调用 return()不会强制迭代器进入关闭状态，但return()方法还是会被调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line">iter.return = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i); </span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 提前退出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul><li>生成器是 ECMAScript 6新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。</li><li><strong>生成器的形式是一个函数</strong>，函数名称前面加一个星号(*)表示它是一个生成器。</li><li><strong>只要是可以定义丽数的地方,就可以定义生成器</strong>。</li><li>箭头函数不能用来定义生成器函数。</li><li>标识生成器函数的星号不受两侧空格的影响。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; </span><br><span class="line">    * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">    * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>调用生成器函数会产生一个生成器对象。</li><li>生成器对象一开始处于暂停执行( suspended )的状态。</li><li>与迭代器相似，生成器对象也实现了Iterator 接口，因此具有next()方法。</li><li>调用这个方法会让生成器开始或恢复执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.next); <span class="comment">// f next() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><ul><li>next ()方法的返回值类似于迭代器，有一个done属性和一个value属性。</li><li>函数体为空的生成器函数中间不会停留,调用一次next()就会让生成器到达 done: true状态。</li><li>value属性是生成器函数的返回值，默认值为undefined，可以通过生成器函数的返回值指定:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: &#x27;foo&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>生成器函数只会在初次调用next ()方法后开始执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line">generatorObject.next(); <span class="comment">// foobar </span></span><br></pre></td></tr></table></figure><ul><li>生成器对象实现了Iterable接口,它们默认的迭代器是自引用的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="built_in">console</span>.log(generatorFn); </span><br><span class="line"><span class="comment">// f* generatorFn() &#123;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn()[<span class="built_in">Symbol</span>.iterator]);</span><br><span class="line"><span class="comment">// f [Symbol.iterator]() &#123;native code&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn()[<span class="built_in">Symbol</span>.iterator]()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(g === g[<span class="built_in">Symbol</span>.iterator]()); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h2><ul><li>yield关键字可以让生成器停止和开始执行。</li><li>生成器函数在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。</li><li>停止执行的生成器函数只能通过在生成器对象上调用next ()方法来恢复执行。</li><li>yield关键字生成的值会出现在next()方法返回的对象里</li><li><strong>通过yield关键字退出的生成器函数会处在done: false状态。</strong></li><li><strong>通过return 关键字退出的生成器函数会处于done: true状态。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: &#x27;baz&#x27; &#125; </span></span><br></pre></td></tr></table></figure><ul><li>生成器函数内部的执行流程会针对每个生成器对象区分作用域。<strong>在一个生成器对象上调用next ()不会影响其他生成器</strong>。</li><li><strong>yield关键字只能在生成器函数内部使用</strong>,用在其他地方会抛出错误。</li><li>yield关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">validGeneratorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnA</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnB</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> b = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnC</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    (<span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125;)(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="1、生成器对象作为可迭代对象"><a href="#1、生成器对象作为可迭代对象" class="headerlink" title="1、生成器对象作为可迭代对象"></a>1、生成器对象作为可迭代对象</h3><ul><li>把生成器对象当成可迭代对象，那么使用起来会更方便。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(n--) &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><h3 id="使用yield实现输入和输出"><a href="#使用yield实现输入和输出" class="headerlink" title="使用yield实现输入和输出"></a>使用yield实现输入和输出</h3><ul><li>除了可以作为函数的中间返回语句使用, yield关键字还可以作为函数的中间参数使用;</li><li>第一次调用next ()传人的值不会被使用，因为这一次调用是为了开始执行生成器函数:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params">initial</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// console.log(initial); </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">generatorObject.next(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 没有输出，开始执行生成器函数 </span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;baz&#x27;</span>); <span class="comment">// baz </span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;qux&#x27;</span>); <span class="comment">// qux </span></span><br></pre></td></tr></table></figure><ul><li>yield关键字可以同时用于输入和输出：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// &#123; done: true, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到yield关键字时暂停执行并计算出要产生的值: “foo”。下一次调用next ()传入了”bar”，作为交给同一个yield 的值。然后这个值被确定为本次生成器函数要返回的值。</li></ul><ul><li>yield 关键字并非只能使用一次，如下面的例子定义了一个无穷计数生成器函数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;;++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> i; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value); <span class="comment">// 5 </span></span><br><span class="line">... </span><br></pre></td></tr></table></figure><ul><li>使用生成器也可以实现范围和填充数组：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start, end</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(end &gt; start) &#123; </span><br><span class="line">        <span class="keyword">yield</span> start++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> range(<span class="number">4</span>, <span class="number">7</span>)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">zeroes</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(n--) &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(zeroes(<span class="number">8</span>))); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h3 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h3><ul><li>yield星号两侧的空格不影响其行为;</li><li>使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><ul><li><strong>yield*实际上只是将一个可迭代对象序列化为一连串可以单独产出的值</strong>，所以这跟把yield放到一个循环里没什么不同。</li><li>yield*的值是关联迭代器返回done: true 时的 value属性。对于普通迭代器来说，这个值是undefined。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: 1 </span></span><br><span class="line"><span class="comment">// value: 2 </span></span><br><span class="line"><span class="comment">// value: 3 </span></span><br><span class="line"><span class="comment">// iter value: undefined</span></span><br></pre></td></tr></table></figure><ul><li>对于生成器函数产生的迭代器来说,这个值就是生成器函数返回的值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">innerGeneratorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outerGeneratorFn</span>(<span class="params">genObj</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* innerGeneratorFn()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> outerGeneratorFn()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: foo </span></span><br><span class="line"><span class="comment">// iter value: bar </span></span><br></pre></td></tr></table></figure><h3 id="使用yield-实现递归算法"><a href="#使用yield-实现递归算法" class="headerlink" title="使用yield*实现递归算法"></a>使用yield*实现递归算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">yield</span> n - <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">yield</span>* <span class="built_in">this</span>.values; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h2 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h2><h3 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h3><ul><li>return()方法会强制生成器进人关闭状态。提供给return()方法的值,就是终止迭代器对象的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">        <span class="keyword">yield</span> x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>与迭代器不同，所有生成器对象都有return()方法，只要通过它进人关闭状态，就无法恢复了。</li><li>后续调用next ()会显示done: true状态，而提供的任何返回值都不会被存储或传播:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">        <span class="keyword">yield</span> x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 1 &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><h3 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h3><ul><li>throw()方法会在暂停的时候将一个提供的错误注人到生成器对象中。如果错误未被处理，生成器就会关闭。</li><li>假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。</li><li>错误处理会跳过对应的yield。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">yield</span> x; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); </span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 1&#125; </span></span><br><span class="line">g.throw(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 3&#125;</span></span><br></pre></td></tr></table></figure><p>230</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代与迭代器&quot;&gt;&lt;a href=&quot;#迭代与迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代与迭代器&quot;&gt;&lt;/a&gt;迭代与迭代器&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript集合引用类型——WeakSet</title>
    <link href="http://example.com/2021/10/18/js-15-5/"/>
    <id>http://example.com/2021/10/18/js-15-5/</id>
    <published>2021-10-18T06:21:19.000Z</published>
    <updated>2021-10-18T06:42:31.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h1><ul><li>使用new关键字实例化一个空的WeakSet:</li><li><strong>弱集合中的值只能是object或者继承自object的类型</strong>，尝试使用非对象设置值会抛出TypeError。</li><li>如果想在初始化时填充弱集合，则构造函数可以接收-一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line">    val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line">    val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, val2, val3]); </span><br><span class="line">alert(ws1.has(val1)); <span class="comment">// true </span></span><br><span class="line">alert(ws1.has(val2)); <span class="comment">// true </span></span><br><span class="line">alert(ws1.has(val3)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet </span></span><br><span class="line"><span class="keyword">typeof</span> ws2; </span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作值</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;val1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([stringVal]); </span><br><span class="line">alert(ws3.has(stringVal)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><ul><li>初始化之后可以使用add()再添加新值，可以使用has()查询，还可以使用delete()删除:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line">    val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false </span></span><br><span class="line">ws.add(val1)</span><br><span class="line"> .add(val2); </span><br><span class="line">alert(ws.has(val1)); <span class="comment">// true </span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true </span></span><br><span class="line">ws.delete(val1); <span class="comment">// 只删除这一个值</span></span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false </span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="弱值"><a href="#弱值" class="headerlink" title="弱值"></a>弱值</h1><p>原理同WeakMap</p><h1 id="不可迭代值"><a href="#不可迭代值" class="headerlink" title="不可迭代值"></a>不可迭代值</h1><ul><li>Weakset中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。</li><li>WeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本API&quot;&gt;&lt;a href=&quot;#基本API&quot; class=&quot;headerlink&quot; title=&quot;基本API&quot;&gt;&lt;/a&gt;基本API&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用new关键字实例化一个空的WeakSet:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弱集合中的值只能是ob</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    <category term="WeakSet" scheme="http://example.com/categories/WeakSet/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript集合引用类型——Set</title>
    <link href="http://example.com/2021/10/18/js-15-4/"/>
    <id>http://example.com/2021/10/18/js-15-4/</id>
    <published>2021-10-18T05:56:01.000Z</published>
    <updated>2021-10-18T06:19:01.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h1><ul><li>创建的同时初始化实例：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组初始化集合 </span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">alert(s1.size); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line">alert(s2.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>初始化之后，可以使用：<ul><li>add ()增加值；</li><li>has()查询；</li><li>size取得元素数量；</li><li>delete()删除元素；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(s.size); <span class="comment">// 0 </span></span><br><span class="line">s.add(<span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .add(<span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(s.size); <span class="comment">// 2 </span></span><br><span class="line">s.delete(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(s.has(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(s.size); <span class="comment">// 1 </span></span><br><span class="line">s.clear(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(s.has(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(s.size); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><ul><li>Set 可以包含任何 JavaScript 数据类型作为值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">s.add(functionVal); </span><br><span class="line">s.add(symbolVal); </span><br><span class="line">s.add(objectVal); </span><br><span class="line">alert(s.has(functionVal)); <span class="comment">// true </span></span><br><span class="line">alert(s.has(symbolVal)); <span class="comment">// true </span></span><br><span class="line">alert(s.has(objectVal)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// SameValueZero 检查意味着独立的实例不会冲突</span></span><br><span class="line">alert(s.has(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;, </span><br><span class="line">    arrVal = []; </span><br><span class="line">s.add(objVal); </span><br><span class="line">s.add(arrVal); </span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line">alert(s.has(objVal)); <span class="comment">// true </span></span><br><span class="line">alert(s.has(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>add()和delete ()操作是幂等的；</li><li>delete()返回一个布尔值，表示集合中是否存在要删除的值:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">alert(s.size); <span class="comment">// 1 </span></span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">alert(s.size); <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h1><ul><li>集合实例可以提供一个迭代器( Iterator ),能以插入顺序生成集合内容。</li><li>可以通过values()方法及其别名方法keys() (或者Symbol. iterator属性，它引用values() )取得这个迭代器:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">alert(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true </span></span><br><span class="line">alert(s.keys === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123; </span><br><span class="line"> alert(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="built_in">Symbol</span>.iterator]()) &#123; </span><br><span class="line"> alert(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3</span></span><br></pre></td></tr></table></figure><ul><li>values ()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="built_in">console</span>.log([...s]); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;] </span></span><br></pre></td></tr></table></figure><ul><li>集合的entries()方法返回一个迭代器，可以按照插人顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;] </span></span><br></pre></td></tr></table></figure><ul><li>如果不使用迭代器，而是使用回调方式，则可以调用集合的forEach() 方法并传人回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">s.forEach(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// val1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// val2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本API&quot;&gt;&lt;a href=&quot;#基本API&quot; class=&quot;headerlink&quot; title=&quot;基本API&quot;&gt;&lt;/a&gt;基本API&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;创建的同时初始化实例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    <category term="Set" scheme="http://example.com/categories/Set/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript集合引用类型——WeakMap</title>
    <link href="http://example.com/2021/10/17/js-15-3/"/>
    <id>http://example.com/2021/10/17/js-15-3/</id>
    <published>2021-10-17T10:42:00.000Z</published>
    <updated>2021-10-18T05:51:11.776Z</updated>
    
    <content type="html"><![CDATA[<ul><li>WeakMap是Map 的“兄弟”类型,其API也是Map的子集。</li><li>WeakMap中的”weak”(弱).描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。</li></ul><h1 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h1><ul><li>可以使用 new 关键字实例化一个空的 WeakMap：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>弱映射中的键只能是 Object 或者继承自 Object的类型,尝试使用非对象设置键会抛出TypeError。</strong></li><li>值的类型没有限制。</li><li>如果想在初始化时填充弱映射，则<strong>构造函数可以接收一个可迭代对象，其中需要包含键/值对数组</strong>。可迭代对象中的每个键/值都会按照迭代顺序插人新实例中:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line">    key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 使用嵌套数组初始化弱映射</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [key2, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">alert(wm1.get(key1)); <span class="comment">// val1 </span></span><br><span class="line">alert(wm1.get(key2)); <span class="comment">// val2 </span></span><br><span class="line">alert(wm1.get(key3)); <span class="comment">// val3 </span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key </span></span><br><span class="line"><span class="keyword">typeof</span> wm2; </span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;key1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    stringKey, <span class="string">&quot;val1&quot;</span> </span><br><span class="line">]); </span><br><span class="line">alert(wm3.get(stringKey)); <span class="comment">// &quot;val1&quot; </span></span><br></pre></td></tr></table></figure><ul><li>初始化之后可以使用set ()再添加键/值对，可以使用get ()和has()查询，还可以使用delete()删除:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line">    key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false </span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// undefined </span></span><br><span class="line">wm.set(key1, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line">  .set(key2, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line">alert(wm.has(key1)); <span class="comment">// true </span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// Matt </span></span><br><span class="line">wm.delete(key1); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false </span></span><br><span class="line">alert(wm.has(key2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h1><ul><li>WeakMap 中“weak”表示弱映射的键不属于正式的引用，不会阻止垃圾回收；</li><li>只要键存在，键/值对就会存在于映射中，并被当作对值的引用；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line">wm.set(&#123;&#125;, <span class="string">&quot;val&quot;</span>); </span><br></pre></td></tr></table></figure><p>set ()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。</p><h1 id="不可迭代键"><a href="#不可迭代键" class="headerlink" title="不可迭代键"></a>不可迭代键</h1><ul><li>因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。</li><li>WeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;WeakMap是Map 的“兄弟”类型,其API也是Map的子集。&lt;/li&gt;
&lt;li&gt;WeakMap中的”weak”(弱).描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基本API&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    <category term="WeakMap" scheme="http://example.com/categories/WeakMap/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Javascript——Object和Map比较分析</title>
    <link href="http://example.com/2021/10/17/js-tips-1/"/>
    <id>http://example.com/2021/10/17/js-tips-1/</id>
    <published>2021-10-17T06:18:22.000Z</published>
    <updated>2021-10-17T08:47:39.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h1><ul><li>Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对;</li></ul><h1 id="插入性能"><a href="#插入性能" class="headerlink" title="插入性能"></a>插入性能</h1><ul><li>向object和 Map中插入新键/值对的消耗大致相当，不过插人Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</li></ul><h1 id="查找速度"><a href="#查找速度" class="headerlink" title="查找速度"></a>查找速度</h1><ul><li>与插入不同，从大型object和 Map中查找键/值对的性能差异极小，但如果只包含少量键/值对,则object有时候速度更快。在把object 当成数组使用的情况下（比如使用连续整数作为属性)，浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言,查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择Obiect更好一些。</li></ul><h1 id="删除性能"><a href="#删除性能" class="headerlink" title="删除性能"></a>删除性能</h1><ul><li>使用delete删除object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此,出现了一些伪删除对象属性的操作，包括把属性值设置为undefined或null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存占用&quot;&gt;&lt;a href=&quot;#内存占用&quot; class=&quot;headerlink&quot; title=&quot;内存占用&quot;&gt;&lt;/a&gt;内存占用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Object" scheme="http://example.com/categories/Object/"/>
    
    <category term="Map" scheme="http://example.com/categories/Map/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript集合引用类型——Map</title>
    <link href="http://example.com/2021/10/08/js-15-2/"/>
    <id>http://example.com/2021/10/08/js-15-2/</id>
    <published>2021-10-08T09:24:41.000Z</published>
    <updated>2021-10-08T10:10:15.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h1><ul><li>使用 new 关键字和 Map 构造函数可以创建一个空映射；</li><li>如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组：</li><li>初始化之后，可以使用 set()方法再添加键/值对；</li><li>可以使用 get()和 has()进行查询；</li><li>可以通过 size 属性获取映射中的键/值对的数量；</li><li>可以使用 delete()和 clear()删除值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">alert(m1.size); <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// undefined </span></span><br><span class="line">alert(m.size); <span class="comment">// 0 </span></span><br><span class="line">m.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt </span></span><br><span class="line">alert(m.size); <span class="comment">// 2 </span></span><br><span class="line">m.delete(<span class="string">&quot;firstName&quot;</span>); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(m.size); <span class="comment">// 1 </span></span><br><span class="line">m.clear(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.size); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>Map 可以使用任何 JavaScript 数据类型作为键；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">m.set(functionKey, <span class="string">&quot;functionValue&quot;</span>); </span><br><span class="line">m.set(symbolKey, <span class="string">&quot;symbolValue&quot;</span>); </span><br><span class="line">m.set(objectKey, <span class="string">&quot;objectValue&quot;</span>); </span><br><span class="line">alert(m.get(functionKey)); <span class="comment">// functionValue </span></span><br><span class="line">alert(m.get(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line">alert(m.get(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时依然保持不变；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;, </span><br><span class="line">    objVal = &#123;&#125;, </span><br><span class="line">    arrKey = [], </span><br><span class="line">    arrVal = []; </span><br><span class="line">m.set(objKey, objVal); </span><br><span class="line">m.set(arrKey, arrVal); </span><br><span class="line">objKey.foo = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrKey.push(<span class="string">&quot;foo&quot;</span>); </span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(m.get(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure><h1 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h1><ul><li>Map 实例会维护键值对的插入顺序；</li><li>映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过**entries()**方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>entries()是默认迭代器，可以直接对映射实例使用扩展操作，把映射转换为数组；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure><ul><li><strong>forEach(callback,opt_thisArg)方法同样可以迭代每个键/值对，第一个参数传入一个回调方法</strong>；</li><li>第二个参数用于重写回调函数内部的this值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// key1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// key2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// key3 -&gt; val3 </span></span><br></pre></td></tr></table></figure><ul><li><strong>keys()和 values()分别返回以插入顺序生成键和值的迭代器；</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123; </span><br><span class="line">    alert(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// key1 </span></span><br><span class="line"><span class="comment">// key2 </span></span><br><span class="line"><span class="comment">// key3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123; </span><br><span class="line">    alert(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value1 </span></span><br><span class="line"><span class="comment">// value2 </span></span><br><span class="line"><span class="comment">// value3 </span></span><br></pre></td></tr></table></figure><ul><li>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改；</li><li>修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.keys()) &#123; </span><br><span class="line">    key = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line">    alert(key); <span class="comment">// newKey </span></span><br><span class="line">    alert(m1.get(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line">    [keyObj, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本API&quot;&gt;&lt;a href=&quot;#基本API&quot; class=&quot;headerlink&quot; title=&quot;基本API&quot;&gt;&lt;/a&gt;基本API&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用 new 关键字和 Map 构造函数可以创建一个空映射；&lt;/li&gt;
&lt;li&gt;如果想在创建的同时初始化</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Map" scheme="http://example.com/categories/Map/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript——Math对象</title>
    <link href="http://example.com/2021/09/22/js-14-2/"/>
    <id>http://example.com/2021/09/22/js-14-2/</id>
    <published>2021-09-22T08:26:55.000Z</published>
    <updated>2021-09-22T09:01:58.242Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Math 对象上提供的计算要比直接在JavaScript实现的快得多，因为<strong>Math对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令</strong></li></ul><h1 id="Math对象属性"><a href="#Math对象属性" class="headerlink" title="Math对象属性"></a>Math对象属性</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/22/js-14-2/pic4.png" class title="# tu1"><h1 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max()方法"></a>min() 和 max()方法</h1><ul><li><strong>min()和 max()方法用于确定一组数值中的最小值和最大值；</strong></li><li>这两个方法都接收任意多个参数；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">// 54 </span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="built_in">console</span>.log(min); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]; </span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure><h1 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/22/js-14-2/pic1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>)); <span class="comment">// 26 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>)); <span class="comment">// 25 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.4</span>)); <span class="comment">// 0.4000000059604645 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.5</span>)); <span class="comment">// 0.5 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.5</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>)); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h1 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h1><ul><li><strong>Math.random()方法ᤄ回一个 0~1 范围内的随机数</strong></li><li>从一组整数中随机选择一个数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total_number_of_choices + first_possible_value)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 1~10 范围内随机选择一个数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//从 2~10 范围内随机选择一个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> choices = upperValue - lowerValue + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> num = selectFrom(<span class="number">2</span>,<span class="number">10</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 2~10 范围内的值，其中包含 2 和 10</span></span><br></pre></td></tr></table></figure><ul><li>如果是为了加密而需要生成随机数，建议使用 window.crypto.getRandomValues()</li></ul><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/22/js-14-2/pic2.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Math 对象上提供的计算要比直接在JavaScript实现的快得多，因为&lt;strong&gt;Math对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Math对象属性&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Global对象" scheme="http://example.com/categories/Global%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript——Global对象</title>
    <link href="http://example.com/2021/09/15/js-14-1/"/>
    <id>http://example.com/2021/09/15/js-14-1/</id>
    <published>2021-09-15T13:42:02.000Z</published>
    <updated>2021-09-22T08:24:08.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>代码不会显式地访问它；</li><li>Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法；</li><li>在全局作用域中定义的变量和函数都会变成 Global 对象的属性；</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="URL编码方式"><a href="#URL编码方式" class="headerlink" title="URL编码方式"></a>URL编码方式</h2><img lazyload src="/images/loading.svg" data-src="/2021/09/15/js-14-1/pic1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>; </span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/09/15/js-14-1/pic2.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>; </span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// http:// www.wrox.com/illegal value.js#start </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure><h2 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h2><ul><li><strong>它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>); </span><br><span class="line"><span class="comment">//======等价于======</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置；</li><li>通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><ul><li>可以在 eval()内部定义一个函数或变量，然后在外部代码中引用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span>); </span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><ul><li>通过 eval()定义的任何变量和函数都不会被提升，它们只是在 eval()执行的时候才会被创建</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;let msg = &#x27;hello world&#x27;;&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">// Reference Error: msg is not defined</span></span><br></pre></td></tr></table></figure><h2 id="Global对象属性"><a href="#Global对象属性" class="headerlink" title="Global对象属性"></a>Global对象属性</h2><ul><li>像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性；</li><li>所有原生引用类型构造函数，比如 Object 和 Function，也都是 Global 对象的属性；</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/09/15/js-14-1/pic3.png" class title="# tu1"><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul><li>ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.color); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure><ul><li>当一个函数在没有明确（通过成为౼个对象的方法，或者通过 call()/apply()）指定 this 值的情况下执行时，this 值等于Global 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;代码不会显式地访问它；&lt;/li&gt;
&lt;li&gt;Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法；&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Global对象" scheme="http://example.com/categories/Global%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript字符串操作方法</title>
    <link href="http://example.com/2021/09/13/js-13-1/"/>
    <id>http://example.com/2021/09/13/js-13-1/</id>
    <published>2021-09-13T08:17:23.000Z</published>
    <updated>2021-09-13T14:26:13.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串拼接方法"><a href="#字符串拼接方法" class="headerlink" title="字符串拼接方法"></a>字符串拼接方法</h1><ul><li><strong>concat()用于将一个或多个字符串拼接成一个新字符串</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>可以接收任意多个参数</strong>，因此可以一次性拼接多个字符串；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;hello world!&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h1 id="从字符串中提取子字符串的方法"><a href="#从字符串中提取子字符串的方法" class="headerlink" title="从字符串中提取子字符串的方法"></a>从字符串中提取子字符串的方法</h1><ul><li><strong>slice()、substr()和 substring()；</strong></li><li>这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数；</li><li>不会修改调用它们的字符串，而只会返回提取到的原始新字符串值；</li></ul><table><thead><tr><th align="center">方法</th><th align="center">参数一</th><th align="center">参数二</th></tr></thead><tbody><tr><td align="center">slice()</td><td align="center">子字符串开始的位置</td><td align="center">提取结束的位置</td></tr><tr><td align="center">substr()</td><td align="center">子字符串开始的位置</td><td align="center">返回的子字符串数量</td></tr><tr><td align="center">substring()</td><td align="center">子字符串开始的位置</td><td align="center">提取结束的位置</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>当某个参数是负值时：</strong><ul><li>slice()方法<strong>将所有负值参数都当成字符串长度加上负参数值</strong>；</li><li>substr()方法<strong>将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0</strong>；</li><li>substring()方法会<strong>将所有负参数值都转换为 0</strong>;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(-<span class="number">3</span>)); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;hel&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure><h1 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h1><ul><li>有两个方法用于在字符串中定位子字符串：<strong>indexOf()和 lastIndexOf()</strong></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/09/13/js-13-1/p1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ul><li>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h1 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h1><ul><li>startsWith()、endsWith()和 includes()用于判断字符串中是否包含另一个字符串的方法</li><li>startsWith()检查开始于索引 0 的匹配项</li><li>endsWith()检查开始于索引(string.length - substring.length)的匹配项</li><li>includes()检查整个字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置；</li><li>如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符</li><li>endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h1><ul><li>这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果；</li><li>trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot; hello world &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim(); </span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot; hello world &quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h1 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat() 方法"></a>repeat() 方法</h1><ul><li>这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>); </span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure><h1 id="padStart-和-padEnd-方法"><a href="#padStart-和-padEnd-方法" class="headerlink" title="padStart() 和 padEnd() 方法"></a>padStart() 和 padEnd() 方法</h1><ul><li>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件；</li><li>这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>)); <span class="comment">// &quot;foo &quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure><ul><li>可选的第二个参数并不限于一个字符；</li><li>如果提供了多个字符的字符串，则会将其拼接并截断以匹配<br>指定长度；</li><li>如果长度小于或等于字符串长度，则会返回原始字符串；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h1 id="字符串迭代与解构"><a href="#字符串迭代与解构" class="headerlink" title="字符串迭代与解构"></a>字符串迭代与解构</h1><ul><li>字符串的原型上暴露了一个**@@iterator方法**，表示可以迭代字符串的每个字符；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在 for-of 循环中可以通过这个迭代器按序访问每个字符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="comment">// c </span></span><br><span class="line"><span class="comment">// d </span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><h1 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h1><ul><li>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()</li><li>toLowerCase()和toUpperCase()方法是原来就有的方法；</li><li>toLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现；</li></ul><h1 id="字符串模式匹配方法"><a href="#字符串模式匹配方法" class="headerlink" title="字符串模式匹配方法"></a>字符串模式匹配方法</h1><ul><li><strong>match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同；</strong></li><li>match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"><span class="comment">// 等价于 pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern); </span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// &quot;cat&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><strong>search()方法：唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象；</strong></li><li>这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。</li><li>search()始终从字符串开头向后匹配模式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pos = text.search(<span class="regexp">/at/</span>); </span><br><span class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li><strong>replace()方法：接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数</strong></li><li>如果第一个参数是字符串，那么只会替换第一个子字符串。</li><li>要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.replace(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;cond, bat, sat, fat&quot; </span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure><ul><li>replace()的第二个参数可以是一个函数。</li><li>在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串；</li><li>在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串；</li><li>这个函数应该返回一个字符串，表示应该把匹配项替换成什么；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span>(match) &#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>)); </span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h1><ul><li>这个方法比较两个字符串，返回如下 3 个值中的一个；<ul><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）</li><li>如果字符串与字符串参数相等，则返回 0。</li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串拼接方法&quot;&gt;&lt;a href=&quot;#字符串拼接方法&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接方法&quot;&gt;&lt;/a&gt;字符串拼接方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;concat()用于将一个或多个字符串拼接成一个新字符串&lt;/strong</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="字符串" scheme="http://example.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript集合引用类型——Array</title>
    <link href="http://example.com/2021/09/08/js-15-1/"/>
    <id>http://example.com/2021/09/08/js-15-1/</id>
    <published>2021-09-08T09:12:06.000Z</published>
    <updated>2021-10-08T09:18:23.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><h2 id="①-使用-Array-构造函数"><a href="#①-使用-Array-构造函数" class="headerlink" title="① 使用 Array 构造函数"></a>① 使用 Array 构造函数</h2><ul><li>在使用 Array 构造函数时，也可以省略 new 操作符；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><ul><li>如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><ul><li>也可以给 Array 构造函数传入要保存的元素：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="②-使用数组字面量（array-literal）表示法："><a href="#②-使用数组字面量（array-literal）表示法：" class="headerlink" title="② 使用数组字面量（array literal）表示法："></a>② 使用数组字面量（array literal）表示法：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 创建一个包含 2 个元素的数组</span></span><br></pre></td></tr></table></figure><h2 id="③-from"><a href="#③-from" class="headerlink" title="③ from()"></a>③ from()</h2><ul><li><p>from()用于将类数组结构转换为数组实例；</p></li><li><p>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] </span></span><br><span class="line"><span class="comment">// 可以使用 from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line">                    .set(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>) </span><br><span class="line">                    .add(<span class="number">2</span>) </span><br><span class="line">                    .add(<span class="number">3</span>) </span><br><span class="line">                    .add(<span class="number">4</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(m)); <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1); </span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line">alert(a1 === a2); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123; </span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; </span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="number">1</span>: <span class="number">2</span>, </span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>, </span><br><span class="line">    <span class="number">3</span>: <span class="number">4</span>, </span><br><span class="line">    length: <span class="number">4</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrayLikeObject)); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.from()还接收第二个可选的映射函数参数；</p><ul><li>这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组；</li></ul></li><li><p>还可以接收第三个可选参数，用于指定映射函数中 this 的值；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="built_in">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 4, 9, 16] </span></span><br><span class="line"><span class="built_in">console</span>.log(a3); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><h2 id="④-of"><a href="#④-of" class="headerlink" title="④ of()"></a>④ of()</h2><ul><li><strong>Array.of()可以把一组参数转换为数组</strong></li><li>用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h1 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h1><ul><li>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）；</li><li>ECMAScript 会将逗号之间相应索引位置的值当成空位；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,,,,]; <span class="comment">// 创建包含 5 个元素的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(options.length); <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(options); <span class="comment">// [,,,,,]</span></span><br></pre></td></tr></table></figure><ul><li>ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(option === <span class="literal">undefined</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// false </span></span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Array</span>.from([,,,]); <span class="comment">// 使用 ES6 的 Array.from()创建的包含 3 个空位的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123; </span><br><span class="line"> alert(val === <span class="literal">undefined</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Array</span>.of(...[,,,])); <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> options.entries()) &#123; </span><br><span class="line"> alert(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h1 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h1><ul><li>要取得或设置数组的值，需要使用中括Ձ并提供相应值的数字索引：</li><li>如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]，则数组长度会自动扩展到该索引值加 1；</li><li>数组中最后一个元素的索引始终是 length - 1；</li><li>数组最多可以包含 4294967295 个元素；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>; <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>; <span class="comment">// 添加第四项</span></span><br><span class="line">alert(colors.length); <span class="comment">// 3 </span></span><br><span class="line">alert(names.length); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h1 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h1><ul><li>ECMAScript 提供了 Array.isArray()方法，的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的；</li></ul><h1 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h1><ul><li>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()；</li><li>keys()返回数组索引的迭代器；</li><li>values()返回数组元素的迭代器；</li><li>entries()返回索引/值对的迭代器；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries()); </span><br><span class="line"><span class="built_in">console</span>.log(aKeys); <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line"><span class="built_in">console</span>.log(aValues); <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries); <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure><h1 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h1><ul><li>批量复制方法 copyWithin()；</li><li>填充数组方法 fill()；</li><li>这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引；</li></ul><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><ul><li>fill()方法可以向一个已有的数组中插入全部或部分相同的值；<ul><li>开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾；</li><li>负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引；</li><li>fill()默认忽略超出数组边界、零长度及方向相反的索引范围；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.fill(<span class="number">5</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 8, 8, 8, 0];</span></span><br><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><ul><li>copyWithin()会按照指定范围ุ复制数组中的部分内容，然后将它们插入到指定索引开始的位置；</li><li>copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line">reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>); </span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] </span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.copyWithin(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line">reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset() </span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line">reset(); </span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure><h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><ul><li>所有对象都有 toLocaleString()、toString()和 valueOf()方法；</li><li>在调用数组的 toLocaleString()方法时，会得到一个以逗号分隔的数组值的字符串；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">alert(colors.toString()); <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure><ul><li>首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，<strong>因为 alert()期待字符串</strong>，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果；</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123; </span><br><span class="line">    <span class="function"><span class="title">toLocaleString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>; </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person2 = &#123; </span><br><span class="line">    <span class="function"><span class="title">toLocaleString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>; </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line">alert(people); <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toString()); <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toLocaleString()); <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure><ul><li>如果数组中某一项是null或undefined，则在join()、toLocaleString()、toString()、valueOf()返回的结果中会以空字符串表示</li></ul><h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic2.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.push(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line">alert(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">// black </span></span><br><span class="line">alert(colors.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic3.png" class title="# tu1"><ul><li>使用shift()和 push()，可以把数组当成<strong>队列</strong>来使用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.push(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line">alert(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift(); <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item); <span class="comment">// red </span></span><br><span class="line">alert(colors.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>使用 unshift()和 pop()，可以在相反方向上模拟队列：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.unshift(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line">alert(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.unshift(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line">alert(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">// green </span></span><br><span class="line">alert(colors.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic4.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values); <span class="comment">// 5,4,3,2,1 </span></span><br></pre></td></tr></table></figure><ul><li>sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。</li><li>即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values); <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure><ul><li>sort()方法可以接收一个<strong>比较函数</strong></li><li>比较函数接收两个参数：<ul><li>如果第一个参数应该排在第二个参数前面，就返回负值；* 如果两个参数相等，就返回 0；</li><li>如果第一个参数应该排在第二个参数后面，就返回正值；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values); <span class="comment">// 0,1,5,10,15 </span></span><br></pre></td></tr></table></figure><ul><li>比较函数还可简写为一个箭头函数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? <span class="number">1</span> : a &gt; b ? -<span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0 </span></span><br></pre></td></tr></table></figure><h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat()方法"></a>concat()方法</h2><ul><li>可以在现有数组全部元素基础上创建一个新数组；</li><li>原理：它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾,最后返回这个新构建的数组；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] </span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>, </span><br><span class="line">    length: <span class="number">2</span>, </span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>, </span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span> </span><br><span class="line">&#125;; </span><br><span class="line">newColors[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, newColors); </span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.concat(moreNewColors); </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] </span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice()方法"></a>slice()方法</h2><ul><li>用于创建一个包含原有数组中一个或多个元素的新数组，操作不影响原始数组；</li><li>接收一个或两个参数：返回元素的开始索引和结束索引；<ul><li>如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素；</li><li>如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.slice(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> colors3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">alert(colors2); <span class="comment">// green,blue,yellow,purple </span></span><br><span class="line">alert(colors3); <span class="comment">// green,blue,yellow </span></span><br></pre></td></tr></table></figure><h2 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a>splice()方法</h2><ul><li>在数组中间插入元素；</li><li>删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量；</li><li>插入：需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素，第三个参数之后还可以传第四个、第五个参数，乃至任意多<br>个要插入的元素；</li><li>替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,blue </span></span><br><span class="line">alert(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line">alert(colors); <span class="comment">// green,yellow,orange,blue </span></span><br><span class="line">alert(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line">alert(colors); <span class="comment">// green,red,purple,orange,blue </span></span><br><span class="line">alert(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h1 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h1><ul><li>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索；</li></ul><h2 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h2><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic5.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>)); <span class="comment">// true </span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;]; </span><br><span class="line"><span class="keyword">let</span> morePeople = [person]; </span><br><span class="line">alert(people.indexOf(person)); <span class="comment">// -1 </span></span><br><span class="line">alert(morePeople.indexOf(person)); <span class="comment">// 0 </span></span><br><span class="line">alert(people.includes(person)); <span class="comment">// false </span></span><br><span class="line">alert(morePeople.includes(person)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h2><ul><li><p>断言函数接收 3 个参数：<strong>元素、索引和数组本身</strong>；</p><ul><li>元素是数组中当前଼索的元素；</li><li>索引是当前元素的索引；</li><li>数组就是正在଼索的数组</li></ul></li><li><p>find()和 findIndex()方法使用了断言函数：</p><ul><li>这两个方法都从数组的最小索引开始；</li><li>find()返回第一个匹配的元素；</li><li>findIndex()返回第一个匹配元素的索引</li><li>这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [ </span><br><span class="line">    &#123; </span><br><span class="line">        name: <span class="string">&quot;Matt&quot;</span>, </span><br><span class="line">        age: <span class="number">27</span> </span><br><span class="line">    &#125;, </span><br><span class="line">    &#123; </span><br><span class="line">        name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">        age: <span class="number">29</span> </span><br><span class="line">    &#125; </span><br><span class="line">]; </span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125; </span></span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic6.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line">alert(everyResult); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line">alert(someResult); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line">alert(filterResult); <span class="comment">// 3,4,5,4,3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>); </span><br><span class="line">alert(mapResult); <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 执行某些操作 </span></span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h1 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/09/08/js-15-1/pic7.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum1 = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur); </span><br><span class="line">alert(sum); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum2 = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> prev + cur; </span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); <span class="comment">// 15 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建数组&quot;&gt;&lt;a href=&quot;#创建数组&quot; class=&quot;headerlink&quot; title=&quot;创建数组&quot;&gt;&lt;/a&gt;创建数组&lt;/h1&gt;&lt;h2 id=&quot;①-使用-Array-构造函数&quot;&gt;&lt;a href=&quot;#①-使用-Array-构造函数&quot; class=&quot;header</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Array" scheme="http://example.com/categories/Array/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十五）集合引用类型</title>
    <link href="http://example.com/2021/08/13/js-15/"/>
    <id>http://example.com/2021/08/13/js-15/</id>
    <published>2021-08-13T07:04:36.000Z</published>
    <updated>2021-10-20T05:44:03.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ul><li>Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据；</li><li>创建 Object 的实例有两种方式：<ul><li>使用 new 操作符和 Object 构造函数；</li><li>使用对象字面量（object literal）表示法；</li></ul></li><li>在对象字面量表示法中，属性名可以是字符串或数值，但数值属性会自动转换为字符串；</li><li>在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">    age: <span class="number">29</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。</li><li>在使用中括号时，要在括号内使用属性名的<strong>字符串形式</strong>；</li><li>使用中括号的主要优势就是可以通过变量访问属性；</li><li>点语法是首选的属性存取方式，除非访问属性时必须使用变量；</li></ul><h1 id><a href="#" class="headerlink" title></a><a href="/2021/09/08/js-15-1/" title="Array">Array</a></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a><a href="/2021/10/08/js-15-2/" title="Map">Map</a></h1><h1 id="-2"><a href="#-2" class="headerlink" title></a><a href="/2021/10/17/js-15-3/" title="WeakMap">WeakMap</a></h1><h1 id="-3"><a href="#-3" class="headerlink" title></a><a href="/2021/10/18/js-15-4/" title="Set">Set</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据；&lt;/li&gt;
&lt;li&gt;创建 </summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十四）单例内置对象</title>
    <link href="http://example.com/2021/08/13/js-14/"/>
    <id>http://example.com/2021/08/13/js-14/</id>
    <published>2021-08-13T07:04:24.000Z</published>
    <updated>2021-09-22T09:03:42.930Z</updated>
    
    <content type="html"><![CDATA[<ul><li>定义：任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象</li><li>这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了；</li></ul><h1 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h1><a href="/2021/09/15/js-14-1/" title="Global对象">Global对象</a><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><a href="/2021/09/22/js-14-2/" title="Math对象">Math对象</a>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;定义：任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象&lt;/li&gt;
&lt;li&gt;这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Global&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十三）原始值包装类型</title>
    <link href="http://example.com/2021/08/13/js-13/"/>
    <id>http://example.com/2021/08/13/js-13/</id>
    <published>2021-08-13T07:04:14.000Z</published>
    <updated>2021-09-13T08:19:06.392Z</updated>
    
    <content type="html"><![CDATA[<ul><li>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。</li><li>每当用到౼个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//========以上代码实际运行步骤===========</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>引用类型与原始值包装类型的主要区别在于对象的生命周期；</li><li>不能在运行时给原始值添加属性和方法；</li></ul><h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><ul><li>Boolean 是对应布尔值的引用类型；</li><li>要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false；</li><li>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false；</li><li>toString()方法被调用时也会被覆盖，返回字符串”true”或”false”；</li><li>所有对象在布尔表达式中都会自动转换为 true；</li><li>Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject); <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue); <span class="comment">// boolean </span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><ul><li>创建Number对象就使用 Number 构造函数并传入一个<br>数值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>不建议直接实例化 Number 对象，因为在处理原始数值和引用数值时，typeof 和 instacnceof 操作符会返回不同的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject); <span class="comment">// &quot;object&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue); <span class="comment">// &quot;number&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><ul><li>Number 类型重写了 valueOf()、toLocaleString()和 toString()方法</li><li><strong>valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串</strong></li><li>toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toString()); <span class="comment">// &quot;10&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h2><ul><li>toFixed()方法返回包含指定小数点位数的数值字符串；如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的</li><li>toFixed()方法可以表示有 0~20 个小数位的数值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure><h2 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h2><ul><li>返回以科学记数法（也称为指数记数法）表示的数值字符串</li><li>接收一个参数，表示结果中小数的位数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>)); <span class="comment">// &quot;1.0e+1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h2><ul><li>会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式</li><li>接收一个参数，表示结果中数字的总位数（不包含指数）</li><li>本质上，toPrecision()方法会根据数值和精度来决定调用 toFixed()还是 toExponential()</li><li>为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>String 是对应字符串的引用类型；</li><li>要创建一个 String 对象，<strong>使用 String 构造函数并传入一个数值</strong></li><li>String 对象的方法可以在所有字符串原始值上调用</li><li>3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值；</li><li>每个 String 对象都有一个 .length 属性，表示字符串中字符的数量；</li><li>即使字符串中包含双字节字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.length); <span class="comment">// &quot;11&quot;</span></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a><a href="/2021/09/13/js-13-1/" title="字符串操作方法">字符串操作方法</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。&lt;/li&gt;
&lt;li&gt;每当用到౼个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十二）RegExp</title>
    <link href="http://example.com/2021/08/13/js-12/"/>
    <id>http://example.com/2021/08/13/js-12/</id>
    <published>2021-08-13T07:04:00.000Z</published>
    <updated>2021-09-13T08:34:11.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h2><ul><li>正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用；</li><li>每个正则表达式可以ࣛ带零个或多个 flags（标记），用于控制正则表达式的行为。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flages;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">flags</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">g</td><td align="center">全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的f内容就结束</td></tr><tr><td align="center">i</td><td align="center">不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写</td></tr><tr><td align="center">m</td><td align="center">多行模式，表示查找到一行文本末尾时会继续查找</td></tr><tr><td align="center">y</td><td align="center">粘附模式，表示只查找从 lastIndex 开始及之后的字符串</td></tr><tr><td align="center">u</td><td align="center">Unicode 模式，启用 Unicode 匹配</td></tr><tr><td align="center">s</td><td align="center">dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）</td></tr></tbody></table><ul><li>元字符包括：( [ { \ ^ $ | ) ] } ? * + .</li><li>所有元字符在模式中也必须转义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>; </span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>; </span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure><h1 id="RegExp-实ׁኔᙝ"><a href="#RegExp-实ׁኔᙝ" class="headerlink" title="RegExp 实ׁኔᙝ"></a>RegExp 实ׁኔᙝ</h1><ul><li>global：布尔值，表示是否设置了 g 标记。</li><li>ignoreCase：布尔值，表示是否设置了 i 标记。</li><li>unicode：布尔值，表示是否设置了 u 标记。</li><li>sticky：布尔值，表示是否设置了 y 标记。</li><li>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li><li>multiline：布尔值，表示是否设置了 m 标记。</li><li>dotAll：布尔值，表示是否设置了 s 标记。</li><li>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li><li>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>; </span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source); <span class="comment">// &quot;\[bc\]at&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.flags); <span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><h1 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h1><ul><li>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用；<ul><li>这个方法只接收一个参数，即要应用模式的字符串</li><li>如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null</li><li>返回的数组包含两个额外的属性：index 和 input，index 是字符串中匹配模式的起始位置，input 是要查找的字符串</li></ul></li><li>如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text); </span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]); <span class="comment">// &quot; and dad and baby&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]); <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure><h1 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h1><ul><li>这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化；</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/08/13/js-12/pic1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============等价于==============</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_); <span class="comment">// this has been a short summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$`&quot;</span>]); <span class="comment">// this has been a </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]); <span class="comment">// summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]); <span class="comment">// short </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$+&quot;</span>]); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下：</li><li>input 属性中包含原始的字符串。</li><li>leftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。</li><li>lastMatch 属性包含ӛ配整个正则表达式的上一个字符串，即”short”。 </li><li>lastParen 属性包含捕获组的上一次匹配，即”s”。</li></ul><h1 id="局限模式"><a href="#局限模式" class="headerlink" title="局限模式"></a>局限模式</h1><p>下列特性目前还没有得到 ECMAScript 的支持：</p><ul><li>\A 和\Z 错（分别匹配字符串的开始和末尾）</li><li>联合及交叉类</li><li>原子组</li><li>x（忽略空格）匹配模式</li><li>条件式匹配</li><li>正则表达式注释</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;创建语法&quot;&gt;&lt;a href=&quot;#创建语法&quot; class=&quot;headerlink&quot; title=&quot;创建语法&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（十一）Date</title>
    <link href="http://example.com/2021/08/13/js-11/"/>
    <id>http://example.com/2021/08/13/js-11/</id>
    <published>2021-08-13T07:03:12.000Z</published>
    <updated>2021-08-15T14:39:59.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><ul><li>ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。</li><li>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。<ul><li>使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。</li></ul></li></ul><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><ul><li>要创建日期对象，就使用 new 操作符来调用 Date 构造函数</li><li>在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><ul><li>要基于其他日期和时间创建日期对象，必须传入其毫秒表示。</li><li>ECMAScript为此提供了两个辅助方法：<strong>Date.parse()和Date.UTC()</strong></li><li>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。规则如下：</li></ul><table><thead><tr><th align="center">格式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">月/日/年</td><td align="center">5/23/2021</td></tr><tr><td align="center">月名 日,年</td><td align="center">May 23,2021</td></tr><tr><td align="center">周几 月名 日 年 时:分:秒 时区</td><td align="center">Sun May 23 2021 00:00:00 GMT-0700</td></tr><tr><td align="center">YYYY-MM-DDTHH:mm:ss.sssZ</td><td align="center">2021-05-23T00:00:00</td></tr></tbody></table><ul><li>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN；</li><li>如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。</li><li>Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒这些参数中，只有前两个（年和月）是必需的；</li><li>如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。</li><li>ECMAScript 还提供了 Date.now()方法，ᤄ回表示方法执行时日期和时间的毫秒数。</li></ul><h1 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h1><ul><li>Date 类型重写了 toLocaleString()、toString()和 valueOf()方法；</li><li><strong>Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间</strong>，这通常意։着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息；</li><li><strong>toString()方法通常返回ࣛ时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的</strong>；</li><li><strong>Date 类型的 valueOf()方法಩本就不返回字符串，这个方法被重写后ᤄ回的是日期的毫秒表示</strong>。</li></ul><h1 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h1><table><thead><tr><th align="center">方法</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">toDateString()</td><td align="center">显示日期中的周几、月、日、年（格式特定于实现）</td></tr><tr><td align="center">toTimeString()</td><td align="center">显示日期中的时、分、秒和时区（格式特定于实现）</td></tr><tr><td align="center">toLocaleDateString()</td><td align="center">显示日期中的周几、月、日、年（格式特定于实现和地区）</td></tr><tr><td align="center">toLocaleTimeString()</td><td align="center">显示日期中的时、分、秒（格式特定于实现和地区）</td></tr><tr><td align="center">toUTCString()</td><td align="center">显示完整的 UTC 日期（格式特定于实现）</td></tr></tbody></table><h1 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h1><img lazyload src="/images/loading.svg" data-src="/2021/08/13/js-11/pic1.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/08/13/js-11/pic2.png" class title="# tu2">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本内容&quot;&gt;&lt;a href=&quot;#基本内容&quot; class=&quot;headerlink&quot; title=&quot;基本内容&quot;&gt;&lt;/a&gt;基本内容&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。&lt;/li&gt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记-数据类型（Object）</title>
    <link href="http://example.com/2021/07/21/js-5-5/"/>
    <id>http://example.com/2021/07/21/js-5-5/</id>
    <published>2021-07-21T12:01:59.000Z</published>
    <updated>2021-08-13T07:09:42.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li><strong>ES中对象是一组数据和功能的集合</strong></li><li>对象被认为是౼个特定引用类型的实例</li></ul><h1 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h1><ul><li>对象通过new操作符跟对象类型的名称来创建</li><li>如果没有参数，可以省略括号</li></ul><h1 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h1><table><thead><tr><th align="center">属性和方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">constructor</td><td align="center">用于创建当前对象的函数</td></tr><tr><td align="center">hasOwnProperty(propertyName)</td><td align="center">用于判断当前对象上是否存在给定属性</td></tr><tr><td align="center">isPrototypeOf(Object)</td><td align="center">用于判断当前对象是否是另一个对象的原型</td></tr><tr><td align="center">propertyIsEnumerable(propertyName)</td><td align="center">用于判断给定的属性是否可以使用for-in语句枚举</td></tr><tr><td align="center">toLocaleString()</td><td align="center">返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</td></tr><tr><td align="center">toString()</td><td align="center">返回对象的字符串表示</td></tr><tr><td align="center">valueOf()</td><td align="center">返回对象对应的字符串、数值或布尔值表示，通常与toString()返回值相同</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ES中对象是一组数据和功能的集合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对象被认为是౼个特定引用类型的实例&lt;/li</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记-数据类型（Symbol）</title>
    <link href="http://example.com/2021/07/21/js-5-4/"/>
    <id>http://example.com/2021/07/21/js-5-4/</id>
    <published>2021-07-21T12:01:47.000Z</published>
    <updated>2021-08-04T13:23:25.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul><li>Symbol为原始类型，可以使用typeof操作符进行检测</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mes = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mes)<span class="comment">//Symbol</span></span><br></pre></td></tr></table></figure><ul><li>Symbol(name)<ul><li>name作为对符号的描述</li><li>与符号定义或标识完全无关</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sys1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sys2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sys1 == sys2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>符号没有字面量语法</li><li>创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性</li><li>Symbol()不能与new关键字一起作为构造函数使用<ul><li>为了避免创建符号包装对象</li></ul></li><li>可以使用Object()函数创建符号包装对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//object</span></span><br><span class="line"><span class="keyword">let</span> sys = <span class="keyword">new</span> <span class="built_in">Symbol</span>();<span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> objsys = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objsys);<span class="comment">//object</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="全局符号注册表"><a href="#全局符号注册表" class="headerlink" title="全局符号注册表"></a>全局符号注册表</h1><ul><li><strong>Symbol.for()</strong></li><li>第一次使用౼个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</li><li>即使使用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同</li><li>全局注册表中的符号必须使用字符串键来创建<ul><li>作为参数传给 Symbol.for()的任何值都会被转换为字符串</li><li>注册表中使用的键同时也会被用作符号描述</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sys1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sys2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sys3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sys4 = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(sys1 == sys2);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(sys1 == sys3);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(sys4);<span class="comment">//Symbol(underfined)</span></span><br></pre></td></tr></table></figure><ul><li><strong>Symbol.keyFor()</strong> 来查询全局注册表</li><li>如果查询的不是全局符号，则返回 undefined</li><li>如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sys1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sys3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sys1));<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sys3));<span class="comment">//underfined</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="number">123</span>);<span class="comment">//TypeError:123 is not a symbol</span></span><br></pre></td></tr></table></figure><h1 id="符号作为属性"><a href="#符号作为属性" class="headerlink" title="符号作为属性"></a>符号作为属性</h1><ul><li>凡是可以使用字符串或数值作为属性的地方，都可以使用符号</li><li>Object.defineProperty(obj,prop,descriptor)<ul><li>obj：被操作的对象</li><li>prop：目标对象需要定义或修改的属性的名称</li><li>descriptor：将被定义或修改的属性描述符</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [s1]:<span class="string">&#x27;foo value&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">//&#123;Symbol(foo):foo value&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,s2,&#123;<span class="attr">value</span>:<span class="string">&#x27;bar value&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">//&#123;Symbol(foo):foo value,Symbol(bar):bar value&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o,&#123;</span><br><span class="line">    [s3]:&#123;<span class="attr">value</span>:<span class="string">&#x27;baz value&#x27;</span>&#125;,</span><br><span class="line">    [s4]:&#123;<span class="attr">value</span>:<span class="string">&#x27;qux value&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">//&#123;Symbol(foo):foo value,Symbol(bar): bar value,</span></span><br><span class="line"><span class="comment">//Symbol(baz):baz value,Symbol(qux):qux value&#125;</span></span><br></pre></td></tr></table></figure><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="Symbol-asyncIterator"><a href="#Symbol-asyncIterator" class="headerlink" title="Symbol.asyncIterator()"></a>Symbol.asyncIterator()</h2><ul><li><strong>一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用</strong></li><li>这个符号表示实现异步迭代器 API 的函数。</li><li>for-await-of 循环会利用这个函数执行异步迭代操作。</li><li>循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。</li><li>个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max)&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>resolve(<span class="built_in">this</span>.asyncIdex++))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount();</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h2><ul><li><strong>一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用</strong></li><li>在 ES6 中，instanceof 操作符会使用Symbol.hasInstance 函数来确定关系</li><li>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用</li><li><strong>instanceof操作符会在原型链上寻找这个属性定义</strong>，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance][b]);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h2><ul><li><strong>一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素</strong></li><li>ES6 中的 Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个<strong>类数组对象</strong>拼接成数组实例</li><li>数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾</li><li>类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。</li><li>其他不是类数组对象的对象在 Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。</li><li><strong>类数组对象是指：property（属性名）为正整数的对象</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2));<span class="comment">//[&#x27;foo&#x27;,&#x27;bar&#x27;]</span></span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2));<span class="comment">//[&#x27;foo&#x27;,[&#x27;bar&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>:<span class="number">1</span>,<span class="number">0</span>:<span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(obj));<span class="comment">//[&#x27;foo&#x27;,&#123;length:1,0:&#x27;baz&#x27;&#125;]</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(obj));<span class="comment">//[&#x27;foo&#x27;,&#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(set));<span class="comment">//[&#x27;foo&#x27;,Set(1)]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h2><ul><li><strong>一个方法，该方法ᤄ回对象默认的迭代器。由 for-of 语句使用</strong></li><li>for-of 循环这样的语言结构会利用这个函数执行迭代操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.interctor]()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max)&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Count();</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h2><ul><li><strong>一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用</strong></li><li>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。</li><li>String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMatcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.match](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(FooMatcher));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(Foomatcher));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.match](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;foo&#x27;</span>)));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;quz&#x27;</span>)));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h2><ul><li><strong>一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用</strong></li><li>String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。</li><li>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Replace</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.replace](target,replacment)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> Replace(<span class="string">&#x27;foo&#x27;</span>),<span class="string">&#x27;qux&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h2><ul><li><strong>一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用</strong></li><li>String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值</li><li>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="keyword">new</span> Search(<span class="string">&#x27;foo&#x27;</span>)));<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>,log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> Search(<span class="string">&#x27;foo&#x27;</span>)));<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> Search(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h2><ul><li><strong>一个函数值，该函数作为创建派生对象的构造函数</strong></li><li>用于对内置类型实例方法的返回值暴露实例化派生对象的方法</li><li>用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]()&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);<span class="comment">//true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);<span class="comment">//true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h2><ul><li><strong>一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用</strong></li><li>String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.split](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(Spliter));</span><br><span class="line"><span class="comment">//[&#x27;bar&#x27;,&#x27;baz&#x27;]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Split</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> Split(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="comment">//[&#x27;bar&#x27;,&#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><ul><li><strong>一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用</strong></li><li>对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>+foo);<span class="comment">//&quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>-foo);<span class="comment">//&quot;NaN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));<span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (hint)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>+bar);<span class="comment">//&quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>-bar);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar));<span class="comment">//&quot;&quot;string bar&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h2><ul><li><strong>一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用</strong></li><li>通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//Set(0)&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString());<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);<span class="comment">//Set</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//Foo&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);<span class="comment">//underfined</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//Bar()</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());<span class="comment">//[object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);<span class="comment">//Bar</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h2><ul><li><strong>一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除</strong></li><li>不推荐使用 with，因此也不推荐使用 Symbol.unscopables</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Symbol为原始类型，可以使用typeof操作符进行检测&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="ES6" scheme="http://example.com/categories/ES6/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记-数据类型（String）</title>
    <link href="http://example.com/2021/07/21/js-5-3/"/>
    <id>http://example.com/2021/07/21/js-5-3/</id>
    <published>2021-07-21T12:01:10.000Z</published>
    <updated>2021-07-31T07:56:11.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>零或多个16位Unicode字符序列。</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><ul><li>单引号、双引号、反引号标示。</li><li>以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="keyword">let</span> message1 = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">let</span> message2 = <span class="string">`Hello World`</span></span><br></pre></td></tr></table></figure><h1 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h1><ul><li>用于标识非打印字符或有其他用途的字符。</li><li>转义序列表示一个字符，在计算字符串长度时算一个字符。</li><li>如下表：</li></ul><table><thead><tr><th align="center">字面量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr><tr><td align="center"><code>\&#39;</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">双引号</td></tr></tbody></table><h1 id="字符串特点"><a href="#字符串特点" class="headerlink" title="字符串特点"></a>字符串特点</h1><ul><li>不可变：一旦创建就不能发生变化</li><li>如果要修改每个变量中的字符串的值，必须先销毁原始的字符串然后重新赋值</li></ul><h1 id="转换字符串"><a href="#转换字符串" class="headerlink" title="转换字符串"></a>转换字符串</h1><ul><li>方法：toString()</li><li><strong>null和undefined没有toString()方法</strong>，直接返回两个值的字面量文本</li><li>数值调用toString方法可以接受一个参数，表示进制。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>))<span class="comment">//&quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>))<span class="comment">//&quot;12&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="模板字面量（ES6）"><a href="#模板字面量（ES6）" class="headerlink" title="模板字面量（ES6）"></a>模板字面量（ES6）</h1><ul><li>模板字面量保留换行字符，可以跨行定义字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message1 = <span class="string">&#x27;one\ntwo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> message2 = <span class="string">`one</span></span><br><span class="line"><span class="string">two`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message1);</span><br><span class="line"><span class="comment">//one</span></span><br><span class="line"><span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(message2);</span><br><span class="line"><span class="comment">//one</span></span><br><span class="line"><span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(message1==message2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><ul><li>表达式：${变量}</li><li>模板字面量不是字符串，是一种特殊的JS语句表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`<span class="subst">$&#123;value&#125;</span>+<span class="subst">$&#123;value&#125;</span>=<span class="subst">$&#123;value*value&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line"><span class="comment">//5+5=10</span></span><br></pre></td></tr></table></figure><ul><li>所有插入的值都会使用toString()强制转为字符串</li></ul><h1 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="headerlink" title="模板字面量标签函数"></a>模板字面量标签函数</h1><ul><li>标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simple</span>(<span class="params">str,aVal,bVal,sum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">console</span>.log(aVal);</span><br><span class="line">    <span class="built_in">console</span>.log(bVal);</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;finish&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可使用剩余操作符收入到一个数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tag</span>(<span class="params">str,...exper</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> exper)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(experssion)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`<span class="subst">$&#123;a&#125;</span>+<span class="subst">$&#123;b&#125;</span>=<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> result = simple<span class="string">`<span class="subst">$&#123;a&#125;</span>+<span class="subst">$&#123;b&#125;</span>=<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"><span class="keyword">let</span> result1 = Tag<span class="string">`<span class="subst">$&#123;a&#125;</span>+<span class="subst">$&#123;b&#125;</span>=<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"><span class="built_in">console</span>.log(result)<span class="comment">//&#x27;finish&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h1><ul><li>String.raw标签函数可用于获取原始字符串</li><li>键盘输入的回车等不能获取到原始字符</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;零或多</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记-数据类型（Number）</title>
    <link href="http://example.com/2021/07/21/js-5-2/"/>
    <id>http://example.com/2021/07/21/js-5-2/</id>
    <published>2021-07-21T12:00:54.000Z</published>
    <updated>2021-07-28T12:50:30.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Number类型概述"><a href="#Number类型概述" class="headerlink" title="Number类型概述"></a>Number类型概述</h1><ul><li><p>Number 类型使用 IEEE 754 格式表示整数和浮点值</p></li><li><p>不同数值类型有不同的数值字面量格式</p></li><li><p>八进制字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、第一个数字必须是0，然后对应八进制数字</span></span><br><span class="line"><span class="comment">2、字面量中数字超出范围就会忽略第一个0，然后当作十进制处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span>;<span class="comment">//56</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">079</span>;<span class="comment">//十进制79</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">08</span>;<span class="comment">//十进制8</span></span><br></pre></td></tr></table></figure></li><li><p>十六进制字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、前缀为0x且区分大小写</span></span><br><span class="line"><span class="comment">2、字母大小写均可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0xa</span>;<span class="comment">//10</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">0x1F</span>;<span class="comment">//31</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>定义：<strong>数值中必须包含小数点，并且小数点后面必须至少有一个数字</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">5.20</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">13.14</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.20</span>;<span class="comment">//不推荐使用</span></span><br></pre></td></tr></table></figure></li><li>存储浮点值使用的内存空间是整数值的两倍</li></ul><h2 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h2><ul><li>用于表示一个应该乘以10的给定次幂的数值</li><li>表示方式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">3.125e7</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">31250000</span></span><br><span class="line"><span class="built_in">console</span>.log(num1 == num2)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li>ES会将小数点后至少包含6个零的浮点值转为科学计数法</li></ul><h2 id="精确度"><a href="#精确度" class="headerlink" title="精确度"></a>精确度</h2><ul><li>精确度可达17为小数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.05</span>+<span class="number">0.25</span> == <span class="number">0.15</span>+<span class="number">0.15</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span>+<span class="number">0.2</span> == <span class="number">0.3</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li>IEEE 754标准：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/07/21/js-5-2/pic1.png" class><h1 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h1><ul><li>由于内存的限制，ES并不支持所有数值</li><li>如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity</li><li>无法表示的负数：-Infinity（负无穷大）</li><li>无法表示的正数：Infinity（无穷大）</li><li>当计算返回正/负无穷时不能再进一步用于任何计算。</li><li>isFinite()函数可用于检测值是不是有限大</li><li>Number.NEGATIVE_INFINITY和Number,POSIYIVE_INFINITY可以获取正/负无穷<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(inFinite(result1));<span class="comment">//true</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="built_in">console</span>.log(inFinite(result2));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h1><ul><li>表示不是数值</li><li>ES中，0，+0，-0相除会返回NaN：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li>分母是有符号或无符号0，返回正/负无穷：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">512</span>/<span class="number">0</span>);<span class="comment">//Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">512</span>/-<span class="number">0</span>);<span class="comment">//-Infinity</span></span><br></pre></td></tr></table></figure></li><li><strong>NaN不等于包括NaN在内的任何值</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li>isNaN()用于检测是否为NaN<ul><li>可接受任意数据类型</li><li>任何不能转换为数值的值都会使得函数返回true</li></ul></li></ul><table>   <tr>      <td>数据类型</td>      <td>内容</td>      <td>结果</td>   </tr>   <tr>      <td>字符串</td>      <td>可以转换为数值</td>      <td>false</td>   </tr>   <tr>      <td></td>      <td>不可以转换为数值</td>      <td>true</td>   </tr>   <tr>      <td>布尔值</td>      <td>true</td>      <td>false</td>   </tr>   <tr>      <td></td>      <td>false</td>      <td>true</td>   </tr>   <tr>      <td>数值</td>      <td>数字</td>      <td>false</td>   </tr>   <tr>      <td></td>      <td>NaN</td>      <td>true</td>   </tr>   <tr>      <td></td>   </tr></table><h1 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h1><table><thead><tr><th align="center">转换函数</th><th align="left">Number()</th><th align="left">parseInt()</th><th align="left">parseFloat()</th></tr></thead><tbody><tr><td align="center">布尔值</td><td align="left">true → 1<br>false → 0</td><td align="left">NaN</td><td align="left">NaN</td></tr><tr><td align="center">数值</td><td align="left">直接返回</td><td align="left">返回对应整数</td><td align="left">返回对应数值</td></tr><tr><td align="center">null</td><td align="left">返回0</td><td align="left">NaN</td><td align="left">NaN</td></tr><tr><td align="center">underfined</td><td align="left">返回NaN</td><td align="left">NaN</td><td align="left">NaN</td></tr><tr><td align="center">字符串</td><td align="left">①包含有（无）符号数字字符串→对应十进制数值<br>②包含有效浮点值→对应浮点数<br>③包含十六进制格式→对应十进制<br>④空字符串→返回0<br>⑤除此之外→返回NaN</td><td align="left">①字符串最前面的空格会被忽略，从第一个非空格字符开始转换<br>②如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN<br>③如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符</td><td align="left">①从位置 0 开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止<br>② 始终忽略字符串开头的零<br>③只解析十进制值<br>④ 如果字符串表示整数（没有小数点或者小数点后面只有一个零），则返回整数</td></tr><tr><td align="center">对象</td><td align="left">调用valueOf()方法，并按上述规则返回值；如果转换结果为NaN，则调用toString()方法，再按照字符串规则转换</td><td align="left">NaN</td><td align="left">NaN</td></tr></tbody></table><ul><li>parseInt(str,base)有两个参数：<ul><li>str：接受一个带转化的字符串</li><li>base：为一个数值，表示进制</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Number类型概述&quot;&gt;&lt;a href=&quot;#Number类型概述&quot; class=&quot;headerlink&quot; title=&quot;Number类型概述&quot;&gt;&lt;/a&gt;Number类型概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Number 类型使用 IEEE 754 格式表示整数和浮</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
