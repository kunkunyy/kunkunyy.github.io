<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚永坤的小窝</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-19T15:17:11.366Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>姚永坤</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript学习笔记（四十五）动画与Canvas图形（一）</title>
    <link href="http://example.com/2021/12/14/js-45/"/>
    <id>http://example.com/2021/12/14/js-45/</id>
    <published>2021-12-14T09:02:37.000Z</published>
    <updated>2021-12-19T15:17:11.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用requestAnimationFrame"><a href="#使用requestAnimationFrame" class="headerlink" title="使用requestAnimationFrame"></a>使用requestAnimationFrame</h1><h2 id="1、早期定时动画"><a href="#1、早期定时动画" class="headerlink" title="1、早期定时动画"></a>1、早期定时动画</h2><ul><li>早期使用setInterval()控制动画的执行。</li><li>存在的问题：<ul><li>无法准确知晓循环之间的延时。</li><li>不能保证时间精度。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateAnimations</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        doAnimation1(); </span><br><span class="line">        doAnimation2(); </span><br><span class="line">        <span class="comment">// 其他任务</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">setInterval</span>(updateAnimations, <span class="number">100</span>); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="2、requestAnimationFrame"><a href="#2、requestAnimationFrame" class="headerlink" title="2、requestAnimationFrame"></a>2、requestAnimationFrame</h2><ul><li><p>requestAnimationFrame()</p><ul><li>方法接收一个参数：要在重绘屏幕前调用的函数。这个函数就是修改DOM样式以反映下一次重绘有什么变化的地方。</li><li>为了实现动画循环，可以串联调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>); </span><br><span class="line">    div.style.width = (<span class="built_in">parseInt</span>(div.style.width, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>; </span><br><span class="line">    <span class="keyword">if</span> (div.style.left != <span class="string">&quot;100%&quot;</span>) &#123; </span><br><span class="line">        requestAnimationFrame(updateProgress); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">requestAnimationFrame(updateProgress);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因为requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。</p></li><li><p>传给requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimestamp 的实例(比如performance.now()返回的值)，表示下次重绘的时间。</p></li></ul><h2 id="3、cancelAnimationFrame"><a href="#3、cancelAnimationFrame" class="headerlink" title="3、cancelAnimationFrame"></a>3、cancelAnimationFrame</h2><ul><li>与setTimeout类似，requestAnimationFrame()返回一个请求ID；</li><li>cancelAnimationFrame()来取消重绘任务。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> requestID = <span class="built_in">window</span>.requestAnimationFrame(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Repaint!&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame(requestID);</span><br></pre></td></tr></table></figure><h2 id="4、通过requestAnimationFrame节流"><a href="#4、通过requestAnimationFrame节流" class="headerlink" title="4、通过requestAnimationFrame节流"></a>4、通过requestAnimationFrame节流</h2><ul><li>支持该方法的浏览器会暴露作为钩子的回调队列。<ul><li>钩子就是浏览器在执行下一次重绘前的一个点。</li><li><strong>通过requestAnimationFrame ()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。</strong></li></ul></li></ul><h1 id="基本的画布功能"><a href="#基本的画布功能" class="headerlink" title="基本的画布功能"></a>基本的画布功能</h1><ul><li>创建<code>&lt;canvas&gt;</code>元素时至少需要width和height属性。</li><li>getContext()方法可以获取对绘图上下文的引用。<ul><li>对于平面图形，需要传入参数：2d。</li></ul></li><li>toDataURL()方法可以导出<code>&lt;canvas&gt;</code>元素上的图像。<ul><li>方法接收一个参数：要生成图像的MIME类型。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2D绘图上下文"><a href="#2D绘图上下文" class="headerlink" title="2D绘图上下文"></a>2D绘图上下文</h1><h2 id="1、填充和描边"><a href="#1、填充和描边" class="headerlink" title="1、填充和描边"></a>1、填充和描边</h2><ul><li>两个属性：fillStyle和strokeStyle。<ul><li>可以是字符串】渐变对象或图案对象；</li><li>默认值为”#000000”；</li><li>字符串表示颜色值，可以是CSS支持的任意格式：名称、十六进制代码、rgb、rgba、hsl或hsla。</li></ul></li></ul><h2 id="2、绘制矩形"><a href="#2、绘制矩形" class="headerlink" title="2、绘制矩形"></a>2、绘制矩形</h2><ul><li>fillRect()、strokeRect()、clearRect()：<ul><li>方法都接收4个参数：矩形x坐标、矩形y坐标、矩形宽度和矩形高度（单位均为像素）。</li><li>fillRect()方法用于以指定颜色在画布上绘制并填充矩形；填充颜色使用fillStyle属性指定（<strong>实心矩形</strong>）。</li><li>strokeRect()方法可以通过strokeStyle属性指定的颜色绘制举行轮廓（<strong>绘制边框，内部空心</strong>）。</li><li>clearRect()方法可以擦除画布中某个区域<ul><li>方法用于把绘图上下文种的某个区域变透明。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 引自 MDN 文档</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="comment">// 绘制红色矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">    <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line">    context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">    <span class="comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span></span><br><span class="line">    context.clearRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="3、绘制路径"><a href="#3、绘制路径" class="headerlink" title="3、绘制路径"></a>3、绘制路径</h2><ul><li>beginPath()方法是开始绘制新路径必须首先调用的方法。</li><li>再用以下方法来绘制路径：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic1.png" class title="# tu1"><ul><li>创建路径之后，可以使用closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定fillstyle 属性并调用fill ()方法来填充路径，也可以指定strokeStyle 属性并调用stroke ()方法来描画路径，还可以调用clip()方法基于已有路径创建一 个新剪切区域。</li><li>isPointInPath()方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用<ul><li>接收x轴和y轴坐标作为参数。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">// 创建路径</span></span><br><span class="line">    context.beginPath(); </span><br><span class="line">    <span class="comment">// 绘制外圆</span></span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>); </span><br><span class="line">    <span class="comment">// 绘制内圆</span></span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>); </span><br><span class="line">    <span class="comment">// 绘制分针</span></span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>); </span><br><span class="line">    <span class="comment">// 绘制时针</span></span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>); </span><br><span class="line">    <span class="comment">// 描画路径</span></span><br><span class="line">    context.stroke(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic2.png" class title="# tu1"><h2 id="4、绘制文本"><a href="#4、绘制文本" class="headerlink" title="4、绘制文本"></a>4、绘制文本</h2><ul><li>fillText()和strokeText()用于绘制文本。<ul><li>两个方法接收4个参数：字符串、x坐标、y坐标和可选的最大像素宽度。</li><li>fillText()方法使用fillStyle属性绘制文本；</li><li>strokeText()方法使用strokeStyle属性；</li><li>两个方法最终绘制的结果都取决于以下3个属性：</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic3.png" class title="# tu1"><ul><li>measureText()方法<ul><li>接收一个参数：要绘制的文本；</li><li>返回一个TextMetrics对象；</li><li>使用font、textAlign和textBaseline属性当前的值计算绘制指定文本后的大小。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fontSize = <span class="number">100</span>; </span><br><span class="line">context.font = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line"><span class="keyword">while</span>(context.measureText(<span class="string">&quot;Hello world!&quot;</span>).width &gt; <span class="number">140</span>) &#123; </span><br><span class="line"> fontSize--; </span><br><span class="line"> context.font = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">context.fillText(<span class="string">&quot;Hello world!&quot;</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">context.fillText(<span class="string">&quot;Font size is &quot;</span> + fontSize + <span class="string">&quot;px&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="5、变换"><a href="#5、变换" class="headerlink" title="5、变换"></a>5、变换</h2><ul><li>以下方法可用于改变绘制上下文的变换矩阵：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic4.png" class title="# tu1"><ul><li><strong>所有这些变换，包括fillstyle和strokestyle属性，会一直保留在上下文中，直到再次修改它们</strong>。</li></ul><h2 id="6、绘制图像"><a href="#6、绘制图像" class="headerlink" title="6、绘制图像"></a>6、绘制图像</h2><ul><li>drawImage()方法用于把现有图像绘制到画布上。</li><li>方法可以接收3组不同的参数：<br>  1、 传入HTML种img元素/canvas元素、绘制目标的x和y坐标；（直接绘制）<br>  2、 传入HTML img元素、绘制目标的x、y坐标、目标宽度、目标高度；（可用于改变图像大小）<br>  3、 要绘制的图像、源图像x坐标、源图像y坐标、源图像宽度、源图像高度、目标区域x坐标、目标区域y坐标、目标区域宽度、目标区域高度。（只把图像绘制到上下文中的一个区域）</li></ul><h2 id="7、阴影"><a href="#7、阴影" class="headerlink" title="7、阴影"></a>7、阴影</h2><ul><li>2D上下文可以根据以下属性的值自动为已有形状或路径生成阴影：<img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic5.png" class title="# tu1"></li><li>这些属性都可以通过context对象读写。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"><span class="comment">// 设置阴影</span></span><br><span class="line">context.shadowOffsetX = <span class="number">5</span>; </span><br><span class="line">context.shadowOffsetY = <span class="number">5</span>; </span><br><span class="line">context.shadowBlur = <span class="number">4</span>; </span><br><span class="line">context.shadowColor = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>; </span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="8、渐变"><a href="#8、渐变" class="headerlink" title="8、渐变"></a>8、渐变</h2><ul><li>渐变通过CanvasGradient的实例表示，在2D上下文中创建和修改都非常简单。</li><li>createLinearGradient()方法用于创建线性渐变。<ul><li>接收4个参数：起点x坐标、起点y坐标、终点x坐标和终点y坐标。</li><li>调用之后,该方法会以指定大小创建一个新的CanvasGradient对象并返回实例。</li></ul></li><li>addColorStop()方法为渐变指定色标。<ul><li>方法接收两个参数：色标位置和CSS颜色字符串。</li><li>色标位置通过0~1范围的值表示，0是第一种颜色，1是最后一种颜色。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.createLinearGradient(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>); </span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.addColorStop(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.fillStyle = gradient; </span><br><span class="line">context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="9、图案"><a href="#9、图案" class="headerlink" title="9、图案"></a>9、图案</h2><ul><li>createPattern()方法。<ul><li>接收两个参数：一个HTML<code>&lt;img&gt;</code>和一个表示该如何重复图像的字符串。</li><li>第二个参数的值与CSS的background-repeat属性，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。</li><li>第一个参数也可以是<code>&lt;video&gt;</code>元素或者另一个<code>&lt;canvas&gt;</code>元素。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>], </span><br><span class="line"> pattern = context.createPattern(image, <span class="string">&quot;repeat&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line">context.fillStyle = pattern; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>); </span><br></pre></td></tr></table></figure><h2 id="10、图像数据"><a href="#10、图像数据" class="headerlink" title="10、图像数据"></a>10、图像数据</h2><ul><li>getImageData()方法获取原始图像数据。<ul><li>方法接收4个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。</li><li>返回的对象是一个ImageData的实例。每个对象都包含3个属性：<ul><li>width：图像宽；</li><li>height：图像高；</li><li>data：包含图像的原始像素信息的数组。每个data中的元素都由4个值表示，分别代表红、绿、蓝和透明度。</li></ul></li></ul></li></ul><h2 id="11、合成"><a href="#11、合成" class="headerlink" title="11、合成"></a>11、合成</h2><ul><li>globalAlpha属性是一个范围在0~1的值(包括0和1),用于指定所有绘制内容的透明度，默认值为0。</li><li>globalCompositionOperation属性表示新绘制的形状如何与上下文中已有的形状融合。该属性为一个字符串，可以取下列值：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic6.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用requestAnimationFrame&quot;&gt;&lt;a href=&quot;#使用requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;使用requestAnimationFrame&quot;&gt;&lt;/a&gt;使用requestAnimatio</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Canvas" scheme="http://example.com/categories/Canvas/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十四）事件（二）</title>
    <link href="http://example.com/2021/12/12/js-44/"/>
    <id>http://example.com/2021/12/12/js-44/</id>
    <published>2021-12-12T14:59:09.000Z</published>
    <updated>2021-12-14T08:58:47.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><h2 id="1、用户界面事件"><a href="#1、用户界面事件" class="headerlink" title="1、用户界面事件"></a>1、用户界面事件</h2><h3 id="1）load事件"><a href="#1）load事件" class="headerlink" title="1）load事件"></a>1）load事件</h3><ul><li>在window对象上，load事件会在整个页面（包括所有外部资源如图片、JavaScript文件和CSS文件)加载完成后触发。</li><li>可以通过两种方式指定load事件处理程序：<ul><li>JavaScript方式；</li><li>向<code>&lt;body&gt;</code>元素添加onload属性。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Loaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Load Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Loaded!&#x27;)&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）unload事件"><a href="#2）unload事件" class="headerlink" title="2）unload事件"></a>2）unload事件</h3><ul><li>与load事件相对。</li><li>unload事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。</li><li>使用方法与load完全一样。</li></ul><h3 id="3）resize事件"><a href="#3）resize事件" class="headerlink" title="3）resize事件"></a>3）resize事件</h3><ul><li>当浏览器窗口被缩放到新高度或宽度是，会触发resize事件。</li><li>事件在window上触发。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Resized&quot;</span>); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h3 id="4）scroll事件"><a href="#4）scroll事件" class="headerlink" title="4）scroll事件"></a>4）scroll事件</h3><ul><li>scroll事件发生在window上，但实际上反映的是页面中相应元素的变化。</li></ul><h2 id="2、焦点事件"><a href="#2、焦点事件" class="headerlink" title="2、焦点事件"></a>2、焦点事件</h2><ul><li>焦点事件在页面元素获得或失去焦点时触发。</li><li>焦点事件有以下6种：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic1.png" class title="# tu1"><ul><li>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件：<ul><li>focuscout在失去焦点的元素上触发。</li><li>focusin在获得焦点的元素上触发。</li><li>blur在失去焦点的元素上触发。</li><li>DOMFocusOut在失去焦点的元素上触发。</li><li>focus在获得焦点的元素上触发。</li><li>DOMFocusIn在获得焦点的元素上触发。</li></ul></li><li>blur、DOMF ocusOut和focusout的事件目标是失去焦点的元素；</li><li>focus、DOMFocusIn和focusin的事件目标是获得焦点的元素。</li></ul><h2 id="3、鼠标和滚轮事件"><a href="#3、鼠标和滚轮事件" class="headerlink" title="3、鼠标和滚轮事件"></a>3、鼠标和滚轮事件</h2><ul><li>DOM3 Events定义了9种鼠标事件：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic2.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic3.png" class title="# tu1"><ul><li>页面中的所有元素都支持鼠标事件。</li><li>除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。</li></ul><h3 id="1）客户端坐标"><a href="#1）客户端坐标" class="headerlink" title="1）客户端坐标"></a>1）客户端坐标</h3><ul><li>客户端坐标使用：event.clientX和event.clientY。</li></ul><h3 id="2）页面坐标"><a href="#2）页面坐标" class="headerlink" title="2）页面坐标"></a>2）页面坐标</h3><ul><li>页面坐标使用：event.pageX和event.pageY。</li><li>页面没有滚动时客户端与页面坐标对应相等。</li></ul><h3 id="3）屏幕坐标"><a href="#3）屏幕坐标" class="headerlink" title="3）屏幕坐标"></a>3）屏幕坐标</h3><ul><li>客户端坐标使用：event.screenX和event.screenY。</li></ul><h3 id="4）修饰键"><a href="#4）修饰键" class="headerlink" title="4）修饰键"></a>4）修饰键</h3><ul><li>键盘上的修饰键：Shift、Ctrl、Alt、Meta。</li><li>DOM规定4个属性表示修饰键状态：<ul><li>shiftKey、ctrlKey、altKey 和 metaKey。</li><li>修饰键被按下时包含布尔值true，没有被按下时包含false。</li></ul></li></ul><h3 id="5）相关元素"><a href="#5）相关元素" class="headerlink" title="5）相关元素"></a>5）相关元素</h3><ul><li>简单解释就是：事件发生存在与事件相关的其他元素。</li><li>涉及到mouseover和mouseout两个事件。<ul><li>对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。</li><li>对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。</li></ul></li><li>DOM通过event对象的relatedTarget属性提供了相关元素的信息。<ul><li>这个属性只有在mouseover和mouseout事件发生时才包含值，其他所有事件的这个属性的值都是 null。</li></ul></li></ul><h3 id="6）鼠标按键"><a href="#6）鼠标按键" class="headerlink" title="6）鼠标按键"></a>6）鼠标按键</h3><ul><li>只有在元素上单击鼠标主键（或按下键盘上的回车键)时click 事件才会触发，因此按键信息并不是必需的。</li><li>对mousedown 和 mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。</li><li>DOM为这个button 属性定义了3个值:0表示鼠标主键、1表示鼠标中键（通常也是滚轮键)、2表示鼠标副键。</li></ul><h3 id="7）额外事件信息"><a href="#7）额外事件信息" class="headerlink" title="7）额外事件信息"></a>7）额外事件信息</h3><ul><li>DOM2 Events规范在event对象上提供了detail 属性，以给出关于事件的更多信息。<ul><li>对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少次单击。</li><li><strong>单击相当于在同一个像素上发生一次mousedown 紧跟一次mouseup</strong>。detail的值从1开始，每次单击会加1。</li><li>如果鼠标在mousedown和mouseup之间移动了，则detail会重置为0。</li></ul></li></ul><h3 id="8）mousewheel事件"><a href="#8）mousewheel事件" class="headerlink" title="8）mousewheel事件"></a>8）mousewheel事件</h3><ul><li>事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。</li><li>这个事件会在任何元素上触发,并(在IE8中）冒泡到document和(在所有现代浏览器中) window。</li><li>mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为 wheelDelta的新属性。<ul><li>当鼠标滚轮向前滚动时，wheelDelta每次都是+120；</li><li>当鼠标滚轮向后滚动时，wheelDelta每次都是-120。</li></ul></li><li>可以为页面上的任何元素或文档添加onmousewheel 事件处理程序，以处理所有鼠标滚轮交互。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousewheel&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(event.wheelDelta); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4、键盘与输入事件"><a href="#4、键盘与输入事件" class="headerlink" title="4、键盘与输入事件"></a>4、键盘与输入事件</h2><ul><li>键盘事件包含 3 个事件：<ul><li>keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。</li><li>keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了keypress事件，而推荐text Input事件。</li><li>keyup，用户释放键盘上某个键时触发。</li></ul></li><li>输入事件只有一个：textInput</li></ul><h3 id="1）键码"><a href="#1）键码" class="headerlink" title="1）键码"></a>1）键码</h3><ul><li>对于keydown和 keyup事件,event对象的keycode属性中会保存一个键码，对应键盘上特定的一个键。</li><li>对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic4.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic5.png" class title="# tu1"><h3 id="2）字符编码"><a href="#2）字符编码" class="headerlink" title="2）字符编码"></a>2）字符编码</h3><ul><li>浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。</li><li>通常，charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。</li></ul><h2 id="5、合成事件"><a href="#5、合成事件" class="headerlink" title="5、合成事件"></a>5、合成事件</h2><ul><li>合成事件是DOM3 Events中新增的，用于处理通常使用IME输人时的复杂输入序列。<ul><li>IME可以让用户输入物理键盘上没有的字符。</li></ul></li><li>合成事件有以下3种：<ul><li>compositionstart，在 IME的文本合成系统打开时触发，表示输入即将开始；</li><li>compositionupdate，在新字符插入输入字段时触发；</li><li>compositionend，在 IME的文本合成系统关闭时触发，表示恢复正常键盘输人。</li></ul></li><li>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，其中包含的值视情况而异：<ul><li>在compositionstart事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换)；</li><li>在compositionupdate事件中,包含要插人的新字符；</li><li>在compositionend事件中，包含本次合成过程中输入的全部内容。</li></ul></li></ul><h2 id="6、变化事件"><a href="#6、变化事件" class="headerlink" title="6、变化事件"></a>6、变化事件</h2><ul><li>已废弃</li></ul><h2 id="7、HTML5事件"><a href="#7、HTML5事件" class="headerlink" title="7、HTML5事件"></a>7、HTML5事件</h2><h3 id="1）contextmenu事件"><a href="#1）contextmenu事件" class="headerlink" title="1）contextmenu事件"></a>1）contextmenu事件</h3><ul><li>专门用于表示何时该显示上下文菜单。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ContextMenu Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Right click or Ctrl+click me to get a custom context menu. Click anywhere else to get the default context menu.<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myMenu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;visibility:hidden;background-color: </span></span></span><br><span class="line"><span class="tag"><span class="string">    silver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere.com&quot;</span>&gt;</span> somewhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.wrox.com&quot;</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere-else.com&quot;</span>&gt;</span>somewhere-else<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">    div.addEventListener(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">        event.preventDefault(); </span><br><span class="line">        <span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myMenu&quot;</span>); </span><br><span class="line">        menu.style.left = event.clientX + <span class="string">&quot;px&quot;</span>; </span><br><span class="line">        menu.style.top = event.clientY + <span class="string">&quot;px&quot;</span>; </span><br><span class="line">        menu.style.visibility = <span class="string">&quot;visible&quot;</span>; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myMenu&quot;</span>).style.visibility = <span class="string">&quot;hidden&quot;</span>; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>以上代码实现效果如下：这里在<code>&lt;div&gt;</code>元素上指定了一个oncontextmenu事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于event对象的clientx和clientY属性把<code>&lt;ul&gt;</code>元素放到适当位置。最后一步通过将visibility属性设置为”visible”让自定义上下文菜单显示出来。另外，又给document添加了一个onclick事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的)。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic6.png" class title="# tu1"><ul><li>当鼠标右键点击/ctrl+点击文字会发生以下变化：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic7.png" class title="# tu1"><h3 id="2）beforeunload事件"><a href="#2）beforeunload事件" class="headerlink" title="2）beforeunload事件"></a>2）beforeunload事件</h3><ul><li>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。</li><li>这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。</li><li>这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。</li></ul><h3 id="3）DOMContentLoaded事件"><a href="#3）DOMContentLoaded事件" class="headerlink" title="3）DOMContentLoaded事件"></a>3）DOMContentLoaded事件</h3><ul><li>DOMContentLoaded事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。</li><li>相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</li><li>要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Content loaded&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4）readystatechange事件"><a href="#4）readystatechange事件" class="headerlink" title="4）readystatechange事件"></a>4）readystatechange事件</h3><ul><li>readystatechange 事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。</li><li>支持readystatechange 事件的每个对象都有一个readyState属性，该属性具有一个以下列出的可能的字符串值。<img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic8.png" class title="# tu1"></li></ul><h3 id="5）pageshow与pagehide事件"><a href="#5）pageshow与pagehide事件" class="headerlink" title="5）pageshow与pagehide事件"></a>5）pageshow与pagehide事件</h3><ul><li>往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。</li><li>这个缓存不仅存储页面数据，也存储 DOM 和JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。</li><li><strong>pageshow，其会在页面显示时触发，无论是否来自往返缓存。</strong><ul><li>在新加载的页面上，pageshow会在 load事件之后触发；</li><li>在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。</li><li><strong>虽然这个事件的目标是document，但事件处理程序必须添加到window上</strong>。</li><li>pageshow 的 event 对象中还包含一个名为 persisted 的属性，这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。</li></ul></li><li><strong>pagehide与pageshow相对，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。</strong></li></ul><h3 id="6）hashchange事件"><a href="#6）hashchange事件" class="headerlink" title="6）hashchange事件"></a>6）hashchange事件</h3><ul><li>HTML5增加了hashchange事件，<strong>用于在URL散列值(URL最后#后面的部分)发生变化时通知开发者</strong>。这是因为开发者经常在Ajax应用程序中使用URL 散列值存储状态信息或路由导航信息。</li><li>onhashchange事件处理程序必须添加给window，每次URL散列值发生变化时会调用它。</li><li>event对象有两个新属性: oldURL 和newURL。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。</li></ul><h2 id="8、设备事件"><a href="#8、设备事件" class="headerlink" title="8、设备事件"></a>8、设备事件</h2><ul><li>设备事件可以用于确定用户使用设备的方式。</li></ul><h3 id="1）orientationchange事件"><a href="#1）orientationchange事件" class="headerlink" title="1）orientationchange事件"></a>1）orientationchange事件</h3><ul><li>用于确定用户的设备是处于垂直模式还是水平模式。</li><li>每当用户旋转设备改变了模式，就会触发orientationchange事件。</li><li>可以从window.orientation 属性中获取有用的信息。</li></ul><h3 id="2）deviceorientation"><a href="#2）deviceorientation" class="headerlink" title="2）deviceorientation"></a>2）deviceorientation</h3><ul><li>deviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。</li><li>设备本身处于3D空间即拥有x轴、y轴和z轴的坐标系中。如果把设备静止放在水平的表面上,那么三轴的值均为0，其中，x轴方向为从设备左侧到右侧,y轴方向为从设备底部到上部、z轴方向为从设备背面到正面。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic9.png" class title="# tu1"><ul><li>当deviceorientation触发时，event对象中会包含各个轴相对于设备静置时坐标值的变化,主要是以下5个属性。<ul><li>alpha：0~360范围内的浮点值，表示围绕z轴旋转时y轴的度数(左右转)。</li><li>beta：-180~180范围内的浮点值，表示围绕x轴旋转时z轴的度数（前后转)。</li><li>gamma：-90~90范围内的浮点值，表示围绕y轴旋转时z轴的度数（扭转)。</li><li>absolute：布尔值，表示设备是否返回绝对值。</li><li>compassCalibrated：布尔值，表示设备的指南针是否正确校准。</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic10.png" class title="# tu1"><h3 id="3）devicemotion事件"><a href="#3）devicemotion事件" class="headerlink" title="3）devicemotion事件"></a>3）devicemotion事件</h3><ul><li>DeviceOrientationEvent规范也定义了devicemotion事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。</li><li>当devicemotion事件触发时，event对象中包含如下额外的属性。<ul><li>acceleration：对象，包含x、y和z属性，反映不考虑重力情况下各个维度的加速信息。</li><li>accelerationIncludingGravity：对象，包含x、y和z属性，反映各个维度的加速信息,包含z轴自然重力加速度。</li><li>interval：毫秒,距离下次触发devicemotion事件的时间。此值在事件之间应为常量。</li><li>rotationRate：对象，包含alpha、beta和l gamma属性，表示设备朝向。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件类型&quot;&gt;&lt;a href=&quot;#事件类型&quot; class=&quot;headerlink&quot; title=&quot;事件类型&quot;&gt;&lt;/a&gt;事件类型&lt;/h1&gt;&lt;h2 id=&quot;1、用户界面事件&quot;&gt;&lt;a href=&quot;#1、用户界面事件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="事件" scheme="http://example.com/categories/%E4%BA%8B%E4%BB%B6/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十三）事件（一）</title>
    <link href="http://example.com/2021/12/12/js-43/"/>
    <id>http://example.com/2021/12/12/js-43/</id>
    <published>2021-12-12T05:39:28.000Z</published>
    <updated>2021-12-12T14:58:11.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><ul><li><strong>事件流描述了页面接收事件的顺序</strong>。</li></ul><h2 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h2><ul><li><strong>IE事件流被称为事件冒泡</strong>。<ul><li>事件被定义为从最具体的元素(文档树中最深的节点)开始触发，然后向上传播至没有那么具体的元素（文档)。</li></ul></li><li>如下页面结构：<ul><li>当点击页面中的div元素后，click事件会以如下顺序发生：<ul><li><code>&lt;div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h2><ul><li>由Netscape Communicator 团队提出。</li><li>事件捕获的意思是<strong>最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件</strong>。</li><li>事件捕获实际上是为了在事件到达最终目标前拦截事件。</li><li>上面例子使用事件捕获，出发顺序如下：<ul><li><code>document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;</code></li></ul></li></ul><h2 id="3、DOM事件流"><a href="#3、DOM事件流" class="headerlink" title="3、DOM事件流"></a>3、DOM事件流</h2><ul><li>DOM2 Events规定事件流分为3个阶段：<strong>事件捕获、到达目标、事件冒泡</strong>。</li><li>事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-43/pic1.png" class title="# tu1"><ul><li>在 DOM事件流中，实际的目标(<code>&lt;div&gt;</code>元素)在捕获阶段不会接收到事件。这是因为捕获阶段从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就结束了。下一阶段，即会在<code>&lt;div&gt;</code>元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。</li></ul><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><ul><li><strong>为响应事件而调用的函数被称为事件处理程序</strong>。</li><li>事件处理程序的名字以“on”开头。</li></ul><h2 id="1、HTML事件处理程序"><a href="#1、HTML事件处理程序" class="headerlink" title="1、HTML事件处理程序"></a>1、HTML事件处理程序</h2><ul><li>特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。</li><li>在 HTML 中定义的事件处理程序可以包含精确的动作指令也可以调用在页面其他地方定义的脚本。</li></ul><h2 id="2、DOM0事件处理程序"><a href="#2、DOM0事件处理程序" class="headerlink" title="2、DOM0事件处理程序"></a>2、DOM0事件处理程序</h2><ul><li>每个元素（包括window和 document)都有通常小写的事件处理程序属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li><li>像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。</li></ul><h2 id="3、DOM2事件处理程序"><a href="#3、DOM2事件处理程序" class="headerlink" title="3、DOM2事件处理程序"></a>3、DOM2事件处理程序</h2><ul><li>addEventListener()和removeEventListener()：<ul><li>接收三个参数：事件名、事件处理函数和一个布尔值。true表示在捕获阶段调用事件处理程序；false（默认值）表示在冒泡阶段调用事件处理程序。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><p>使用DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); </span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure></li><li><p><strong>通过addEventListener()添加的事件处理程序只能使用removeEventListener()并传入与添加时同样的参数来移除</strong>。</p></li><li><p><strong>使用addEventListener()添加的匿名函数无法移除</strong>。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); </span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 没有效果！</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); </span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); </span><br><span class="line">&#125;; </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效果！</span></span><br></pre></td></tr></table></figure><h2 id="4、IE事件处理程序"><a href="#4、IE事件处理程序" class="headerlink" title="4、IE事件处理程序"></a>4、IE事件处理程序</h2><ul><li>attachEvent()和detachEvent()<ul><li>接收两个同样的参数：事件处理程序的名字和事件处理函数。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="5、跨浏览器事件处理程序"><a href="#5、跨浏览器事件处理程序" class="headerlink" title="5、跨浏览器事件处理程序"></a>5、跨浏览器事件处理程序</h2><ul><li>addHandler()和removeHandler()方法<ul><li>接收三个参数：目标元素、事件名和事件处理函数</li></ul></li></ul><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><h2 id="1、DOM事件对象"><a href="#1、DOM事件对象" class="headerlink" title="1、DOM事件对象"></a>1、DOM事件对象</h2><ul><li>event对象是传给事件处理程序的唯一参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;; </span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>所有事件对象都会包含下表中的公共属性和方法：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-43/pic2.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-43/pic3.png" class title="# tu1"><ul><li>在事件处理程序内部，<strong>this对象始终等于currentTarget 的值</strong>，而<strong>target 只包含事件的实际目标</strong>。</li><li>如果事件处理程序直接添加在了意图的目标，则this、currentTarget和 target的值是一样的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget === <span class="built_in">this</span>); <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(event.target === <span class="built_in">this</span>); <span class="comment">// true </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>preventDefault()方法用于阻止特定事件的默认动作。<ul><li>比如：链接的默认行为就是在被单击时导航到href属性指定的URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消。</li><li>任何可以通过preventDefault()取消默认行为的事件，其事件对象的cancelable属性都会设置为true。</li></ul></li><li>stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡。</li><li>eventPhase属性可以用于确定事件流当前所处的阶段。<ul><li>如果事件处理程序在捕获阶段被调用，则eventPhase等于1；</li><li>如果事件处理程序在目标上被调用，则eventPhase等于2；</li><li>如果事件处理程序在冒泡阶段被调用，则eventPhase等于3。</li><li>虽然“到达目标”是在冒泡阶段发生的，但其eventPhase仍然等于2。</li></ul></li></ul><h2 id="2、IE事件对象"><a href="#2、IE事件对象" class="headerlink" title="2、IE事件对象"></a>2、IE事件对象</h2><ul><li>IE事件对象可以基于事件处理程序被指定的方式以不同方式来访问。</li><li>如果事件处理程序是使用DOM0方式指定的，则event对象只是window对象的一个属性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;事件流描述了页面接收事件的顺序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、事件冒泡&quot;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="事件" scheme="http://example.com/categories/%E4%BA%8B%E4%BB%B6/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十二）DOM2和DOM3（三）</title>
    <link href="http://example.com/2021/12/09/js-42/"/>
    <id>http://example.com/2021/12/09/js-42/</id>
    <published>2021-12-09T10:03:31.000Z</published>
    <updated>2021-12-12T05:46:12.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><ul><li>DOM2 Traversal and Range模块定义了两个类型用于辅助顺序遍历DOM结构。这两个类型<strong>NodeIterator和Treewalker</strong>从某个起点开始执行对DOM结构的深度优先遍历。</li><li>DOM遍历是**对DOM结构的深度优先遍历，至少允许朝两个方向移动(取决于类型)**。遍历以给定节点为根，不能在 DOM中向上超越这个根节点。</li><li>查看以下HTML：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>DOM树如下：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic1.png" class title="# tu1"><h2 id="1）NodeIterator"><a href="#1）NodeIterator" class="headerlink" title="1）NodeIterator"></a>1）NodeIterator</h2><ul><li>NodeIterator类型是两个类型中比较简单的，可以通过document.createNodeIterator()方法创建其实例。方法接收四个参数：<ul><li>root：作为遍历根节点的节点；</li><li>whatToShow：数值代码，表示应该访问哪些节点；</li><li>filter：NodeFilter对象或函数,表示是否接收或跳过特定节点；</li><li>entityReferenceExpansion，布尔值,表示是否扩展实体引用。这个参数在HTML文档中没有效果，因为实体引用永远不扩展。</li></ul></li><li>whatToshow参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在NodeFilter类型中定义的。<ul><li>这些值除了 NodeFilter.SHOW_ALL 之外，都可以组合使用。</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic2.png" class title="# tu1"><ul><li><p>createNodeIterator()方法的filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。</p></li><li><p>NodeFilter对象只有一个方法**acceptNode()**，如果给定节点应该访问就返回NodeFilter.FILTER_ACCEPT，否则返回NodeFilter.FILTER_SKIP。</p></li><li><p><strong>NodeFilter 是一个抽象类型，所以不可能创建它的实例</strong>。只要创建一个包含 acceptNode()的对象，然后把它传给createNodeIterator()就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以下代码定义了只接收&lt;p&gt;元素的节点过滤器对象：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> filter = &#123; </span><br><span class="line">    <span class="function"><span class="title">acceptNode</span>(<span class="params">node</span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">&quot;p&quot;</span> ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">filter 参数还可以是一个函数，与 acceptNode()的形式一样，如下面的例子所示：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> filter = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">&quot;p&quot;</span> ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="built_in">document</span>.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个简单的遍历所有节点的 NodeIterator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="built_in">document</span>.createNodeIterator(<span class="built_in">document</span>, NodeFilter.SHOW_ALL, <span class="literal">null</span>, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure></li><li><p>NodeIterator 的两个主要方法是nextNode()和 previousNode()：</p><ul><li>nextNode()方法在DOM子树中<strong>以深度优先方式进前一步</strong>；previousNode()是在遍历中<strong>后退一步</strong>。</li><li>NodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用nextNode ()返回的是根节点。。</li><li>当遍历到达DOM树最后一个节点时，nextNode()返回null；previousNode()返回遍历的根节点后，再次调用也会返回null。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>假设想要遍历<code>&lt;div&gt;</code>元素内部所有元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.nextNode(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(node.tagName); <span class="comment">// 输出标签名</span></span><br><span class="line">    node = iterator.nextNode(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DIV </span></span><br><span class="line"><span class="comment">P </span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">UL </span></span><br><span class="line"><span class="comment">LI </span></span><br><span class="line"><span class="comment">LI </span></span><br><span class="line"><span class="comment">LI</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果只想遍历<code>&lt;li&gt;</code>元素，可以传入一个过滤器：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> filter = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">&quot;li&quot;</span> ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,filter, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.nextNode(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.tagName); <span class="comment">// 输出标签名</span></span><br><span class="line">    node = iterator.nextNode(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2）TreeWalker"><a href="#2）TreeWalker" class="headerlink" title="2）TreeWalker"></a>2）TreeWalker</h2><ul><li>Treewalker是NodeIterator的高级版。</li><li>除了包含同样的nextNode().previousNode()方法，Treewalker还添加了如下在 DOM结构中向<strong>不同方向</strong>遍历的方法。<ul><li>parentNode()，遍历到当前节点的父节点；</li><li>firstChild()，遍历到当前节点的第一个子节点；</li><li>lastChild()，遍历到当前节点的最后一个子节点；</li><li>nextSibling()，遍历到当前节点的下一个同胞节点；</li><li>previoussibling()，遍历到当前节点的上一个同胞节点。</li></ul></li><li>调用document.createTreewalker()方法来创建Treewalker对象。<ul><li>参数： 作为遍历起点的根节点、要查看的节点类型、节点过滤器、一个表示是否扩展实体引用的布尔值。</li><li>节点过滤器：除了可以返回NodeFilter.FILTER_ACCEPT和NodeFilter.FILTER_SKIP，还可以返回NodeFilter.FILTER_REJECT。</li></ul></li><li>在使用NodeIterator时，NodeFilter.FILTER_SKIP和NodeFilter.FILTER_REJECT是一样的。</li><li>在使用Treewalker时，NodeFilter.FILTER_SKIP表示跳过节点，访问子树中的<strong>下一个节点</strong>，而NodeFilter.FILTER_REJECT则表示<strong>跳过该节点以及该节点的整个子树</strong>。</li></ul><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><h2 id="1、DOM范围"><a href="#1、DOM范围" class="headerlink" title="1、DOM范围"></a>1、DOM范围</h2><ul><li>DOM2在Document类型上定义了一个createRange()方法可用于创建一个DOM范围对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="built_in">document</span>.createRange(); </span><br></pre></td></tr></table></figure><ul><li>新创建的氛围对象是与创建它的文档关联，不能在其他文档中使用。</li><li>创建范围并指定它的位置后就可以对范围的内容执行一些操作，从而实现对底层DOM树更精细的控制。</li><li>每个范围都是 Range类型的实例，拥有相应的属性和方法。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic3.png" class title="# tu1"><h2 id="2、简单选择"><a href="#2、简单选择" class="headerlink" title="2、简单选择"></a>2、简单选择</h2><ul><li>selectNode()或 selectNodeContents()是通过范围选择文档中౼个部分最简单的方式。<ul><li>参数：接收一个节点，并将该节点的信息添加到调用它的氛围</li><li>不同：<ul><li>selectNode()选择整个节点，包括其后代节点。</li><li>selectNodeContents()只选择节点的后代。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="built_in">document</span>.createRange(), </span><br><span class="line">    range2 = <span class="built_in">document</span>.createRange(), </span><br><span class="line">    p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line">range1.selectNode(p1); </span><br><span class="line">range2.selectNodeContents(p1); </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic4.png" class title="# tu1"><ul><li>调用selectNode()时，startContainer、endContainer和 commonAncestorContainer都等于传入节点的父节点。在这个例子中,这几个属性都等于document.body。</li><li>选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic5.png" class title="# tu1"><h2 id="3、复杂选择"><a href="#3、复杂选择" class="headerlink" title="3、复杂选择"></a>3、复杂选择</h2><ul><li>要创建复杂的范围，需要使用setstart()和setEnd()方法。<ul><li>两个方法都接收两个参数：参照节点和偏移量。</li><li>对setstart()来说，参照节点会成为startContainer，而偏移量会赋值给startoffset。</li><li>对setEnd()而言，参照节点会成为endContainer，而偏移量会赋值给endoffset。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过范围从中选择从&quot;Hello&quot;中的&quot;1lo&quot;到&quot; world! 中的&quot;o&quot;的部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line">    helloNode = p1.firstChild.firstChild, </span><br><span class="line">    worldNode = p1.lastChild</span><br><span class="line"><span class="keyword">let</span> range = <span class="built_in">document</span>.createRange(); </span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>); </span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>); </span><br></pre></td></tr></table></figure></li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic6.png" class title="# tu1"><h2 id="4、操作范围"><a href="#4、操作范围" class="headerlink" title="4、操作范围"></a>4、操作范围</h2><ul><li>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。</li><li>为操作范围的内容，选区中的内容必须格式完好。</li><li><strong>范围能够确定缺ܾ的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作</strong>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>针对以上例子，范围发现选区中缺少一个开始的<code>&lt;b&gt;</code>标签，于是会在后台动态补上这个标签，同时还需要补上封闭”He”的结束标签<code>&lt;/b&gt;</code>，结果会把 DOM 修改为这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>deleteContents()方法会从文档中删除范围包含的节点。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>),</span><br><span class="line">    helloNode = p1.firstChild.firstChild,</span><br><span class="line">    worldNode = p1.lastChild,</span><br><span class="line">    range = <span class="built_in">document</span>.createRange(); </span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br><span class="line">range.deleteContents();</span><br></pre></td></tr></table></figure><ul><li>执行上面的代码之后，页面中的 HTML 会变成这样：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;<span class="name">rld</span></span>!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li>extractContents()也会从文档中移除范围选区，同时返回范围对应的文档片段。</li><li>下面例子中提取了范围的文档片段，然后把它添加到文档<code>&lt;body&gt;</code>元素的最后。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line">    helloNode = p1.firstChild.firstChild, </span><br><span class="line">    worldNode = p1.lastChild, </span><br><span class="line">range = <span class="built_in">document</span>.createRange(); </span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>); </span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> fragment = range.extractContents(); </span><br><span class="line">p1.parentNode.appendChild(fragment);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;<span class="name">rld</span></span>!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure></li><li>如果不想把范围从文档中移除,也可以使用cloneContents()创建一个副本，然后把这个副本插入到文档其他地方。</li></ul><h2 id="5、范围插入"><a href="#5、范围插入" class="headerlink" title="5、范围插入"></a>5、范围插入</h2><ul><li>insertNode()：方法可以在范围选区的开始位置插人一个节点。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line">    helloNode = p1.firstChild.firstChild, </span><br><span class="line">    worldNode = p1.lastChild, </span><br><span class="line">    range = <span class="built_in">document</span>.createRange(); </span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>); </span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.style.color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line">span.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Inserted text&quot;</span>)); </span><br><span class="line">range.insertNode(span); </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Inserted text<span class="tag">&lt;/<span class="name">span</span>&gt;<span class="name">llo</span></span><span class="tag">&lt;/<span class="name">b</span>&gt;</span> world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>surroundContents()：方法插入包含范围的内容。<ul><li>接收一个参数：包含范围内容的节点。</li></ul></li></ul><h2 id="6、范围折叠"><a href="#6、范围折叠" class="headerlink" title="6、范围折叠"></a>6、范围折叠</h2><ul><li>如果范围并没有选择文档的任何部分，则称为折叠( collapsed )。</li><li><strong>折叠范围</strong>有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。</li><li>在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/09/js-42/pic7.png" class title="# tu1"><ul><li>collapse()方法<ul><li>接收一个参数：布尔值，表示折叠到范围哪一段。</li><li>true表示折叠到起点；false表示折叠到终点。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line">    p2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>), </span><br><span class="line">    range = <span class="built_in">document</span>.createRange(); </span><br><span class="line">range.setStartAfter(p1); </span><br><span class="line">range.setStartBefore(p2); </span><br><span class="line"><span class="built_in">console</span>.log(range.collapsed); <span class="comment">// true </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7、范围比较"><a href="#7、范围比较" class="headerlink" title="7、范围比较"></a>7、范围比较</h2><ul><li>compareBoundaryPoints()方法确定范围之间是否存在公共的边界。<ul><li>参数：接收两个参数，要比较的范围和以恶常量值，表示比较的方式。<ul><li>Range.START_TO_START(0)，比较两个范围的起点;</li><li>Range.START_TO_END(1)，比较第一个范围的起点和第二个范围的终点；</li><li>Range.END_TO_END（2),比较两个范围的终点；</li><li>Range.END_TO_START (3)，比较第一个范围的终点和第二个范围的起点。</li></ul></li><li>返回值：<ul><li>在第一个范围的边界点位于第二个范围的边界点之前时返回-1；</li><li>在两个范围的边界点相等时返回0；</li><li>在第一个范围的边界点位于第二个范围的边界点之后时返回1。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="built_in">document</span>.createRange(); </span><br><span class="line"><span class="keyword">let</span> range2 = <span class="built_in">document</span>.createRange(); </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line">range1.selectNodeContents(p1); </span><br><span class="line">range2.selectNodeContents(p1); </span><br><span class="line">range2.setEndBefore(p1.lastChild); </span><br><span class="line"><span class="built_in">console</span>.log(range1.compareBoundaryPoints(Range.START_TO_START, range2)); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(range1.compareBoundaryPoints(Range.END_TO_END, range2)); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="8、复制范围"><a href="#8、复制范围" class="headerlink" title="8、复制范围"></a>8、复制范围</h2><ul><li>cloneRange()方法可以复制范围，会创建调用它的范围的副本。</li><li>新范围包含与原始范围一样的属性,修改其边界点不会影响原始范围。</li></ul><h2 id="9、清理"><a href="#9、清理" class="headerlink" title="9、清理"></a>9、清理</h2><ul><li>detach()方法把范围从创建它的文档中剥离。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DOM2 Traversal and Range模块定义了两个类型用于辅助顺序遍历DOM结构。这两个类型&lt;strong&gt;Node</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十一）DOM2和DOM3（二）</title>
    <link href="http://example.com/2021/12/06/js-41/"/>
    <id>http://example.com/2021/12/06/js-41/</id>
    <published>2021-12-06T08:09:15.000Z</published>
    <updated>2021-12-09T10:12:13.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ul><li>HTML样式有3种定义方法：外部样式表、文档样式表、元素特定样式。</li></ul><h2 id="1、存取元素样式"><a href="#1、存取元素样式" class="headerlink" title="1、存取元素样式"></a>1、存取元素样式</h2><ul><li>任何支持style属性的HTML元素在JavaScript中都会有一-个对应的style属性。</li><li><strong>style属性是cssstyleDeclaration类型的实例</strong>，其中包含通过HTML style属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。</li><li>HTML style属性中的CSS属性在JavaScript style对象中都有对应的属性。</li><li>因为<strong>CSS属性名使用连字符表示法</strong>（用连字符分隔两个单词，如background-image），所以<strong>在JavaScript中这些属性必须转换为驼峰大小写形式</strong>（如backgroundImage）。</li><li>大多数属性名会这样直接转换过来。但有一个CSS属性名不能直接转换，它就是float。因为float是JavaScript的保留字，所以不能用作属性名。<strong>DOM2 Style 规定它在style对象中对应的属性应该是cssFloat</strong>。</li><li>任何时候，只要获得了有效DOM元素的引用，就可以通过JavaScript来设置样式。</li><li>通过style属性设置的值也可以通过style对象获取。</li></ul><h3 id="1）DOM样式属性和方法"><a href="#1）DOM样式属性和方法" class="headerlink" title="1）DOM样式属性和方法"></a>1）DOM样式属性和方法</h3><ul><li>DOM2 Style规范也在style对象上定义了一些属性和方法。这些属性和方法提供了元素style属性的信息并支持修改。</li></ul><table><thead><tr><th align="center">属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">cssText</td><td align="center">包含 style 属性中的 CSS 代码</td></tr><tr><td align="center">length</td><td align="center">应用给元素的 CSS 属性数量</td></tr><tr><td align="center">parentRule</td><td align="center">表示 CSS 信息的 CSSRule 对象</td></tr><tr><td align="center">getPropertyPriority(propertyName)</td><td align="center">如果 CSS 属性 propertyName 使用了!important则返回”important”，否则返回空字符串</td></tr><tr><td align="center">getPropertyValue (propertyName)</td><td align="center">返回属性propertyName的字符串值</td></tr><tr><td align="center">item(index)</td><td align="center">返回索引为index的CSS属性名</td></tr><tr><td align="center">removeProperty (propertyName)</td><td align="center">从样式中删除CSS属性propertyName</td></tr><tr><td align="center">setProperty (propertyName, value, priority)</td><td align="center">设置CSS属性propertyName的值为value, priority是” important”或空字符串</td></tr></tbody></table><h3 id="2）计算样式"><a href="#2）计算样式" class="headerlink" title="2）计算样式"></a>2）计算样式</h3><ul><li><p>DOM2 Style在document.defaultView上增加了getComputedstyle()方法。</p><ul><li>方法接收两个参数：<strong>要取得计算样式的元素</strong>和<strong>伪元素字符串（如”:after” ）</strong>。如果不需要查询伪元素，则第二个参数可以传null。</li><li>方法返回一个cssstyleDeclaration对象（与style属性的类型一样 ），包含元素的计算样式。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Computed Styles Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span> </span><br><span class="line">        #myDiv &#123; </span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue; </span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>; </span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>; </span></span><br><span class="line">        &#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red; border: 1px solid black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>这里的<code>&lt;div&gt;</code>元素从文档样式表（ <code>&lt;style&gt;</code>元素）和自己的style属性获取了样式。此时，这个元素的style对象中包含backgroundColor和border属性，但不包含（通过样式表规则应用的）width和height属性。下 面的代码从这个元素获取了计算样式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>); </span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.backgroundColor); <span class="comment">// &quot;red&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.width); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.height); <span class="comment">// &quot;200px&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.border); <span class="comment">// &quot;1px solid black&quot;（在某些浏览器中）</span></span><br></pre></td></tr></table></figure></li><li><p> 在所有浏览器中计算样式都是只读的，不能修改getComputeastyle()方法返回的对象。</p></li><li><p>计算样式还包含浏览器内部样式表中的信息。</p></li></ul><h2 id="2、操作样式表"><a href="#2、操作样式表" class="headerlink" title="2、操作样式表"></a>2、操作样式表</h2><ul><li>CSSStyleSheet类型表示CSS样式表，包括使用<code>&lt;1ink&gt;</code>元素和通过<code>&lt;style&gt;</code>元素定义的样式表。这两个元素本身分别是HTMLLinkElement和HTMLStyleElement。</li><li><strong>CSSStyleSheet类型是一个通用样式表类型，可以表示以任何方式在HTML中定义的样式表。</strong></li><li>CSSStylesheet类型的实例则是一个只读对象(只有一-个属性例外)。</li><li>CSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。<strong>以下是CSSStyleSheet从StyleSheet继承的属性（除了disabled，其他属性对后市只读的）</strong>。</li></ul><table><thead><tr><th align="center">属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">disabled</td><td align="center">布尔值，表示样式表是否被禁用了(这个属性是可读写的，因此将它设置为true会禁用样式表)</td></tr><tr><td align="center">href</td><td align="center">如果是使用<code>&lt;link&gt;</code>包含的样式表，则返回样式表的URL，否则返回null</td></tr><tr><td align="center">media</td><td align="center">样式表支持的媒体类型集合，这个集合有一个length属性和一个item()方法，跟所有DOM集合一样。同样跟所有DOM集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表</td></tr><tr><td align="center">owmerNode</td><td align="center">指向拥有当前样式表的节点，在HTML中要么是&lt;1ink&gt;元素要么是<code>&lt;sty1e&gt;</code>元素(在XML中可以是处理指令)。如果当前样式表是通过@import被包含在另一个样式表中，则这个属性值为null。</td></tr><tr><td align="center">parentstylesheet</td><td align="center">如果当前样式表是通过@import被包含在另一个样式表中， 则这个属性指向导人它的样式表</td></tr><tr><td align="center">title</td><td align="center">ownerNode 的title属性</td></tr><tr><td align="center">type</td><td align="center">字符串，表示样式表的类型。对CSS样式表来说，就是”text/css”</td></tr></tbody></table><ul><li>CSSStyleSheet类型还支持以下属性和方法：</li></ul><table><thead><tr><th align="center">属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">cssRules</td><td align="center">当前样式表包含的样式规则的集合</td></tr><tr><td align="center">ownerRule</td><td align="center">如果样式表是使用@import导人的，则指向导人规则；否则为null。</td></tr><tr><td align="center">deleteRule(index)</td><td align="center">在指定位置删除cssRules中的规则</td></tr><tr><td align="center">insertRule(rule, index)</td><td align="center">在指定位置向cssRules中插人规则</td></tr></tbody></table><h3 id="1）CSS规则"><a href="#1）CSS规则" class="headerlink" title="1）CSS规则"></a>1）CSS规则</h3><ul><li>CSSRule类型<strong>表示样式表中的一条规则</strong>。</li><li>这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的cssstyleRule (其他CSS规则还有@import、@font-face、@page和@charset等，不过这些规则很少需要使用脚本来操作)。</li><li>CSSStyleRule对象上的可用属性：<ul><li>cssText：返回整条规则的文本。这里的文本可能与样式表中实际的文本不-样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。</li><li>parentRule：如果这条规则被其他规则(如@media)包含，则指向包含规则，否则就是null。</li><li>parentStyleSheet：包含当前规则的样式表。</li><li>selectorText：返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在Firefox、Safari 、Chrome和IE中是只读的，在Opera中是可以修改的。</li><li>style：返回cssstyleDeclaration对象，可以设置和获取当前规则中的样式。</li><li>type：数值常量，表示规则类型。对于样式规则，它始终为1。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span> &#123; </span><br><span class="line">    <span class="attribute">background-color</span>: blue; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>假设这条规则位于页面中的第一个样式表中，而且是该样式表中唯一一条 CSS规则，则下列代码可以获取它的所有信息:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.cssRules || sheet.rules; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line"><span class="built_in">console</span>.log(rule.selectorText); <span class="comment">// &quot;div.box&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(rule.style.cssText); <span class="comment">// 完整的 CSS 代码</span></span><br><span class="line"><span class="built_in">console</span>.log(rule.style.backgroundColor); <span class="comment">// &quot;blue&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(rule.style.width); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(rule.style.height); <span class="comment">// &quot;200px&quot; </span></span><br></pre></td></tr></table></figure><h3 id="2）创建规则"><a href="#2）创建规则" class="headerlink" title="2）创建规则"></a>2）创建规则</h3><ul><li>可以使用insertRule()方法向样式表中添加规则。<ul><li>方法接收两个参数：规则的文本和表示插入位置的索引值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet.insertRule(<span class="string">&quot;body &#123; background-color: silver &#125;&quot;</span>, <span class="number">0</span>); <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3）删除规则"><a href="#3）删除规则" class="headerlink" title="3）删除规则"></a>3）删除规则</h3><ul><li>deleteRule()方法支持从样式表中删除规则。<ul><li>接受一个参数：要删除规则的索引。</li></ul></li></ul><h2 id="3、元素尺寸"><a href="#3、元素尺寸" class="headerlink" title="3、元素尺寸"></a>3、元素尺寸</h2><h3 id="1）偏移尺寸"><a href="#1）偏移尺寸" class="headerlink" title="1）偏移尺寸"></a>1）偏移尺寸</h3><ul><li>元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框(但不包含外边距)。</li><li>以下4个属性用于取得元素的偏移尺寸：<ul><li>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度(如果可见)和上、下边框的高度。</li><li>offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。</li><li>offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。</li><li>offsetwidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。</li></ul></li><li>其中，offsetLeft和 offsetTop是相对于包含元素的，包含元素保存在offsetParent属性中。offsetParent不一定是parentNode。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/06/js-41/pic1.png" class title="# tu1"><h3 id="2）客户端尺寸"><a href="#2）客户端尺寸" class="headerlink" title="2）客户端尺寸"></a>2）客户端尺寸</h3><ul><li>元素的客户端尺寸( client dimensions)包含元素内容及其内边距所占用的空间。</li><li>客户端尺寸只有两个相关属性:clientwidth和 clientHeight。<ul><li>clientwidth是内容区宽度加左、右内边距宽度，</li><li>clientHeight是内容区高度加上、下内边距高度。</li></ul></li><li><strong>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间</strong>。</li><li>这两个属性最常用于确定浏览器视口尺寸,即检测document. documentElement的clientwidth和clientHeight。这两个属性表示视口(<code>&lt;html&gt;</code>或<code>&lt;body&gt;</code>元素)的尺寸。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/06/js-41/pic2.png" class title="# tu1"><h3 id="3）滚动尺寸"><a href="#3）滚动尺寸" class="headerlink" title="3）滚动尺寸"></a>3）滚动尺寸</h3><ul><li>滚动尺寸( scroll dimensions)，提供了元素内容滚动距离的信息。</li><li>有些元素，比如<code>&lt;html&gt;</code>无须任何代码就可以自动滚动，而其他元素则需要使用CSS的overflow属性令其滚动。</li><li>滚动尺寸相关的属性有如下4个：<ul><li>scrollHeight：没有滚动条出现时，元素内容的总高度。</li><li>scrollLeft：内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li>scrollTop：内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li>scrollwidth：没有滚动条出现时，元素内容的总宽度。</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/06/js-41/pic3.png" class title="# tu1"><ul><li>scrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。</li><li>scrollWidth和 scrollHeight 与clientwidth和clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollwidth和 scollHeight等于文档内容的宽度，而clientwidth和clientHeight 等于视口的大小。</li><li>scrollLeft和 scrollTop属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于0。如果元素在垂直方向上滚动，则scrollTop 会大于0，表示元素顶部不可见区域的高度。如果元素在水平方向上滚动,则scrollLeft会大于0，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的,所以把它们都设置为О就可以重置元素的滚动位置。</li></ul><h3 id="4）确定元素尺寸"><a href="#4）确定元素尺寸" class="headerlink" title="4）确定元素尺寸"></a>4）确定元素尺寸</h3><ul><li>浏览器在每个元素上都暴露了getBoundingclientRect ()方法，返回一个DOMRect对象，包含6个属性:left、 top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视口的位置。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/06/js-41/pic4.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;样式&quot;&gt;&lt;a href=&quot;#样式&quot; class=&quot;headerlink&quot; title=&quot;样式&quot;&gt;&lt;/a&gt;样式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTML样式有3种定义方法：外部样式表、文档样式表、元素特定样式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、存取元素样式&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十）DOM2和DOM3（一）</title>
    <link href="http://example.com/2021/12/03/js-40/"/>
    <id>http://example.com/2021/12/03/js-40/</id>
    <published>2021-12-03T10:45:34.000Z</published>
    <updated>2021-12-06T08:07:57.482Z</updated>
    
    <content type="html"><![CDATA[<ul><li>DOM1(DOMLevel1)主要定义了HTML和XML文档的底层结构。</li><li>DOM2(DOMLevel2)和DOM3 ( DOM Level3 )在这些结构之上加入更多交互能力，提供了更高级的XML特性。</li><li>DOM2和DOM3是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个DOM子集。这些模式如下所示。<ul><li>DOM Core:在DOM1核心部分的基础上，为节点增加方法和属性。</li><li>DOM Views:定义基于样式信息的不同视图。</li><li>DOM Events:定义通过事件实现DOM文档交互。</li><li>DOM Style:定义以编程方式访问和修改CSS样式的接口。</li><li>DOM Traversal and Range:新增遍历DOM文档及选择文档内容的接口。</li><li>DOM HTML:在DOM1 HTML部分的基础上，增加属性、方法和新接口。</li><li>DOM Mutation Observers:定义基于DOM变化触发回调的接口。这个模块是DOM4级模块，用于取代Mutation Events。</li></ul></li></ul><h1 id="DOM的演进"><a href="#DOM的演进" class="headerlink" title="DOM的演进"></a>DOM的演进</h1><ul><li>DOM2和DOM3Core模块的目标是扩展DOMAPI,满足XML的所有需求并提供更好的错误处理和特性检测。</li><li>DOM2 Core没有新增任何类型，仅仅在DOM1 Core基础上增加了一些方法和属性。</li><li>DOM3 Core除了增强原有类型，也新增了一些新类型。</li></ul><h2 id="1、XML命名空间"><a href="#1、XML命名空间" class="headerlink" title="1、XML命名空间"></a>1、XML命名空间</h2><ul><li>XML命名空间可以实现在一个格式规范的文档中混用不同的XML语言，而不必担心元素命名冲突。严格来讲，XML命名空间在XHTML中才支持，HTML并不支持。</li><li>命名空间是使用xmlns指定的。XHTML的命名空间是”<a class="link" href="http://www.w3.org/1999/xhtml&quot;%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E5%9C%A8%E4%BB%BB%E4%BD%95%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E7%9A%84XHTML%E9%A1%B5%E9%9D%A2%E7%9A%84%60%60%60">http://www.w3.org/1999/xhtml&quot;，应该包含在任何格式规范的XHTML页面的```<i class="fas fa-external-link-alt"></i></a><html>```元素中：</html></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Hello world! </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><ul><li><p>对这个例子来说，所有元素都默认属于XHTML命名空间。可以使用xmlns给命名空间创建一个前缀，格式为“xmlns：前缀”，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xhtml:html</span> <span class="attr">xmlns:xhtml</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">xhtml:head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">xhtml:title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">xhtml:title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">xhtml:head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">xhtml:body</span>&gt;</span> </span><br><span class="line">    Hello world! </span><br><span class="line">    <span class="tag">&lt;/<span class="name">xhtml:body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xhtml:html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DOM2 Core为解决以下问题，给大部分DOM1方法提供了特定于命名空间的版本。</p><ul><li>创建了一个新元素，那这个元素属于哪个命名空间？</li><li>查询特定标签名时，结果中应该包含哪个命名空间下的元素？</li></ul></li></ul><h3 id="1）Node的变化"><a href="#1）Node的变化" class="headerlink" title="1）Node的变化"></a>1）Node的变化</h3><ul><li>在DOM2中，Node类型包含以下特定于命名空间的属性：<ul><li>localName：不包含命名空间前缀的节点名；</li><li>namespaceURI：节点的命名空间URL，如果未指定则为null；</li><li>prefix：命名空间前缀，如果未指定则为null。</li><li><strong>在节点使用命名空间前缀的情况下，nodeName 等于prefix+ “:”+ localName。</strong></li></ul></li><li>DOM3进一步增加了如下与命名空间相关的方法：<ul><li>isDefaultNamespace(namespaceURI)，返回布尔值，表示namespaceURI是否为节点的默认命名空间。</li><li>lookupNamespaceURI(prefix)，返回给定prefix的命名空间URI；</li><li>lookupPrefix(namespaceURI)，返回给定namespaceURI的前缀。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:svg</span> <span class="attr">xmlns:s</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%; height:100%&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">s:rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:red&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">s:svg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body.isDefaultNamespace(<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 假设 svg 包含对&lt;s:svg&gt;元素的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(svg.lookupPrefix(<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>)); <span class="comment">// &quot;s&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(svg.lookupNamespaceURI(<span class="string">&quot;s&quot;</span>)); <span class="comment">// &quot;http://www.w3.org/2000/svg&quot; </span></span><br></pre></td></tr></table></figure><h3 id="2）Document的变化"><a href="#2）Document的变化" class="headerlink" title="2）Document的变化"></a>2）Document的变化</h3><ul><li>DOM2在Document类型上新增了如下命名空间特定的方法：<ul><li>createElementNs(namespaceURI, tagName), 以给定的标签名tagName创建指定命名空间namespaceURI的一个新元素；</li><li>createAttributeNS (namespaceURI, attributeName),以给定的属性名attributeName创建指定命名空间namespaceURI的一个新属性；</li><li>getElementsByTagNameNS (namespaceURI, tagName) ，返回指定命名空间namespaceURI中所有标签名为tagName的元素的NodeList。</li></ul></li><li>这些命名控件特定的方法只在文档中包含两个或两个以上命名空间时才有用。</li></ul><h3 id="3）Element的变化"><a href="#3）Element的变化" class="headerlink" title="3）Element的变化"></a>3）Element的变化</h3><ul><li>DOM2 Core对Element类型的更新主要集中在对属性的操作上。下面是新增的方法：<ul><li>getElementsByTagNameNS (namespaceURI, tagName) ，取得指定命名空间namespaceURI中标签名为tagName的元素的NodeList;</li><li>hasAttributeNS (namespaceURI, localName)， 返回布尔值，表示元素中是否有命名空间namespaceURI下名为localName的属性(注意，DOM2Core也添加不带命名空间的hasAttribute()方法);</li><li>removeAttributeNS (namespaceURI, localName) ，删除指定命名空间namespaceURI中名为localName的属性;</li><li>setAttributeNS (namespaceURI, qualifiedName,value)，设置指定命名空间namespaceURI中名为qualifiedName的属性为value；</li><li>setAttributeNodeNS (attNode)，为元素设置(添加)包含命名空间信息的属性节点attNode。</li></ul></li><li>这些方法与DOM1中对应的方法行为相同，除setAttributeNodeNS()之外都只是多了一个命名空间参数。</li></ul><h3 id="4）NamedNodeMap的变化"><a href="#4）NamedNodeMap的变化" class="headerlink" title="4）NamedNodeMap的变化"></a>4）NamedNodeMap的变化</h3><ul><li>NamedNodeMap也增加了以下处理命名空间的方法。<strong>因为NamedNodeMap主要表示属性，所以这些方法大都适用于属性</strong>：<ul><li>getNamedItemNS (namespaceURI, localName), 取得指定命名空间namespaceURI中名为localName的项; </li><li>removeNamedItemNS (namespaceURI, localName)，删除指定命名空间namespaceURI 中名为loca1Name的项；</li><li>setNamedItemNS (node)，为元素设置(添加)包含命名空间信息的节点。</li></ul></li></ul><h2 id="2、其他变化"><a href="#2、其他变化" class="headerlink" title="2、其他变化"></a>2、其他变化</h2><h3 id="1）DocumentType的变化"><a href="#1）DocumentType的变化" class="headerlink" title="1）DocumentType的变化"></a>1）DocumentType的变化</h3><ul><li>新增了三个属性：publicId、systemId和internalSubset。publicId、systemId属性表示文档类型声明中有效但无法使用DOM1 API访问的数据。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-// W3C// DTD HTML 4.01// EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>publicId是”-// W3C// DTD HTML 4.01// EN”；</li><li>systemId是”<a class="link" href="http://www.w3.org/TR/html4/strict.dtd&quot;%EF%BC%9B">http://www.w3.org/TR/html4/strict.dtd&quot;；<i class="fas fa-external-link-alt"></i></a></li><li>支持DOM2的浏览器应该可以运行以下JavaScript代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.doctype.publicId); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.doctype.systemId); </span><br></pre></td></tr></table></figure><ul><li>internalsubset用于访问文档类型声明中可能包含的额外定义，如下面的例子所示：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span> </span></span><br><span class="line"><span class="meta">[<span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>] &gt;</span> </span><br></pre></td></tr></table></figure><ul><li>对于以上声明，document . doctype. internalSubset会返回”<!ELEMENT name (#PCDATA)>“。HTML文档中几乎不会涉及文档类型的内部子集，XML文档中稍微常用一些。</li></ul><h3 id="2）Document的变化-1"><a href="#2）Document的变化-1" class="headerlink" title="2）Document的变化"></a>2）Document的变化</h3><ul><li><p>唯一与命名空间无关的方法：importNode()。</p><ul><li>用于从其他文档获取一个节点并导入到新文档，以便将其插入新文档。</li><li>接收两个参数：要复制的节点和表示是否同时复制子树的布尔值。</li><li>返回结果是适合在当前文档中使用的新节点。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newNode = <span class="built_in">document</span>.importNode(oldNode, <span class="literal">true</span>); <span class="comment">// 导入节点及所有后代</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(newNode);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>由于每个节点都有一个ownerDocument属性，表示所属文档；如果调用appendChild()方法时传入节点的owerDocument不是指向当前文档，则会发生错误；而调用importNode()导入其他文档的节点会返回一个新节点，这个新节点的owerDocument属性时正确的。</p></li><li><p>DOM2 View给Document类型增加了新属性defaultView，是一个指向拥有当前文档的窗口的指针。</p><ul><li>并没有明确视图何时可用，因此这是添加的唯一一个属性。</li><li>可用于确定拥有文档的窗口。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentWindow = <span class="built_in">document</span>.defaultView || <span class="built_in">document</span>.parentWindow;</span><br></pre></td></tr></table></figure><ul><li><p>DOM2 Core还针对document.implementation对象增加了两个新方法: createDocumentType ()和createDocument ()。</p></li><li><p><strong>createDocumentType：</strong></p><ul><li>用于创建DocumentType类型的新节点；</li><li>接收三个参数：文档类型名称、publicId和systemld。</li><li>createDocumentType()只在创建新文档时才会用到。</li></ul></li><li><p><strong>createDocument()：</strong></p><ul><li>接收三个参数：文档元素的namespaceURI、文档元素的标签名和文档类型。</li></ul></li><li><p>要创建一个XHTML文档，可以使用以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="built_in">document</span>.implementation.createDocumentType(<span class="string">&quot;html&quot;</span>, <span class="string">&quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot;</span>, <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> doc = <span class="built_in">document</span>.implementation.createDocument(<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>, </span><br><span class="line"> <span class="string">&quot;html&quot;</span>, doctype); </span><br></pre></td></tr></table></figure></li><li><p>DOM2 HTML模块也为document.implamentation对象添加了createHTMLDocument()方法。</p><ul><li>方法可以创建一个完整的HTML文档，包含<code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;</code>元素。</li><li>直接收一个参数：创建文档的标题（放到title元素中）</li><li>返回一个新的HTML文档。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> htmldoc = <span class="built_in">document</span>.implementation.createHTMLDocument(<span class="string">&quot;New Doc&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(htmldoc.title); <span class="comment">// &quot;New Doc&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> htmldoc.body); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3）Node的变化"><a href="#3）Node的变化" class="headerlink" title="3）Node的变化"></a>3）Node的变化</h3><ul><li><p>DOM3新增了两个用于比较节点的方法：isSameNode()和isEqualNode()。</p><ul><li>两个方法都接收一个参数：节点参数；</li><li>返回值：如果这个节点与参考节点相同或相等，则返回true；反之返回false。</li><li>节点相同，意味着引用同一个对象；</li><li>节点相等，意味着节点类型相同，拥有相等的属性( nodeName、nodevalue等)，而且attributes和childNodes也相等(即同样的位置包含相等的值)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">div1.setAttribute(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;box&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> div2 = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">div2.setAttribute(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;box&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(div1.isSameNode(div1)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(div1.isEqualNode(div2)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(div1.isSameNode(div2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>setUserData()：</p><ul><li>给DOM节点附加额外数据的方法。</li><li>接收三个参数：键、值、处理函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.setUserData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;); </span><br></pre></td></tr></table></figure></li></ul></li><li><p>处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行，可以在这时候决定如何处理用户数据。</p></li><li><p>处理函数接收五个参数：<strong>表示操作类型的数值</strong>( 1代表复制，2代表导人，3代表删除，4代表重命名)<strong>、数据的键、数据的值、源节点和目标节点</strong>。</p></li><li><p>删除节点时，源节点为null；除复制外，目标节点都为null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">div.setUserData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">operation, key, value, src, dest</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (operation == <span class="number">1</span>) &#123; </span><br><span class="line">        dest.setUserData(key, value, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> newDiv = div.cloneNode(<span class="literal">true</span>); </span><br><span class="line"><span class="built_in">console</span>.log(newDiv.getUserData(<span class="string">&quot;name&quot;</span>)); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里先创建了一个&lt;div&gt;元素，然后给它添加了一-些数据，包含用户的名字。在使用cloneNode ()复制这个元素时，就会调用处理函数，从而将同样的数据再附加给复制得到的目标节点。然后，在副本节点上调用getUserData ()能够取得附加到源节点上的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4）内嵌窗格的变化"><a href="#4）内嵌窗格的变化" class="headerlink" title="4）内嵌窗格的变化"></a>4）内嵌窗格的变化</h3><ul><li>DOM2 HTML给HTMLIFrameElement类型新增了一个属性：contentDocument。<ul><li>contentDocument属性时Document的实例，拥有所有文档属性和方法</li></ul></li><li>contentWindow属性返回相应窗格的window对象，这个对象上有一个document属性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;DOM1(DOMLevel1)主要定义了HTML和XML文档的底层结构。&lt;/li&gt;
&lt;li&gt;DOM2(DOMLevel2)和DOM3 ( DOM Level3 )在这些结构之上加入更多交互能力，提供了更高级的XML特性。&lt;/li&gt;
&lt;li&gt;DOM2和DOM3是按</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十九）DOM扩展（二）</title>
    <link href="http://example.com/2021/12/02/js-39/"/>
    <id>http://example.com/2021/12/02/js-39/</id>
    <published>2021-12-02T08:10:00.000Z</published>
    <updated>2021-12-04T08:38:02.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h1><h2 id="1、children属性"><a href="#1、children属性" class="headerlink" title="1、children属性"></a>1、children属性</h2><ul><li>children属性是一个HTMLCollection，只包含元素的Element类型的子节点。</li><li>如果元素的子节点类型全部是元素类型，那children和childNodes中包含的节点应该是一样的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childCount = element.children.length; </span><br><span class="line"><span class="keyword">let</span> firstChild = element.children[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="2、contains-方法"><a href="#2、contains-方法" class="headerlink" title="2、contains()方法"></a>2、contains()方法</h2><ul><li><p>DOM编程中经常需要确定一个元素是不是另一个元素的后代。</p></li><li><p>IE引入了contains()方法，让开发者可以在不遍历DOM的情况下获取这个信息。</p><ul><li>参数为待确定的目标节点；</li><li>如果目标节点是被搜索节点的后代，返回true；否则返回false。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子测试&lt;html&gt;元素中是否包含&lt;body&gt;元素，在格式正确的HTML中会返回true。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.contains(<span class="built_in">document</span>.body)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用DOM Level 3的compareDocumentPosition()方法也可以确定节点间的关系。</p><ul><li>方法会返回表示两个节点关系的位掩码。</li><li>下表给出了这些位掩码的说明。<table><thead><tr><th align="center">掩码</th><th align="center">节点关系</th></tr></thead><tbody><tr><td align="center">0x1</td><td align="center">断开（传入的节点不在文档中）</td></tr><tr><td align="center">0x2</td><td align="center">领先(传人的节点在DOM树中位于参考节点之前)</td></tr><tr><td align="center">0x4</td><td align="center">随后(传入的节点在DOM树中位于参考节点之后)</td></tr><tr><td align="center">0x8</td><td align="center">包含(传入的节点是参考节点的祖先)</td></tr><tr><td align="center">0x10</td><td align="center">被包含(传人的节点是参考节点的后代)</td></tr></tbody></table></li></ul></li><li><p>要模仿contains()方法，就需要用到掩码16 ( 0x10 )。compareDocumentPosition()方法的结果可以通过按位与来确定参考节点是否包含传入的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">document</span>.documentElement.compareDocumentPosition(<span class="built_in">document</span>.body); </span><br><span class="line"><span class="built_in">console</span>.log(!!(result &amp; <span class="number">0x10</span>)); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以上代码执行后result的值为20 (或0x14,其中0x4表示“随后”，加上0x10“被包含”)。对result和0x10应用按位与会返回非零值，而两个叹号将这个值转换成对应的布尔值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3、插入标记"><a href="#3、插入标记" class="headerlink" title="3、插入标记"></a>3、插入标记</h2><ul><li>HTML5将IE发明的innerHTML和outerHTML纳人了标准，但还有两个属性没有入选。这两个剩下的属性是innerText和outerText。</li></ul><h3 id="（1）innerText属性"><a href="#（1）innerText属性" class="headerlink" title="（1）innerText属性"></a>（1）innerText属性</h3><ul><li>innerText属性<strong>对应元素中包含的所有文本内容，无论文本在子树中哪个层级</strong>。</li><li>在用于读取值时，innerText会按照<strong>深度优先的顺序</strong>将子树中所有文本节点的值拼接起来。</li><li>在用于写入值时，innerText会移除元素的所有后代并插入一个包含该值的文本节点。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对这个例子中的&lt;div&gt;而言，innerText 属性会返回以下字符串:</span></span><br><span class="line"><span class="comment">This is a paragraph with a list following it .</span></span><br><span class="line"><span class="comment">Item 1</span></span><br><span class="line"><span class="comment">Item 2</span></span><br><span class="line"><span class="comment">Item 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><strong>设置innerText会移除元素之前所有的后代节点，完全改变DOM子树</strong>。此外，设置innerText也会编码出现在字符串中的HTML语法字符(小于号、大于号、引号及和号)。</li><li>因为设置innerText只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必须进行HTML编码。</li><li>innerText 属性可以用于去除HTML标签。<strong>通过将innerText 设置为等于innerText，可以去除所有HTML标签而只剩文本。</strong></li></ul><h3 id="（2）outerText属性"><a href="#（2）outerText属性" class="headerlink" title="（2）outerText属性"></a>（2）outerText属性</h3><ul><li>outerText与innerText 是类似的，只不过<strong>作用范围包含调用它的节点</strong>。</li><li>要读取文本值时，outerText与innerText实际上会返回同样的内容。</li><li>写入文本值时，<strong>outerText 不止会移除所有后代节点，而是会替换整个元素</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.outerText = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"><span class="comment">//等价于以下两行代码</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">div.parentNode.replaceChild(text, div); </span><br></pre></td></tr></table></figure><ul><li>本质上，这相当于<strong>用新的文本节点替代outerText所在的元素</strong>。此时，原来的元素会与文档脱离关系，因此也无法访问。</li><li>outerText是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除Firefox之外所有主流浏览器都支持outerText。</li></ul><h2 id="4、滚动"><a href="#4、滚动" class="headerlink" title="4、滚动"></a>4、滚动</h2><ul><li>HTML5把scrollIntoView()标准化了，但不同浏览器中仍然有其他专有方法。</li><li>scrollIntoViewIfNeeded()作为HTMLElement类型的扩展可以在所有元素上调用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;专有扩展&quot;&gt;&lt;a href=&quot;#专有扩展&quot; class=&quot;headerlink&quot; title=&quot;专有扩展&quot;&gt;&lt;/a&gt;专有扩展&lt;/h1&gt;&lt;h2 id=&quot;1、children属性&quot;&gt;&lt;a href=&quot;#1、children属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十八）DOM扩展（二）</title>
    <link href="http://example.com/2021/12/01/js-38/"/>
    <id>http://example.com/2021/12/01/js-38/</id>
    <published>2021-12-01T05:00:30.000Z</published>
    <updated>2021-12-02T08:08:50.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><ul><li>HTML5规范包含了与标记相关的大量 JavaSeript API定义。其中有的API与DOM重合，定义了浏览器应该提供的DOM扩展。</li></ul><h2 id="一、CSS类扩展"><a href="#一、CSS类扩展" class="headerlink" title="一、CSS类扩展"></a>一、CSS类扩展</h2><h3 id="1、getElementByClassName"><a href="#1、getElementByClassName" class="headerlink" title="1、getElementByClassName()"></a>1、getElementByClassName()</h3><ul><li><p>该方法暴露在document对象和所有HTML元素上。</p><ul><li>方法接收一个参数：包含一个或多个类名的字符串；</li><li>返回类名中包含相应类的元素的NodeList；</li><li>如果提供了多个类名，则顺序无关紧要。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;username current&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).getElementsByClassName(<span class="string">&quot;selected&quot;</span>); </span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素上调用getElementsByClassName()则返回该元素后代中匹配的元素。</p></li></ul><h3 id="2、classList属性"><a href="#2、classList属性" class="headerlink" title="2、classList属性"></a>2、classList属性</h3><ul><li>classList属性是为了更加方便的对于类名进行增删改查操作。<ul><li>classList是一个新的集合类型DOMTokenList的实例。</li><li>除开length属性，item()和中括号取值等操作外，还增加了以下方法：<ul><li>add(value)：向类名列表中添加指定的字符串值value。如果这个值已经存在,则什么也不做。</li><li>contains(value)：返回布尔值,表示给定的value是否存在。</li><li>remove(value)：从类名列表中删除指定的字符串值value。</li><li>toggle(value)：如果类名列表中已经存在指定的value，则删除；如果不存在，则添加。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.classList.remove(<span class="string">&quot;disabled&quot;</span>); </span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.classList.add(<span class="string">&quot;current&quot;</span>);</span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.classList.toggle(<span class="string">&quot;user&quot;</span>); </span><br><span class="line"><span class="comment">// 检测类名 </span></span><br><span class="line"><span class="keyword">if</span> (div.classList.contains(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.classList.contains(<span class="string">&quot;disabled&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="class"><span class="keyword">class</span> <span class="title">of</span> <span class="title">div</span>.<span class="title">classList</span>)</span>&#123; </span><br><span class="line">    doStuff(<span class="class"><span class="keyword">class</span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>添加了classList属性之后，除非是完全删除或完全重写元素的class属性，否则className属性就用不到了。</li></ul><h2 id="二、焦点管理"><a href="#二、焦点管理" class="headerlink" title="二、焦点管理"></a>二、焦点管理</h2><ul><li>HTML5增加了辅助DOM焦点管理的功能。首先是document.activeElement，始终包含当前拥有焦点的 DOM元素。</li><li>页面加载时，可以通过用户输人(按Tab键或代码中使用focus()方法）让某个元素自动获得焦点。</li><li>默认情况下，document.activeElement在页面刚加载完之后会设置为document.body。而在页面完全加载之前，document.activeElement的值为null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.focus(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点。</li><li>确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.focus(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus()); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><ul><li>这对于保证 Web应用程序的无障碍使用是非常重要的。无障碍Web应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。</li></ul><h2 id="三、HTMLDocument扩展"><a href="#三、HTMLDocument扩展" class="headerlink" title="三、HTMLDocument扩展"></a>三、HTMLDocument扩展</h2><h3 id="1、readyState属性"><a href="#1、readyState属性" class="headerlink" title="1、readyState属性"></a>1、readyState属性</h3><ul><li>document.readyState属性有两个可能的值：<ul><li>loading：表示文档正在加载；</li><li>complete：表示文档加载完成。</li></ul></li><li>实际开发中，最好是把 document.readstate当成一个指示器，以判断文档是否加载完毕。</li><li>通常要依赖onload事件处理程序设置一个标记，表示文档加载完了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">&quot;complete&quot;</span>)&#123; </span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2、compatMode属性"><a href="#2、compatMode属性" class="headerlink" title="2、compatMode属性"></a>2、compatMode属性</h3><ul><li>这个属性唯一的任务是指示浏览器当前处于什么渲染模式。</li><li>标准模式下document.compatMode的值是“CSSlCompat”。</li><li>混杂模式下document.compatMode的值是“BlackCompat”。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">&quot;CSS1Compat&quot;</span>)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Standards mode&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Quirks mode&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3、head属性"><a href="#3、head属性" class="headerlink" title="3、head属性"></a>3、head属性</h3><ul><li>document.head属性指向文档的<code>&lt;head&gt;</code>元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="built_in">document</span>.head;</span><br></pre></td></tr></table></figure><h2 id="四、字符集属性"><a href="#四、字符集属性" class="headerlink" title="四、字符集属性"></a>四、字符集属性</h2><ul><li>characterSet属性表示文档实际使用的字符集，也可以用来指定新字符集。</li><li>属性的默认值是“UTF-16”，可以通过<code>&lt;meta&gt;</code>元素或响应头以及新增的characterSeet属性来修改。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.characterSet); <span class="comment">// &quot;UTF-16&quot; </span></span><br><span class="line"><span class="built_in">document</span>.characterSet = <span class="string">&quot;UTF-8&quot;</span>; </span><br></pre></td></tr></table></figure><h2 id="五、自定义数据属性"><a href="#五、自定义数据属性" class="headerlink" title="五、自定义数据属性"></a>五、自定义数据属性</h2><ul><li>HTML5允许给元素指定<strong>非标准的属性</strong>，但要使用前缀data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。</li><li>除了前缀，自定义属性对命名是没有限制的,data-后面跟什么都可以。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span> data-appId=<span class="string">&quot;12345&quot;</span> data-myname=<span class="string">&quot;Nicholas&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>定义了自定义数据属性后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap的实例，包含一组键/值对映射。</li><li>元素的每个data-name 属性在dataset 中都可以通过data-后面的字符串作为键来访问(例如，属性data-myname,data-myName可以通过myname访问，但要注意data-my-name、data-My-Name要通过myName 来访问)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.dataset.appId; </span><br><span class="line"><span class="keyword">let</span> myName = div.dataset.myname; </span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.dataset.appId = <span class="number">23456</span>; </span><br><span class="line">div.dataset.myname = <span class="string">&quot;Michael&quot;</span>; </span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、插入标记"><a href="#六、插入标记" class="headerlink" title="六、插入标记"></a>六、插入标记</h2><ul><li>在所有现代浏览器中，通过innerHTML插入的<code>&lt;script&gt;</code>标签是不会执行的。</li></ul><h3 id="1、innerHTML属性"><a href="#1、innerHTML属性" class="headerlink" title="1、innerHTML属性"></a>1、innerHTML属性</h3><ul><li><p>在读取innerHTML属性时，会返回<strong>元素所有后代的HTML字符串，包括元素、注释和文本节点</strong>。</p></li><li><p>在写入innerHTML时，则<strong>会根据提供的字符串值以新的DOM子树替代元素中原来包含的所有节点</strong>。</p></li><li><p>比如下面的 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>对于这里的<code>&lt;div&gt;</code>元素而言，其 innerHTML 属性会返回以下字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt; with a list following it.&lt;/</span>p&gt; </span><br><span class="line">&lt;ul&gt; </span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;/li&gt; </span><br><span class="line">    &lt;li&gt;Item <span class="number">2</span>&lt;/li&gt; </span><br><span class="line">    &lt;li&gt;Item <span class="number">3</span>&lt;/li&gt; </span><br><span class="line">&lt;/ul&gt; </span><br></pre></td></tr></table></figure></li><li><p>实际返回的文本内容会因浏览器而不同：</p><ul><li>IE 和 Opera 会把所有元素标签转换为大写；</li><li>Safari、Chrome和 Firefox 会按照文档源代码的格式返回，包含空格和缩进。</li></ul></li><li><p>在写人模式下，赋给innerHTML属性的值会被解析为DOM子树，并替代元素之前的所有节点。如果赋值中不包含任何HTML标签，则直接生成一个文本节点。</p><ul><li>因为所赋的值默认为HTML，所以其中的所有标签都会以浏览器处理HTML的方式转换为元素(同样，转换结果也会因浏览器不同而不同)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">&quot;Hello world!&quot;</span>; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>因为浏览器会解析设置的值，所以给innerHTML， 设置包含HTML的字符串时，结果会大不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello <span class="symbol">&amp;amp;</span> welcome, <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="symbol">&amp;quot;</span>reader<span class="symbol">&amp;quot;</span>!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置innerHTML会导致浏览器将HTML字符串解析为相应的DOM树。这意味着设置innerHTML属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 DOM子树序列化之后的结果。</p></li></ul><h3 id="2、outerHTML属性"><a href="#2、outerHTML属性" class="headerlink" title="2、outerHTML属性"></a>2、outerHTML属性</h3><ul><li>读取 outerHTML属性时，会返回调用它的元素（及所有后代元素)的 HTML字符串。</li><li>在写入outerHTML属性时，调用它的元素会被传入的 HTML字符串经解释之后生成的 DOM子树取代。</li><li>如果使用outerHTML设置HTML，比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.outerHTML = <span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>会得到与执行以下脚本相同的结果：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>); </span><br><span class="line">p.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;This is a paragraph.&quot;</span>)); </span><br><span class="line">div.parentNode.replaceChild(p, div);</span><br></pre></td></tr></table></figure>新的<code>&lt;p&gt;</code>元素会取代 DOM 树中原来的<code>&lt;div&gt;</code>元素。</li></ul><h3 id="3、insertAdjacentHTML-与insertAdjacentText"><a href="#3、insertAdjacentHTML-与insertAdjacentText" class="headerlink" title="3、insertAdjacentHTML()与insertAdjacentText()"></a>3、insertAdjacentHTML()与insertAdjacentText()</h3><ul><li>这两个方法都接收两个参数：<ul><li>要插入标记的位置；</li><li>要插入的HTML或文本。</li></ul></li><li>第一个参数必须是下列值中的一个：<ul><li>beforebegin：插入当前元素前面，作为前一个同胞节点；</li><li>afterbegin：插入当前元素内部，作为新的子节点或放在第一个子节点前面；</li><li>beforeend：插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li><li>afterend：插入当前元素后面，作为下一个同胞节点。</li></ul></li><li>这几个值是不区分大小写的。第二个参数会作为HTML字符串解析(与innerHTML 和outerHTML相同)或者作为纯文本解析(与innerText和outerText相同)。 如果是HTML，则会在解析出错时抛出错误。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为第一个子节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element. </span><br><span class="line">insertAdjacentText(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br></pre></td></tr></table></figure><h3 id="4、内存与性能问题"><a href="#4、内存与性能问题" class="headerlink" title="4、内存与性能问题"></a>4、内存与性能问题</h3><ul><li>使用以上方法替换子节点可能在浏览器(特别是IE)中导致内存问题。</li></ul><h2 id="七、scrollIntoView"><a href="#七、scrollIntoView" class="headerlink" title="七、scrollIntoView()"></a>七、scrollIntoView()</h2><ul><li>DOM规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5选择了标准化scrollIntoView()。</li><li>scrollIntoView()方法存在于所有HTML元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。参数如下：<ul><li>alignToTop是一个布尔值：<ul><li>true：窗口滚动后元素的顶部与视口顶部对齐。</li><li>false：窗口滚动后元素的底部与视口底部对齐。</li></ul></li><li>scrollIntoViewOptions是一个选项对象：<ul><li>behavior：定义过渡动画，可取的值为” smooth”和”auto”，默认为”auto”。</li><li>block：定义垂直方向的对齐，可取的值为“start”、“center”、“end”和“nearest”，默认为“start”。</li><li>inline：定义水平方向的对齐，可取的值为“start”、“center”、“end”和“nearest”，默认为“nearest”。</li></ul></li><li>不传参数等同于alignToTop为true。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保元素可见</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(); </span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(<span class="literal">true</span>); </span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(&#123;<span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;); </span><br><span class="line"><span class="comment">// 尝试将元素平滑地滚入视口</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML5&quot;&gt;&lt;a href=&quot;#HTML5&quot; class=&quot;headerlink&quot; title=&quot;HTML5&quot;&gt;&lt;/a&gt;HTML5&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTML5规范包含了与标记相关的大量 JavaSeript API定义。其中有的API与DOM重合，定义</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十七）DOM扩展（一）</title>
    <link href="http://example.com/2021/11/30/js-37/"/>
    <id>http://example.com/2021/11/30/js-37/</id>
    <published>2021-11-30T15:29:32.000Z</published>
    <updated>2021-12-01T05:10:29.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selectors-API"><a href="#Selectors-API" class="headerlink" title="Selectors API"></a>Selectors API</h1><ul><li>Selectors API(参见W3C网站上的Selectors APl Level 1)是W3C推荐标准，规定了浏览器原生支持的CSS查询API。</li><li><strong>支持这一特性的所有JavaScript库都会实现一个基本的CSS解析器，然后使用已有的DOM方法搜索文档并匹配目标节点。</strong></li><li>Selectors APILevel1的核心是两个方法：<strong>queryselector()和 querySelectorAll()<strong>。在兼容浏览器中，</strong>Document类型和Element类型的实例上都会暴露这两个方法</strong>。</li><li>Selectors API Level 2规范在Element类型上新增了更多方法，比如 matches ()、find()和findAll()。不过，目前还没有浏览器实现或宣称实现find()和findAll()。</li></ul><h2 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h2><ul><li>方法接收CSS选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&quot;body&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#myDiv&quot;</span>);</span><br><span class="line"><span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">&quot;img.button&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li>在Document上使用querySelector()方法时，会从文档元素开始搜索;在Element 上使用querySelector()方法时，则只会从当前元素的后代中查询。</li><li>如果选择符有语法错误或碰到不支持的选择符，则querySelector( )方法会抛出错误。</li></ul><h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h2><ul><li>querySelectorAll()方法跟querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个NodeList的静态实例。</li><li>querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一个<strong>静态的“快照”，而非“实时”的查询</strong>。这样的底层实现避免了使用NodeList对象可能造成的性能问题。<ul><li>返回的NodeList对象可以通过for-of循环、item()方法或中括号语法取得个别元素。</li><li><strong>如果没有匹配项，则返回空的NodeList实例</strong>。</li></ul></li><li>querySelectorAll()也可以在Document、DocumentFragment和Element类型上使用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).querySelectorAll(<span class="string">&quot;em&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line"><span class="comment">//=======================</span></span><br><span class="line"><span class="keyword">let</span> strongElements = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>); </span><br><span class="line"><span class="comment">// 以下 3 个循环的效果一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> strong <span class="keyword">of</span> strongElements) &#123; </span><br><span class="line">    strong.className = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.length; ++i) &#123; </span><br><span class="line">    strongElements.item(i).className = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.length; ++i) &#123; </span><br><span class="line">    strongElements[i].className = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="matches"><a href="#matches" class="headerlink" title="matches()"></a>matches()</h2><ul><li>matches()方法(在规范草案中称为matchesSelector())接收一个CSS选择符参数，如果元素匹配则该选择符返回true，否则返回false。</li><li>使用这个方法可以方便地检测某个元素会不会被querySelector()或 querySelectorAll()方法返回。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.matches(<span class="string">&quot;body.page1&quot;</span>))&#123; </span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h1><ul><li><p>IE9之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了childNodes和firstchild等属性上的差异。为了弥补这个差异，同时不影响DOM规范，W3C通过新的ElementTraversal规范定义了一组新属性。</p></li><li><p>Element Traversal API 为 DOM 元素添加了 5 个属性：</p><ul><li>childElementCount：返回子元素数量(不包含文本节点和注释)；</li><li>firstElementChild：指向第一个Element类型的子元素(Element版firstChild)；</li><li>lastElementChild：指向最后一个 Element类型的子元素(Element版lastchild)；</li><li>previousElementSibling：指向前一个Element类型的同胞元素（Element版previoussibling)；</li><li>nextElementsibling：指向后一个Element类型的同胞元素(Element 版nextsibling )。</li></ul></li><li><p>以下是跨浏览器方式遍历特定元素的所有子元素的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildNode = parentElement.firstChild; </span><br><span class="line"><span class="comment">// 没有子元素，firstChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildNode) &#123; </span><br><span class="line">    <span class="keyword">if</span> (currentChildNode.nodeType === <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果有元素节点，则做相应处理</span></span><br><span class="line">        processChild(currentChildNode); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (currentChildNode === parentElement.lastChild) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    currentChildNode = currentChildNode.nextSibling; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>使用Element Traversal属性之后,以上代码可以简化如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildElement = parentElement.firstElementChild;</span><br><span class="line"><span class="comment">// 没有子元素，firstElementChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildElement) &#123; </span><br><span class="line">    <span class="comment">// 这就是元素节点，做相应处理</span></span><br><span class="line">    processChild(currentChildElement); </span><br><span class="line">    <span class="keyword">if</span> (currentChildElement === parentElement.      lastElementChild) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    currentChildElement = currentChildElement.nextElementSibling; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Selectors-API&quot;&gt;&lt;a href=&quot;#Selectors-API&quot; class=&quot;headerlink&quot; title=&quot;Selectors API&quot;&gt;&lt;/a&gt;Selectors API&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Selectors API(参见W3C网</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    <category term="Selectors API" scheme="http://example.com/categories/Selectors-API/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十六）DOM（三）</title>
    <link href="http://example.com/2021/11/29/js-36/"/>
    <id>http://example.com/2021/11/29/js-36/</id>
    <published>2021-11-29T06:21:38.000Z</published>
    <updated>2021-11-30T15:03:51.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MutationObserver接口"><a href="#MutationObserver接口" class="headerlink" title="MutationObserver接口"></a>MutationObserver接口</h1><ul><li><strong>MutationObserver接口，可以在DOM被修改时异步执行回调。</strong></li><li>Mutati onObserver可以观察整个文档、DOM树的一部分， 或某个元素。此外还可以观察元素属性、子节点、文本，或者前ʻ者任意组合的变化。</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>MutationObserver的实例要通过调用MutationObserver构造函数并传人一个回调函数来创建。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;DOM was mutated!&#x27;</span>)); </span><br></pre></td></tr></table></figure></li></ul><h3 id="1、observe方法"><a href="#1、observe方法" class="headerlink" title="1、observe方法"></a>1、observe方法</h3><ul><li>新创建的MutationObserver实例不会关联DOM的任何部分。要把这个observer与DOM关联起来，需要使用observe()方法。</li><li>方法接收两个必需的参数：要观察其变化的DOM节点和一个MutationObserverInit对象。<ul><li>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行以上代码后，&lt;body&gt;元素上任何属性发生变化都会被这个MutationObserver实例发现，然后就会异步执行注册的回调函数。&lt;body&gt;元素后代的修改或其他非属性修改都不会触发回调进入任务队列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//通过以下代码来验证</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Changed body class&#x27;</span>); </span><br><span class="line"><span class="comment">// Changed body class </span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、回调与MutationRecord"><a href="#2、回调与MutationRecord" class="headerlink" title="2、回调与MutationRecord"></a>2、回调与MutationRecord</h3><ul><li>每个回调都会收到一个MutationRecord实例的数组。</li><li>MutationRecord实例包含的信息包括发生了什么变化，以及DOM的哪一部分受到了影响。</li><li>因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反映一个属性变化的 MutationRecord 实例的数组</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList [], </span></span><br><span class="line">        <span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: null </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList [], </span></span><br><span class="line">        <span class="comment">// target: body </span></span><br><span class="line">        <span class="comment">// type: &quot;attributes&quot; </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次涉及命名ቆ间的类似变化</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.setAttributeNS(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList [], </span></span><br><span class="line">        <span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: &quot;baz&quot;, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: null </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList [], </span></span><br><span class="line">        <span class="comment">// target: body </span></span><br><span class="line">        <span class="comment">// type: &quot;attributes&quot; </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">连续修改会生成多个Mutati onRecord实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure><ul><li>MutationRecord实例的属性：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/11/29/js-36/pic1.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/11/29/js-36/pic2.png" class title="# tu1"><ul><li>传给回调函数的第二个参数是观察变化的 MutationObserver 的实例。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords, mutationObserver</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords,</span><br><span class="line">mutationObserver)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver </span></span><br></pre></td></tr></table></figure><h3 id="3、disconnect-方法"><a href="#3、disconnect-方法" class="headerlink" title="3、disconnect()方法"></a>3、disconnect()方法</h3><ul><li>默认情况下，只要被观察的元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，从而被执行。</li><li>disconnect()方法可以用来提前终止执行回调。<ul><li>不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.disconnect(); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">//（没有日志输出）</span></span><br></pre></td></tr></table></figure><ul><li>要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用disconnect()。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    observer.disconnect(); </span><br><span class="line">    <span class="built_in">document</span>.body.className = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure><h3 id="4、复用MutationObserver"><a href="#4、复用MutationObserver" class="headerlink" title="4、复用MutationObserver"></a>4、复用MutationObserver</h3><ul><li>多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。</li><li>MutationRecord 的 target 属性可以标识发生变化事件的目标节点。</li><li>disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">x.target))); </span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> childB = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childA); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childB); </span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.observe(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.observe(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">childB.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;span&gt;] </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">x.target))); </span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> childB = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childA); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childB); </span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.observe(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.observe(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.disconnect(); </span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">childB.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// （没有日志输出）</span></span><br></pre></td></tr></table></figure><h3 id="5、重用MutationObserver"><a href="#5、重用MutationObserver" class="headerlink" title="5、重用MutationObserver"></a>5、重用MutationObserver</h3><ul><li>调用disconnect()并不会结束MutationObserver的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。</li><li>下面的示例在两个连续的异步块中先断开然后又恢复了观察者与<code>&lt;body&gt;</code>元素的关联：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes </span></span><br><span class="line"><span class="string">changed&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    observer.disconnect(); </span><br><span class="line">    <span class="comment">// 这行代码不会触发变化事件</span></span><br><span class="line">    <span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// Reattach </span></span><br><span class="line">    observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">    <span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line">    <span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed </span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="MutationObserverInit与观察范围"><a href="#MutationObserverInit与观察范围" class="headerlink" title="MutationObserverInit与观察范围"></a>MutationObserverInit与观察范围</h2><ul><li>MutationObserverInit 对象用于控制对目标节点的观察范围。</li><li>粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</li><li>下表列出了 MutationObserverInit 对象的属性：<img lazyload src="/images/loading.svg" data-src="/2021/11/29/js-36/pic3.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/11/29/js-36/pic4.png" class title="# tu1"></li><li>在调用observe()时，MutationObserverInit 对象中的attribute、characterData和childList属性<strong>必须至少有一项为true</strong>（无论是直接设置这几个属性，还是通过设置attributeOldvalue等属性间接导致它们的值转换为true）。否则会抛出错误，因为没有任何变化事件可能触发回调。</li></ul><h3 id="1、观察属性"><a href="#1、观察属性" class="headerlink" title="1、观察属性"></a>1、观察属性</h3><ul><li>MutationObserver可以观察节点属性的添加、移除和修改。</li><li>要为属性变化注册回调，需要在MutationObserverInit对象中将attributes属性设置为true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 添加属性 </span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="comment">// 移除属性</span></span><br><span class="line"><span class="built_in">document</span>.body.removeAttribute(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/11/29/js-36/pic5.png" class title="# tu1"><ul><li>把attributes设置为true的默认行为是观察所有属性，但不会在MutationRecord对象中记录原来的属性值。</li><li>如果想观察某个或某几个属性，可以使用attributeFilter属性来设置白名单，即一个属性名字符串数组；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;foo&#x27;</span>] &#125;); </span><br><span class="line"><span class="comment">// 添加白名单属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加被排除的属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="comment">// 只有 foo 属性的变化被记录了</span></span><br><span class="line"><span class="comment">// [MutationRecord] </span></span><br></pre></td></tr></table></figure><ul><li>如果想在变化记录中保存属性原来的值，可以将attributeOldValue属性设置为true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.oldValue))); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributeOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [null, &#x27;bar&#x27;, &#x27;baz&#x27;] </span></span><br></pre></td></tr></table></figure><h3 id="2、观察字符数据"><a href="#2、观察字符数据" class="headerlink" title="2、观察字符数据"></a>2、观察字符数据</h3><ul><li>MutationObserver 可以观察文本节点(如 Text、 Comment或ProcessingInstruction节点)中字符的添加、删除和修改。</li><li>要为字符数据注册回调，需要在MutationObserverInit对象中将characterData 属性设置为true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建要观察的文本节点</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body.firstChild, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 赋值为相同的字符串</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// 赋值为新字符串</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">// 通过节点设置函数赋值</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br></pre></td></tr></table></figure></li><li>将characterData属性设置为true的默认行为不会在MutationRecord对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据,可以将characterData0ldValue属性设置为true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.oldValue))); </span><br><span class="line"><span class="built_in">document</span>.body.innerText = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body.firstChild, &#123; <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.innerText = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.innerText = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;] </span></span><br></pre></td></tr></table></figure><h3 id="3、观察子节点"><a href="#3、观察子节点" class="headerlink" title="3、观察子节点"></a>3、观察子节点</h3><ul><li>MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在Mutation-ObserverInit对象中将childList属性设置为true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、下面的例子演示了添加子节点：</span></span><br><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList[div], </span></span><br><span class="line">        <span class="comment">// attributeName: null, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: null, </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// target: body, </span></span><br><span class="line">        <span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、下面的例子演示了移除子节点：</span></span><br><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// attributeName: null, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: null, </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList[div], </span></span><br><span class="line">        <span class="comment">// target: body, </span></span><br><span class="line">        <span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure></li><li>对子节点重新排序（尽管调用一个方法即可实现)会报告两次变化事件,因为从技术上会涉及先移除和再添加。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( </span><br><span class="line"> (mutationRecords) =&gt; <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建两个初始子节点</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 交换子节点顺序</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(<span class="built_in">document</span>.body.lastChild, <span class="built_in">document</span>.body.firstChild); </span><br><span class="line"><span class="comment">// 发生了两次变化：第一次是节点被移除，第二次是节点被添加</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// attributeName: null, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: div, </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList[span], </span></span><br><span class="line">        <span class="comment">// target: body, </span></span><br><span class="line">        <span class="comment">// type: childList, </span></span><br><span class="line">    <span class="comment">// &#125;, </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList[span], </span></span><br><span class="line">        <span class="comment">// attributeName: null, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: div, </span></span><br><span class="line">        <span class="comment">// previousSibling: null, </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// target: body, </span></span><br><span class="line">        <span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="4、观察子树"><a href="#4、观察子树" class="headerlink" title="4、观察子树"></a>4、观察子树</h3><ul><li>默认情况下，MutationObserver 将观察的范围限定为一个元素及其子节点的变化。</li><li>可以把观察的范围扩展到这个元素的子树(所有后代节点),这需要在MutationObserverInit对象中将subtree属性设置为true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建一个后代</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="comment">// 观察&lt;body&gt;元素及其子树</span></span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 修改&lt;body&gt;元素的子树</span></span><br><span class="line"><span class="built_in">document</span>.body.firstChild.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 记录了子树变化的事件</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">        <span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line">        <span class="comment">// attributeNamespace: null, </span></span><br><span class="line">        <span class="comment">// oldValue: null, </span></span><br><span class="line">        <span class="comment">// nextSibling: null, </span></span><br><span class="line">        <span class="comment">// previousSibling: null, </span></span><br><span class="line">        <span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line">        <span class="comment">// target: div, </span></span><br><span class="line">        <span class="comment">// type: &quot;attributes&quot;, </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><ul><li>被观察子树中的节点被移出子树之后仍然能够触发变化事件。</li><li>在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line"><span class="keyword">let</span> subtreeRoot = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> subtreeLeaf = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="comment">// 创建包含两层的子树</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(subtreeRoot); </span><br><span class="line">subtreeRoot.appendChild(subtreeLeaf); </span><br><span class="line"><span class="comment">// 观察子树</span></span><br><span class="line">observer.observe(subtreeRoot, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 把节点转移到其他子树</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(subtreeLeaf, subtreeRoot); </span><br><span class="line">subtreeLeaf.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 移出的节点仍然触发变化事件</span></span><br><span class="line"><span class="comment">// [MutationRecord] </span></span><br></pre></td></tr></table></figure><h2 id="异步回调与记录队列"><a href="#异步回调与记录队列" class="headerlink" title="异步回调与记录队列"></a>异步回调与记录队列</h2><ul><li>MutationObserver接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。</li><li>为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在MutationRecord实例中，然后添加到记录队列。</li><li>这个队列对每个MutationObserver实例都是唯一的，是所有 DOM变化事件的有序列表。</li></ul><h3 id="1、记录队列"><a href="#1、记录队列" class="headerlink" title="1、记录队列"></a>1、记录队列</h3><ul><li>每次MutationRecord被添加到MutationObserver的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为0），才会将观察者注册的回调（在初始化Mutation0bserver时传入）作为微任务调度到任务队列上。</li><li>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些MutationRecord就用不着了，因此记录队列会被清空，其内容会被丢弃。</li></ul><h3 id="2、takeRecords-方法"><a href="#2、takeRecords-方法" class="headerlink" title="2、takeRecords()方法"></a>2、takeRecords()方法</h3><ul><li>调用MutationObserver实例的takeRecords()方法可以清空记录队列，取出并返回其中的所有MutationRecord实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver( <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords)); </span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.className = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(observer.takeRecords()); </span><br><span class="line"><span class="built_in">console</span>.log(observer.takeRecords()); </span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="性能、内存与垃圾回收"><a href="#性能、内存与垃圾回收" class="headerlink" title="性能、内存与垃圾回收"></a>性能、内存与垃圾回收</h2><ul><li>DOM Level 2规范中描述的MutationEvent定义了一组会在各种DOM变化时触发的事件。</li><li>由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3规定废弃了这些事件。Mutationobserver接口就是为替代这些事件而设计的更实用、性能更好的方案。</li><li><strong>将变化回调委托给微任务来执行可以保证事件同步触发,同时避免随之而来的混乱。</strong></li><li>为MutationObserver而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。无论如何，使用Mutationobserver仍然不是没有代价的。</li></ul><h3 id="1、MutationObserver的引用"><a href="#1、MutationObserver的引用" class="headerlink" title="1、MutationObserver的引用"></a>1、MutationObserver的引用</h3><ul><li><strong>Mutationobserver实例与目标节点之间的引用关系是非对称的。</strong></li><li><strong>MutationObserver拥有对要观察的目标节点的弱引用。</strong>因为是弱引用,所以不会妨碍垃圾回收程序回收目标节点。</li><li><strong>目标节点拥有对 Mutationobserver 的强引用。</strong>如果目标节点从 DOM中被移除，随后被垃圾回收,则关联的MutationObserver也会被垃圾回收。</li></ul><h3 id="2、MutationRecord的引用"><a href="#2、MutationRecord的引用" class="headerlink" title="2、MutationRecord的引用"></a>2、MutationRecord的引用</h3><ul><li>记录队列中的每个MutationRecord 实例至少包含对已有 DOM节点的一个引用。</li><li>如果变化是childList类型，则会包含多个节点的引用。</li><li>记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecora，然后让它们超出作用域并被垃圾回收。</li><li>有时候可能需要保存某个观察者的完整变化记录。保存这些MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。</li><li>如果需要尽快地释放内存，建议从每个MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃MutationRecord。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MutationObserver接口&quot;&gt;&lt;a href=&quot;#MutationObserver接口&quot; class=&quot;headerlink&quot; title=&quot;MutationObserver接口&quot;&gt;&lt;/a&gt;MutationObserver接口&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十五）DOM（二）</title>
    <link href="http://example.com/2021/11/28/js-35/"/>
    <id>http://example.com/2021/11/28/js-35/</id>
    <published>2021-11-28T07:42:24.000Z</published>
    <updated>2021-11-29T05:58:45.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><ul><li><code>&lt;script&gt;</code>元素用于向网页中插人JavaScript代码,可以是src属性包含的外部文件，也可以是作为该元素内容的源代码。</li><li>有两种方式通过<code>&lt;script&gt;</code>动态为网页添加脚本:引人外部文件和直接插人源代码。</li><li>动态脚本就是在页面初始加载时不存在，之后又通过DOM包含的脚本。</li><li>可以通过DOM编程创建这个节点:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.src = <span class="string">&quot;foo.js&quot;</span>; </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script); </span><br></pre></td></tr></table></figure><ul><li>抽象出一个跨浏览器的函数:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">    script.type = <span class="string">&quot;text/javascript&quot;</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code)); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line">        script.text = code; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数可以这样调用：</span></span><br><span class="line">loadScriptString(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><ul><li>CSS样式在HTML页面中可以通过两个元素加载：<code>&lt;link&gt;</code>和<code>&lt;style&gt;</code><ul><li><code>&lt;link&gt;</code>：用于包含CSS外部文件；</li><li><code>&lt;style&gt;</code>：用于添加嵌入样式。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 DOM 编程创建出来</span></span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>); </span><br><span class="line">link.rel = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line">link.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">link.href = <span class="string">&quot;styles.css&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.appendChild(link); </span><br></pre></td></tr></table></figure><ul><li><p>应该把<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>元素而不是<code>&lt;body&gt;</code>元素，这样才能保证所有浏览器都能正常运行。</p></li><li><p>这个过程可以抽象为以下通用函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>); </span><br><span class="line">    link.rel = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line">    link.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">    link.href = url; </span><br><span class="line">    <span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">    head.appendChild(link); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样调用这个 loadStyles()函数了：</span></span><br><span class="line">loadStyles(<span class="string">&quot;styles.css&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后顺序。</p></li><li><p>另一种定义样式的方式是使用<code>&lt;script&gt;</code>元素包含嵌入的 CSS 规则</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span> </span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123; </span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>); </span><br><span class="line">style.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>)); </span><br><span class="line"><span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.appendChild(style); </span><br></pre></td></tr></table></figure></li></ul><h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><ul><li>表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.createElement(<span class="string">&quot;table&quot;</span>); </span><br><span class="line">table.border = <span class="number">1</span>; </span><br><span class="line">table.width = <span class="string">&quot;100%&quot;</span>; </span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">&quot;tbody&quot;</span>); </span><br><span class="line">table.appendChild(tbody); </span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.appendChild(row1); </span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,1&quot;</span>)); </span><br><span class="line">row1.appendChild(cell1_1); </span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,1&quot;</span>)); </span><br><span class="line">row1.appendChild(cell2_1); </span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="built_in">document</span>.createElement(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.appendChild(row2); </span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="built_in">document</span>.createElement(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,2&quot;</span>)); </span><br><span class="line">row2.appendChild(cell1_2); </span><br><span class="line"><span class="keyword">let</span> cell2_2= <span class="built_in">document</span>.createElement(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,2&quot;</span>)); </span><br><span class="line">row2.appendChild(cell2_2); </span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table); </span><br></pre></td></tr></table></figure><ul><li>为了方便创建表格，HTML DOM给```<table>、<tbody>和<tr>``元素添加了一些属性和方法。</tr></tbody></table></li><li><code>&lt;table&gt;</code>元素添加了以下属性和方法:<img lazyload src="/images/loading.svg" data-src="/2021/11/28/js-35/pic1.png" class title="# tu1"></li><li><code>&lt;tbody&gt;</code>元素添加了以下属性和方法:<img lazyload src="/images/loading.svg" data-src="/2021/11/28/js-35/pic2.png" class title="# tu1"></li><li><code>&lt;tr&gt;</code>元素添加了以下属性和方法:<img lazyload src="/images/loading.svg" data-src="/2021/11/28/js-35/pic3.png" class title="# tu1"></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.createElement(<span class="string">&quot;table&quot;</span>); </span><br><span class="line">table.border = <span class="number">1</span>; </span><br><span class="line">table.width = <span class="string">&quot;100%&quot;</span>; </span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">&quot;tbody&quot;</span>); </span><br><span class="line">table.appendChild(tbody); </span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.insertRow(<span class="number">0</span>); </span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>); </span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,1&quot;</span>)); </span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>); </span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,1&quot;</span>)); </span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.insertRow(<span class="number">1</span>); </span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>); </span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,2&quot;</span>)); </span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>); </span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,2&quot;</span>)); </span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table); </span><br></pre></td></tr></table></figure><h2 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h2><ul><li>DOM编程的关键是：理解NodeList对象和相关的NameNodeMap、HTMLCollection。</li><li>以上三个集合类型是“实时的”，意味着文档结构的变化会实时地在他们身上反映出来，它们的值始终代表最新的状态。</li><li><strong>NodeList是基于DOM文档的实时查询</strong>。</li><li>任何时候需要迭代NodeList，最好初始化一个变量保存当时查询时的长度，然后使用循环变量与这个变量进行比较。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = divs.length; i &lt; len; ++i) &#123; </span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DOM编程&quot;&gt;&lt;a href=&quot;#DOM编程&quot; class=&quot;headerlink&quot; title=&quot;DOM编程&quot;&gt;&lt;/a&gt;DOM编程&lt;/h1&gt;&lt;h2 id=&quot;动态脚本&quot;&gt;&lt;a href=&quot;#动态脚本&quot; class=&quot;headerlink&quot; title=&quot;动态脚本&quot;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（DocumentFragment类型和Attr类型）</title>
    <link href="http://example.com/2021/11/28/js-34-7/"/>
    <id>http://example.com/2021/11/28/js-34-7/</id>
    <published>2021-11-28T06:59:46.000Z</published>
    <updated>2021-11-28T07:39:13.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h1><ul><li><strong>在所有节点类型中，DocumentFragment类型是唯一一个在标记中没有对应表示的类型</strong>。</li><li>DOM将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。</li><li>DocumentFragment节点具有以下特征:<ul><li>nodeType等于11；</li><li>nodeName值为”#document- fragment”；</li><li>nodeValue值为null；</li><li>parentNode值为null；</li><li>子节点可以是Element、 Process ingInstruction、Comment、 Text、CDATASection或EntityRe ference。</li></ul></li><li><strong>文档片段的作用是充当其他要被添加到文档的节点的仓库。</strong></li><li>可以使用document.createDocumentFragment()方法创建文档片段。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure></li><li>文档片段从Node类型继承了所有文档类型具备的可以执行DOM操作的方法。</li><li><strong>如果文档中的一个节点被添加到一一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。</strong></li><li>可以通过appendChild()或insertBefore()方法将文档片段的内容添加到文档。</li><li>在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。</li><li>文档片段本身永远不会被添加到文档树。</li></ul><h1 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h1><ul><li><strong>元素数据在DOM中通过Attr类型表示</strong>。</li><li><strong>Attr类型构造函数和原型在所有浏览器中都可以直接访问</strong>。</li><li>技术上讲，属性是存在于元素attributes属性中的节点。</li><li>Attr 节点具有以下特点：<ul><li>nodeType等于2;</li><li>nodeName值为属性名;</li><li>nodeValue值为属性值;</li><li>parentNode值为null;</li><li>在HTML中不支持子节点;</li><li>在XML中子节点可以是Text或Ent ityReference。</li></ul></li><li><strong>属性节点尽管是节点，却不被认为是DOM文档树的一部分。</strong></li><li>Attr节点很少直接被引用，通常更喜欢使用getAttribute()、removeAttribute()和 setAttribute()方法操作属性。</li><li><strong>Attr对象上有3个属性: name、value和specified。</strong>其中，name包含属性名（与nodeName一样）value包含属性值(与nodeValue一样),而specified是一个布尔值，表示属性使用的是默认值还是被指定的值。</li><li>可以使用document.createAttribute()方法创建新的Attr节点，参数为属性名。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">&quot;align&quot;</span>); </span><br><span class="line">attr.value = <span class="string">&quot;left&quot;</span>; </span><br><span class="line">element.setAttributeNode(attr); </span><br><span class="line">alert(element.attributes[<span class="string">&quot;align&quot;</span>].value); <span class="comment">// &quot;left&quot; </span></span><br><span class="line">alert(element.getAttributeNode(<span class="string">&quot;align&quot;</span>).value); <span class="comment">// &quot;left&quot; </span></span><br><span class="line">alert(element.getAttribute(<span class="string">&quot;align&quot;</span>)); <span class="comment">// &quot;left&quot; </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这个例子中，首先创建了一个新属性。调用createAttribute()并传人&quot;align&quot;为新属性设置了name属性，因此就不用再设置了。随后，value属性被赋值为&quot;left&quot;。为把这个新属性添加到元素上，可以使用元素的setAttri buteNode()方法。添加这个属性后，可以通过不同方式访问它，包括attributes属性、getAttr ibuteNode ()和getAttribute()方法。其中，attributes 属性和getAttri buteNode ()方法都返回属性对应的Attr节点，而getAttribute()方法只返回属性的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DocumentFragment类型&quot;&gt;&lt;a href=&quot;#DocumentFragment类型&quot; class=&quot;headerlink&quot; title=&quot;DocumentFragment类型&quot;&gt;&lt;/a&gt;DocumentFragment类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（CDATASection类型和DocumentType类型）</title>
    <link href="http://example.com/2021/11/27/js-34-6/"/>
    <id>http://example.com/2021/11/27/js-34-6/</id>
    <published>2021-11-27T08:10:32.000Z</published>
    <updated>2021-11-28T06:58:34.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h1><ul><li><p>CDATASection类型<strong>表示XML中特有的CDATA区块</strong>。</p></li><li><p>CDATASection类型继承Text类型，因此拥有包括splitText ()在内的所有字符串操作方法。</p></li><li><p>CDATASection类型的节点具有以下特征:</p><ul><li>nodeType等于4；</li><li>nodeName值为”#cdata-section”；</li><li>nodeValue值为CDATA区块的内容；</li><li>parentNode值为Document或Element对象；</li><li>不支持子节点。</li></ul></li><li><p>CDATA区块只在XML文档中有效，因此某些浏览器比较陈旧的版本会错误地将CDATA区块解析为Comment或Element。</p></li><li><p>在真正的XML文档中，可以使用document.createCDataSection()并传入节点内容来创建：CDATA区块。</p></li></ul><h1 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h1><ul><li>DocumentType类型的节点<strong>包含文档的文档类型(doctype)信息</strong>，具有以下特征：<ul><li>nodeType等于10；</li><li>nodeName 值为文档类型的名称；</li><li>nodeValue值为null；</li><li>parentNode值为Document对象；</li><li>不支持子节点。</li></ul></li><li>DocumentType对象在DOM Level 1中不支持动态创建，只能在解析文档代码时创建。</li><li>对于支持这个类型的浏览器，DocumentType 对象保存在document.doctype属性中。</li><li>DOM Level 1规定了DocumentType对象的3个属性: <strong>name、entities 和notations</strong>：<ul><li>name：文档类型的名称；</li><li>entities：这个文档类型描述的实体的NamedNodeMap；* notations：这个文档类型描述的表示法的NamedNodeMap。</li></ul></li><li><strong>因为浏览器中的文档通常是HTML或XHTML文档类型，所以entities和notations列表为空</strong>。( 这个对象只包含行内声明的文档类型。)无论如何，<strong>只有name属性是有用的</strong>。</li><li>这个属性包含文档类型的名称，即紧跟在&lt;!DOCTYPE后面的那串文本。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-// W3C// DTD HTML 4.01// EN&quot;</span> </span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http:// www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于这个文档类型，name 属性的值是&quot;html&quot;：</span></span><br><span class="line">alert(<span class="built_in">document</span>.doctype.name); <span class="comment">// &quot;html&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CDATASection类型&quot;&gt;&lt;a href=&quot;#CDATASection类型&quot; class=&quot;headerlink&quot; title=&quot;CDATASection类型&quot;&gt;&lt;/a&gt;CDATASection类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CDATASection类</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（Comment类型）</title>
    <link href="http://example.com/2021/11/27/js-34-5/"/>
    <id>http://example.com/2021/11/27/js-34-5/</id>
    <published>2021-11-27T07:53:13.000Z</published>
    <updated>2021-11-27T08:09:51.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h1><ul><li>DOM中的注释通过Comment类型表示。</li><li>Comment类型的节点具有以下特征:<ul><li>nodeType等于8；</li><li>nodeName值为”#comment “；</li><li>nodeValue值为注释的内容；</li><li>parentNode值为Document或Element对象;</li><li>不支持子节点。</li></ul></li><li>Comment类型与Text类型继承同一个基类( CharacterData )<br>因此拥有除splitText ()之外Text节点所有的字符串操作方法。</li><li>与Text类型相似，注释的实际内容可以通过nodeValue或data属性获得。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释节点可以作为父节点的子节点来访问。比如下面的HTML代码:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="comment">&lt;!-- A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以像下面这样访问它</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> comment = div.firstChild; </span><br><span class="line">alert(comment.data); <span class="comment">// &quot;A comment&quot;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用document.createComment()方法创建注释节点，参数为注释文本。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Comment类型&quot;&gt;&lt;a href=&quot;#Comment类型&quot; class=&quot;headerlink&quot; title=&quot;Comment类型&quot;&gt;&lt;/a&gt;Comment类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DOM中的注释通过Comment类型表示。&lt;/li&gt;
&lt;li&gt;Comme</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（Text类型）</title>
    <link href="http://example.com/2021/11/25/js-34-4/"/>
    <id>http://example.com/2021/11/25/js-34-4/</id>
    <published>2021-11-25T15:14:56.000Z</published>
    <updated>2021-11-27T07:48:18.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h1><ul><li>Text节点<strong>由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML字符，但不含HTML代码</strong>。</li><li>Text类型的节点具有以下特征：<ul><li>nodeType等于3；</li><li>nodeName值为”#text “；</li><li>nodevalue值为节点中包含的文本；</li><li>parentNode值为Element对象；</li><li>不支持子节点。</li></ul></li><li>Text节点中包含的文本可以<strong>通过nodevalue属性</strong>访问，也可以通过data属性访问，这两个属性包含相同的值。</li><li>修改nodevalue或data的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法:<ul><li>appendData(text)，向节点末尾添加文本text；</li><li>deleteData(offset，count)，从位置offset开始删除count个字符；</li><li>insertData(offset，text)，在位置offset插人text；</li><li>replaceData(offset，count，text)，用text替换从位置offset到offset+count的文本；</li><li>splitText ( offset)，在位置offset将当前文本节点拆分为两个文本节点;</li><li>substringData(offset，count)，提取从位置offset到offset+count的文本。</li></ul></li><li>通过length属性获取文本节点中包含的字符数量。这个值等于nodeValue.length和data.length。</li><li>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有内容，因此没有文本节点 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 有空格，因此有一个文本节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 有内容，因此有一个文本节点 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列代码可以用来访问这个文本节点，同时修改它：</span></span><br><span class="line"><span class="keyword">let</span> textNode = div.firstChild; <span class="comment">// 或 div.childNodes[0] </span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">&quot;Some other message&quot;</span>; </span><br><span class="line"><span class="comment">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot; </span></span><br></pre></td></tr></table></figure><h2 id="1、创建文本节点"><a href="#1、创建文本节点" class="headerlink" title="1、创建文本节点"></a>1、创建文本节点</h2><ul><li>document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。</li><li>跟设置已有文本节点的值一样，这些要插入的文本也会应用HTML或XML编码。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>创建新文本节点后，其ownerDocument 属性会被设置为document。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以下代码创建了一个&lt;div&gt;元素并给它添加了一段文本消息：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.className = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.appendChild(textNode); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个例子首先创建了一个&lt;div&gt;元素并给它添加了值为&quot;message&quot;的class属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.className = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.appendChild(textNode); </span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Yippee!&quot;</span>); </span><br><span class="line">element.appendChild(anotherTextNode); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure><ul><li>在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</li></ul><h2 id="2、规范化文本节点"><a href="#2、规范化文本节点" class="headerlink" title="2、规范化文本节点"></a>2、规范化文本节点</h2><ul><li>DOM文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM文档中也经常会出现两个相邻文本节点。</li><li>normalize()方法可以合并相邻的文本节点。<ul><li>该方法是在Node类型中定义的。</li><li>在<strong>包含两个或多个相邻文本节点的父节点</strong>上调用normalize()时，<strong>所有同胞文本节点会被合并为一个文本节点</strong>，这个<strong>文本节点的nodevalue就等于之前所有同胞节点nodevalue拼接在一起得到的字符串</strong>。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.className = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.appendChild(textNode); </span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Yippee!&quot;</span>); </span><br><span class="line">element.appendChild(anotherTextNode); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element); </span><br><span class="line">alert(element.childNodes.length); <span class="comment">// 2 </span></span><br><span class="line">element.normalize(); </span><br><span class="line">alert(element.childNodes.length); <span class="comment">// 1 </span></span><br><span class="line">alert(element.firstChild.nodeValue); <span class="comment">// &quot;Hello world!Yippee!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、拆分文本节点"><a href="#3、拆分文本节点" class="headerlink" title="3、拆分文本节点"></a>3、拆分文本节点</h2><ul><li>splitText()：方法可以在指定的偏移位置拆分nodevalue，将一个文本节点拆分成两个文本节点。<ul><li>拆分之后，原来的文本节点包含<strong>开头到偏移位置前</strong>的文本，新文本节点包含<strong>剩下的文本</strong>。</li><li>方法返回<strong>新的文本节点</strong>，具有与原来的文本节点相同的parentNode。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.className = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.appendChild(textNode); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element); </span><br><span class="line"><span class="keyword">let</span> newNode = element.firstChild.splitText(<span class="number">5</span>); </span><br><span class="line">alert(element.firstChild.nodeValue); <span class="comment">// &quot;Hello&quot; </span></span><br><span class="line">alert(newNode.nodeValue); <span class="comment">// &quot; world!&quot; </span></span><br><span class="line">alert(element.childNodes.length); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Text类型&quot;&gt;&lt;a href=&quot;#Text类型&quot; class=&quot;headerlink&quot; title=&quot;Text类型&quot;&gt;&lt;/a&gt;Text类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Text节点&lt;strong&gt;由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的 HT</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（Element类型）</title>
    <link href="http://example.com/2021/11/24/js-34-3/"/>
    <id>http://example.com/2021/11/24/js-34-3/</id>
    <published>2021-11-24T07:49:06.000Z</published>
    <updated>2021-11-25T15:28:52.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h1><ul><li><p>Element表示<strong>XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力</strong>。</p></li><li><p>Element类型的节点具有以下特征：</p><ul><li>nodeType等于1；</li><li>nodeName值为元素的标签名；</li><li>nodevalue值为null；</li><li>parentNode值为Document或Element对象；</li><li>子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference类型。</li></ul></li><li><p>可以通过nodeName或tagName属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">alert(div.tagName); <span class="comment">// &quot;DIV&quot; </span></span><br><span class="line">alert(div.tagName == div.nodeName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>在 HTML 中，元素标签名始终以全大写表示；</p></li><li><p>在 XML(包括XHTML) 中，标签名始终与源代码中的大小写一致。</p></li><li><p>如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 不要这样做，可能出错！</span></span><br><span class="line">    <span class="comment">// do something here </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 推荐，适用于所有文档</span></span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、HTML元素"><a href="#1、HTML元素" class="headerlink" title="1、HTML元素"></a>1、HTML元素</h2><ul><li><p>所有HTML元素都通过HTMLElement类型表示，包括其直接实例和间接实例。</p></li><li><p>HTMLElement直接继承Element并增加了一些属性。</p></li><li><p>每个属性都对应下列属性之一，它们是所有HTML元素上都有的标准属性：</p><ul><li>id：元素在文档中的唯一标识符；</li><li>title：包含元素的额外信息，通常以提示条形式展示；</li><li>lang：元素内容的语言代码(很少用)；</li><li>dir：语言的书写方向(“ltr”表示从左到右，”rtl”表示从右到左，同样很少用)；</li><li>className：相当于class属性，用于指定元素的CSS类(因为class是 ECMAScript关键字所以不能直接用这个名字)。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个元素中的所有属性都可以使用下列JavaScript代码读取</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">alert(div.id); <span class="comment">// &quot;myDiv&quot; </span></span><br><span class="line">alert(div.className); <span class="comment">// &quot;bd&quot; </span></span><br><span class="line">alert(div.title); <span class="comment">// &quot;Body text&quot; </span></span><br><span class="line">alert(div.lang); <span class="comment">// &quot;en&quot; </span></span><br><span class="line">alert(div.dir); <span class="comment">// &quot;ltr&quot; </span></span><br><span class="line"><span class="comment">//可以使用下列代码修改元素的属性:</span></span><br><span class="line">div.id = <span class="string">&quot;someOtherId&quot;</span>; </span><br><span class="line">div.className = <span class="string">&quot;ft&quot;</span>; </span><br><span class="line">div.title = <span class="string">&quot;Some other text&quot;</span>; </span><br><span class="line">div.lang = <span class="string">&quot;fr&quot;</span>; </span><br><span class="line">div.dir =<span class="string">&quot;rtl&quot;</span>; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>把id或lang改成其他值对用户是不可见的(假设没有基于这两个属性应用CSS样式)；</p></li><li><p>修改title属性则只会在鼠标移到这个元素上时才会反映出来；</p></li><li><p>修改dir会导致页面文本立即向左或向右对齐；</p></li><li><p>修改className 会立即反映应用到新类名的CSS样式（如果宗义了不同的样式)。</p></li></ul><h2 id="2、取得属性"><a href="#2、取得属性" class="headerlink" title="2、取得属性"></a>2、取得属性</h2><ul><li>与属性相关的DOM方法主要有3个：getAttribute()、setAttribute()和 removeAttribute()。</li><li>如果给定的属性不存在，则getAttribute()返回null。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot; </span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;class&quot;</span>)); <span class="comment">// &quot;bd&quot; </span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;title&quot;</span>)); <span class="comment">// &quot;Body text&quot; </span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;lang&quot;</span>)); <span class="comment">// &quot;en&quot; </span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;dir&quot;</span>)); <span class="comment">// &quot;ltr&quot; </span></span><br></pre></td></tr></table></figure><ul><li>getAttribute()方法也能取得不是HTML语言正式属性的自定义属性的值。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = div.getAttribute(<span class="string">&quot;my_special_attribute&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li>属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。</li><li>根据 HTML5 规范的要求，自定义属性名应该前缀data-以方便验证。</li><li>元素的所有属性也可以通过相应DOM元素对象的属性来取得。</li><li>通过 DOM对象访问的属性中有两个返回的值跟使用getAttribute()取得的值不一样：<ul><li>首先是style属性，这个属性用于为元素设定CSS样式。<strong>在使用getAttribute()访问style属性时，返回的是CSS字符串。而在通过DOM对象的属性访问时，style属性返回的是一个(cssstyleDeclaration)对象。</strong></li><li>第二个属性其实是一类，即事件处理程序（或者事件属性)，比如 onclick。<strong>如果使用getAttribute()访问事件属性，则返回的是字符串形式的源代码。而通过DOM对象的属性访问事件属性时返回的则是一个JavaScript函数（未指定该属性则返回null)。</strong></li></ul></li></ul><h2 id="3、设置属性"><a href="#3、设置属性" class="headerlink" title="3、设置属性"></a>3、设置属性</h2><ul><li><p>setAttribute()：</p><ul><li>方法接收两个参数：要设置的属性名和属性的值。</li><li>如果属性已经存在，则setAttribute()会以指定的值替换原来的值；如果不存在，则会创建该属性。</li><li>适用于HTML属性和自定义属性。</li><li>设置的属性名会规范为小写形式。</li></ul></li><li><p>因为元素属性也是DOM对象属性，所以直接给DOM对象的属性赋值也可以设置元素属性的值。</p></li><li><p>在DOM对象上添加自定义属性不会让它变成元素的属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&quot;id&quot;</span>， <span class="string">&quot;someOtherId&quot;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&quot;class&quot;</span>， <span class="string">&quot;ft&quot;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&quot;title&quot;</span>， <span class="string">&quot;Some other text&quot;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&quot;lang&quot;</span>，<span class="string">&quot;fr&quot;</span>); </span><br><span class="line">div.setAttribute(<span class="string">&quot;dir&quot;</span>， <span class="string">&quot;rtl&quot;</span>); </span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line">div.id = <span class="string">&quot;someOtherId&quot;</span>; </span><br><span class="line">div.align = <span class="string">&quot;left&quot;</span>;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line">div.mycolor = <span class="string">&quot;red&quot;</span>; </span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;mycolor&quot;</span>)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li><p>removeAttribute()用于从元素中完全删除对应属性。</p><ul><li>在序列化DOM元素时可以通过它控制要包含的属性。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.removeAttribute(<span class="string">&quot;class&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="4、attributes属性"><a href="#4、attributes属性" class="headerlink" title="4、attributes属性"></a>4、attributes属性</h2><ul><li><p>Element类型是唯一使用attributes属性的 DOM节点类型。</p></li><li><p><strong>attributes属性包含一个NamedNodeMap实例，是一个类似NodeList 的“实时”集合</strong>。</p></li><li><p>元素的每个属性都表示为一个Attr节点，并保存在这个NamedNodeMap对象中。</p></li><li><p>NamedNodeMap对象包含下列方法:</p><ul><li>getNamedItem(name)，返回nodeName属性等于name的节点;</li><li>removeNamedItem(name)，删除nodeName属性等于name 的节点;</li><li>setNamedItem(node)，向列表中添加node节点，以其nodeName为索引;</li><li>item(pos)，返回索引位置pos处的节点。</li></ul></li><li><p><strong>attributes属性中的每个节点的nodeName是对应属性的名字，nodeValue 是属性的值</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要取得元素 id 属性的值，可以使用以下代码：</span></span><br><span class="line"><span class="keyword">let</span> id = element.attributes.getNamedItem(<span class="string">&quot;id&quot;</span>).nodeValue;</span><br><span class="line"><span class="comment">// =============等价于=================</span></span><br><span class="line"><span class="keyword">let</span> id = element.attributes[<span class="string">&quot;id&quot;</span>].nodeValue; </span><br><span class="line"><span class="comment">// 设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，</span></span><br><span class="line">element.attributes[<span class="string">&quot;id&quot;</span>].nodeValue = <span class="string">&quot;someOtherId&quot;</span>; </span><br></pre></td></tr></table></figure></li><li><p>emoveNamedItem()方法与元素上的removeAttribute()方法类似，也是删除指定名字的属性。</p><ul><li>两个方法唯一的不同之处，就是removeNamedItem()返回表示被删除属性的Attr节点</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldAttr = element.attributes.removeNamedItem(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>attributes属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把DOM结构序列化为XML或HTML字符串。</li></ul><h2 id="5、创建元素"><a href="#5、创建元素" class="headerlink" title="5、创建元素"></a>5、创建元素</h2><ul><li>document.createElement()方法创建新元素。<ul><li>方法接收一个参数：需要创建元素的标签名。</li></ul></li><li>同时使用appendChild()、insertBefore()或 replaceChild()将元素添加到文档树中，浏览器就会立即将其渲染出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><h2 id="6、元素后代"><a href="#6、元素后代" class="headerlink" title="6、元素后代"></a>6、元素后代</h2><ul><li>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Element类型&quot;&gt;&lt;a href=&quot;#Element类型&quot; class=&quot;headerlink&quot; title=&quot;Element类型&quot;&gt;&lt;/a&gt;Element类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Element表示&lt;strong&gt;XML或HTML元素，对外暴露出</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（Document类型）</title>
    <link href="http://example.com/2021/11/24/js-34-2/"/>
    <id>http://example.com/2021/11/24/js-34-2/</id>
    <published>2021-11-24T07:43:36.000Z</published>
    <updated>2021-11-24T07:46:19.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h1><ul><li>Document类型是JavaScript中<strong>表示文档节点的类型</strong>。</li><li>在浏览器中，<strong>文档对象 document是HTMLDocument 的实例</strong>(HTMLDocument继承Document )，表示整个HTML页面。</li><li><strong>document是window对象的属性</strong>，因此是一个全局对象。</li><li>Document类型的节点有以下特征：<ul><li>nodeType等于9；</li><li>nodeName值为”#document”；</li><li>nodeValue值为null;</li><li>parentNode值为null；</li><li>ownerDocument值为null；</li><li>子节点可以是DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment类型。</li></ul></li><li>Document类型可以<strong>表示HTML页面或其他XML文档</strong>，但最常用的还是<strong>通过HTMLDocument的实例取得document对象</strong>。</li><li>document对象可用于<strong>获取关于页面的信息以及操纵其外观和底层结构</strong>。</li></ul><h2 id="1、文档子节点"><a href="#1、文档子节点" class="headerlink" title="1、文档子节点"></a>1、文档子节点</h2><ul><li>有两个快捷方式用于访问子节点：</li><li>documentElement属性：始终指向HTML页面中的html元素。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>针对以上页面结构，浏览器解析完成后，文档只有一个子节点，即<code>&lt;html&gt;</code>元素，这个元素既可以通过documentElement属性获取也可以通过childNodes列表访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">// true </span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><ul><li>HTMLDocument的实例document还有一个body属性直接指向<code>&lt;body&gt;</code>元素。</li><li>Document类型另一种可能的子节点是DocumentType。</li><li><code>&lt;!doctype&gt;</code>标签是文档中独立的部分，其信息可以通过doctype属性来访问。</li><li>出现在<code>&lt;html&gt;</code>元素外的注释也是文档的子节点，类型为Comment。不过由于浏览器实现不同，注释不一定能被识别。</li><li>因为文档类型是只读的，而且只能由一个Element类型的子节点，所以像appendChild()、removeChild()等方法不会再document对象上使用。</li></ul><h2 id="2、文档类型"><a href="#2、文档类型" class="headerlink" title="2、文档类型"></a>2、文档类型</h2><ul><li>document作为HTMLDocument的实例，还有一些标准Document对象上所没有的属性。<ul><li>title：包含<code>&lt;title&gt;</code>元素中的文本，通常显示再浏览器窗口或标签页的标题栏。<strong>可以通过修改title属性来修改页面的标题，但是并不会改变<code>&lt;title&gt;</code>元素</strong>。（document.title）</li><li>URL：包含当前页面完整的URL，与域名是相关的。比如：<a class="link" href="http://www.wrox.com/WileyCDA/">http://www.wrox.com/WileyCDA/<i class="fas fa-external-link-alt"></i></a> ➡ <a class="link" href="http://www.wrox.com.(document.url)/">www.wrox.com。（document.URL）<i class="fas fa-external-link-alt"></i></a></li><li>domain：包含页面的域名，可以调整设置，但出于安全考虑设置的值也是有限制的。（document.domain）</li><li>referrer：包含链接到当前页面的那个页面的URL；如果当前页面没有来源，则referrer属性包含字符串。（document.referrer）</li></ul></li><li>当页面中包含来自某个不同子域的窗格(<code>&lt;frame&gt;</code>)或内嵌窗格(<code>&lt;iframe&gt;</code>)时，设置document.domain是有用的。</li><li><strong>因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信</strong>。此时,在每个页面上把document.domain设置为相同的值，这些页面就可以访问对方的JavaScript对象了。</li><li>比如，一个加载自 <a class="link" href="http://www.wrox.com的页面中包含一个内嵌窗格,其中的页面加载自p2p.wrox.com.这两个页面的document.domain包含不同的字符串,内部和外部页面相互之间不能访问对方的/">www.wrox.com的页面中包含一个内嵌窗格，其中的页面加载自p2p.wrox.com。这两个页面的document.domain包含不同的字符串，内部和外部页面相互之间不能访问对方的<i class="fas fa-external-link-alt"></i></a> JavaScript对象。如果每个页面都把document.domain 设置为wrox.com，那这两个页面之间就可以通信了。</li><li>浏览器对domain属性还有一个限制，即<strong>这个属性一旦放松就不能再收紧</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com </span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 放松，成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;p2p.wrox.com&quot;</span>; <span class="comment">// 收紧，错误</span></span><br></pre></td></tr></table></figure><h2 id="3、定位元素"><a href="#3、定位元素" class="headerlink" title="3、定位元素"></a>3、定位元素</h2><ul><li>获取某个或某组元素的引用：<ul><li>getElementById()：<ul><li>接收一个参数，即要获取元素的ID；</li><li>如果找到了则返回这个元素，如果没找到则返回null；</li><li>参数ID必须跟元素在页面中的id属性值完全匹配，包括大小写。</li></ul></li><li>getElementsByTagName()：<ul><li>方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的NodeList。</li><li>在 HTML文档中，这个方法返回一个HTMLCollection对象。</li></ul></li><li>getElementsByName()：<ul><li>返回具有给定name属性的所有元素。</li></ul></li></ul></li></ul><h2 id="4、特殊集合"><a href="#4、特殊集合" class="headerlink" title="4、特殊集合"></a>4、特殊集合</h2><p>document对象上还暴露了几个特殊集合，这些集合也都是HTMLCollection的实例，同样也是访问文档中公共部分的快捷方式。</p><ul><li>document.anchors：包含文档中所有带name属性的<code>&lt;a&gt;</code>元素</li><li>document.applets：包含文档中所有<code>&lt;applet&gt;</code>元素</li><li>document.forms：包含文档中所有<code>&lt;form&gt;</code>元素与document.getElementsByTagName (“form”)返回的结果相同)。</li><li>document.images：包含文档中所有<code>&lt;img&gt;</code>元素(与document.getElementsByTagName (“img”)返回的结果相同)。</li><li>document.links包含文档中所有带href属性的<code>&lt;a&gt;</code>元素。</li></ul><h2 id="5、DOM兼容性检测"><a href="#5、DOM兼容性检测" class="headerlink" title="5、DOM兼容性检测"></a>5、DOM兼容性检测</h2><ul><li>由于DOM有多个 Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。</li><li><strong>document.implementation</strong>属性是一个对象，其中提供了<strong>与浏览器DOM实现相关的信息和能力</strong>。</li><li>DOM Level 1在 document.implementation上只定义了一个方法，即hasFeature()。<ul><li>这个方法接收两个参数：特性名称和DOM版本。</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/11/24/js-34-2/pic3.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/11/24/js-34-2/pic4.png" class title="# tu1"><h2 id="6、文档写入"><a href="#6、文档写入" class="headerlink" title="6、文档写入"></a>6、文档写入</h2><ul><li>write()、writeln()、open()和 close()。</li><li>write()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。</li><li>write()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符（\n）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current date and time is: </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span> </span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">&quot;&lt;strong&gt;&quot;</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).toString() + <span class="string">&quot;&lt;/strong&gt;&quot;</span>); </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img lazyload src="/images/loading.svg" data-src="/2021/11/24/js-34-2/pic5.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Document类型&quot;&gt;&lt;a href=&quot;#Document类型&quot; class=&quot;headerlink&quot; title=&quot;Document类型&quot;&gt;&lt;/a&gt;Document类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Document类型是JavaScript中&lt;strong&gt;表示</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——DOM类型（Node类型）</title>
    <link href="http://example.com/2021/11/24/js-34-1/"/>
    <id>http://example.com/2021/11/24/js-34-1/</id>
    <published>2021-11-24T07:37:57.000Z</published>
    <updated>2021-11-24T07:41:08.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h1><ul><li>DOMLevel 1描述了名为Node的接口，这个接口时所有DOM节点类型都必须实现的。</li><li>每个节点都有nodeType 属性，表示该节点的类型。节点类型由定义在 Node类型上的12个数值常量表示:<ul><li>Node.ELEMENT_NODE（1） </li><li>Node.ATTRIBUTE_NODE（2） </li><li>Node.TEXT_NODE（3） </li><li>Node.CDATA_SECTION_NODE（4） </li><li>Node.ENTITY_REFERENCE_NODE（5） </li><li>Node.ENTITY_NODE（6） </li><li>Node.PROCESSING_INSTRUCTION_NODE（7） </li><li>Node.COMMENT_NODE（8） </li><li>Node.DOCUMENT_NODE（9） </li><li>Node.DOCUMENT_TYPE_NODE（10） </li><li>Node.DOCUMENT_FRAGMENT_NODE（11） </li><li>Node.NOTATION_NODE（12）</li></ul></li></ul><h2 id="1、nodeName与nodeValue"><a href="#1、nodeName与nodeValue" class="headerlink" title="1、nodeName与nodeValue"></a>1、nodeName与nodeValue</h2><ul><li>nodeName 与nodeValue 保存着有关节点的信息。</li><li>这两个属性的值完全取决于节点类型，在使用这两个属性前,最好先检测节点类型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123; </span><br><span class="line">    value = someNode.nodeName; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这个例子中，先检查了节点是不是元素。如果是，则将其nodeName 的值赋给一个变量。对元素而言，nodeName始终等于元素的标签名，而nodevalue 则始终为null。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2、节点关系"><a href="#2、节点关系" class="headerlink" title="2、节点关系"></a>2、节点关系</h2><ul><li>文档中的所有节点都与其他节点有关系，这些关系可以形容为家族关系，相当于把文档树比作家谱。</li><li>每个节点都有一个childNodes属性，其中包含一个NodeList的实例。</li><li>NodeList是一个类数组对象，用于存储可以按位置存取的有序节点。</li><li>NodeList并不是Array的实例，但可以使用中括号访问它的值,而且它也有length属性。</li><li>NodeList是一个对DOM结构的查询，DOM结构的变化会自动地在NodeList 中反映出来。</li><li>我们通常说NodeList 是实时的活动对象，而不是第一次访问时所获得内容的快照。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild = someNode.childNodes[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> secondChild = someNode.childNodes.item(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> count = someNode.childNodes.length; </span><br></pre></td></tr></table></figure><ul><li>使用Array.prototype.slice()可以把NodeList对象转换为数组。</li><li>ES6的Array.from()静态方法同样也能实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes1 = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> arrayOfNodes2 = <span class="built_in">Array</span>.from(someNode.childNodes); </span><br></pre></td></tr></table></figure><ul><li><p>每个节点都有一个parentNode属性，指向其DOM树中的父元素。</p></li><li><p>childNodes中的所有节点都有同一个父元素，因此它们的parentNode属性都指向同一个节点。</p></li><li><p>childNodes列表中的每个节点都是同一列表中其他节点的同胞节点。</p></li><li><p>使用previoussibling 和nextsibling可以在这个列表的节点间导航。</p></li><li><p>这个列表中第一个节点的previoussibling属性是 null，最后一个节点的nextSibling属性也是null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nextSibling === <span class="literal">null</span>)&#123; </span><br><span class="line">     alert(<span class="string">&quot;Last node in the parent&#x27;s childNodes list.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.previousSibling === <span class="literal">null</span>)&#123; </span><br><span class="line">    alert(<span class="string">&quot;First node in the parent&#x27;s childNodes list.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果childlNodes中只有一个节点,则它的previoussibling和 nextsibling 属性都是null。</p></li><li><p>父节点和它的第一个及最后一个子节点也有专门属性：firstchild 和 lastchild 分别指向childNodes 中的第一个和最后一个子节点。</p></li><li><p>someNode.firstchild的值始终等于someNode.childNodes[0]，而someNode.lastChild 的值始终等于someNode.childNodes[someNode.childNodes.length-1]。</p></li><li><p>如果只有一个子节点，则firstchild和 lastchild指向同一个节点。</p></li><li><p>如果没有子节点，则firstchild和 lastchild都是 null。</p></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/11/24/js-34-1/pic2.png" class title="# tu1"><h2 id="3、操纵节点"><a href="#3、操纵节点" class="headerlink" title="3、操纵节点"></a>3、操纵节点</h2><ul><li>由于所有的关系指针都是只读的，DOM提供了一些操纵节点的方法。</li><li>appendChild()：用于在childNodes列表末尾添加节点<ul><li>添加新节点会更新相关的关系指针，包括父节点和之前一个子节点。</li><li>appendChild()会返回新添加的节点。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.appendChild(newNode); </span><br><span class="line">alert(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>如果把文档中已经存在的节点传给appendChild() ,则这个节点会从之前的位置被转移到新位置。</li><li>即使DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。</li><li><strong>如果调用appendChild()传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.appendChild(someNode.firstChild); </span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">// false </span></span><br><span class="line">alert(returnedNode == someNode.lastChild); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>如果想把节点放到childNodes中的特定位置而不是末尾，则可以使用**insertBefore()**方法。<ul><li>方法接收两个参数：<strong>要插入的节点</strong>和<strong>参照节点</strong>。</li><li>调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。</li><li>如果参照节点是 null，则insertBefore()与 appendchild()效果相同。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>); </span><br><span class="line">alert(newNode == someNode.lastChild); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.firstChild); </span><br><span class="line">alert(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line">alert(newNode == someNode.firstChild); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild); </span><br><span class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>appendChild()和insertBefore()在插入节点时不会删除任何已有节点</strong>。</li><li><strong>replacechild()方法</strong>接收两个参数：<strong>要插入的节点和要替换的节点。</strong></li><li>要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。</li><li>使用replacechild()插入一个节点后，所有关系指针都会从被替换的节点复制过来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild); </span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure><ul><li>移除节点可以使用<strong>removeChild()方法</strong>。<ul><li>这个方法接收一个参数，即要移除的节点。</li><li>被移除的节点会被返回,</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerFirstChild = someNode.removeChild(someNode.firstChild); </span><br><span class="line"><span class="comment">// 删除最后一个子节点</span></span><br><span class="line"><span class="keyword">let</span> formerLastChild = someNode.removeChild(someNode.lastChild);</span><br></pre></td></tr></table></figure><ul><li>上面介绍的4个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的parentNode属性）。</li><li>并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法,则会导致抛出错误。</li></ul><h2 id="4、其他方法"><a href="#4、其他方法" class="headerlink" title="4、其他方法"></a>4、其他方法</h2><ul><li><p>cloneNode()会返回与调用它的节点一模一样的节点。</p><ul><li>方法接收一个布尔值参数，表示是否深复制。即复制节点及其整个子DOM树。</li><li>如果传入 false，则只会复制调用该方法的节点。</li><li>复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点 ( orphan )。</li><li>可以通过appendchild()，insertBefore()或replacechild()方法把孤儿节点添加到文档中。</li></ul></li><li><p>normalize()用于处理文档子树中的文本节点。</p><ul><li>在节点上调用normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。</li><li>如果发现空文本节点，则将其删除；</li><li>如果两个同胞节点是相邻的，则将其合并为一个文本节点。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Node类型&quot;&gt;&lt;a href=&quot;#Node类型&quot; class=&quot;headerlink&quot; title=&quot;Node类型&quot;&gt;&lt;/a&gt;Node类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DOMLevel 1描述了名为Node的接口，这个接口时所有DOM节点类型都必须实现的。&lt;/li</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十四）DOM（一）</title>
    <link href="http://example.com/2021/11/18/js-34/"/>
    <id>http://example.com/2021/11/18/js-34/</id>
    <published>2021-11-18T06:24:19.000Z</published>
    <updated>2021-11-28T07:40:36.443Z</updated>
    
    <content type="html"><![CDATA[<ul><li>文档对象模型时HTML和XML文档的编程接口。</li><li>DOM表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。</li></ul><h1 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h1><ul><li>任何HTML或XML都可以用DOM表示一个由节点构成的层级结构。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/11/18/js-34/pic1.png" class title="# tu1"><p>其中, document节点表示每个文档的根节点。在这里,根节点的唯一子节点是<code>&lt;html&gt;</code>元素，我们称之为文档元素( documentElement)。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在HTML页面中，文档元素始终是<code>&lt;html&gt;</code>元素。在XML文档中,则没有这样预定义的元素,任何元素都可能成为文档元素。</p><h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><a href="/2021/11/24/js-34-1/" title="点击此处">点击此处</a><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><a href="/2021/11/24/js-34-2/" title="点击此处">点击此处</a><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><a href="/2021/11/24/js-34-3/" title="点击此处">点击此处</a><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><a href="/2021/11/25/js-34-4/" title="点击此处">点击此处</a><h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><a href="/2021/11/27/js-34-5/" title="点击此处">点击此处</a><h2 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h2><a href="/2021/11/27/js-34-6/" title="点击此处">点击此处</a><h2 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h2><a href="/2021/11/27/js-34-6/" title="点击此处">点击此处</a><h2 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h2><a href="/2021/11/28/js-34-7/" title="点击此处">点击此处</a><h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><a href="/2021/11/28/js-34-7/" title="点击此处">点击此处</a>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;文档对象模型时HTML和XML文档的编程接口。&lt;/li&gt;
&lt;li&gt;DOM表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;节点层级&quot;&gt;&lt;a href=&quot;#节点层级&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="DOM" scheme="http://example.com/categories/DOM/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三十三）BOM（二）</title>
    <link href="http://example.com/2021/11/17/js-33/"/>
    <id>http://example.com/2021/11/17/js-33/</id>
    <published>2021-11-17T07:12:24.000Z</published>
    <updated>2021-11-18T05:54:26.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h1><ul><li>location对象提供了当前窗口中加载文档的信息，以及通常的导航功能。</li><li>它<strong>既是window的属性，也是document的属性</strong>。</li><li>location对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。</li></ul><p>假设当前浏览器加载的URL是：<a class="link" href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=<i class="fas fa-external-link-alt"></i></a> javascript#contents</p><p>location对象的内容如下：</p><img lazyload src="/images/loading.svg" data-src="/2021/11/17/js-33/pic1.png" class title="# tu1"><h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><ul><li>虽然location.search 返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数首先删除了查询字符串开头的问号，当然前提是location.search必须有内容。解析后的参数将被保存到args对象，这个对象以字面量形式创建。接着，先把查询字符串按照s分割成数组，每个元素的形式为name=value。for循环迭代这个数组，将每一个元素按照=分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用decodeURIComponent ()解码后（这是因为查询字符串通常是被编码后的格式)分别保存在name和value变量中。最后，name作为属性而value作为该属性的值被添加到args对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> getQueryStringArgs = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="comment">// 取得没有开头问号的查询字符串</span></span><br><span class="line">    <span class="keyword">let</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">&quot;&quot;</span>), </span><br><span class="line">    <span class="comment">// 保存数据的对象</span></span><br><span class="line">    args = &#123;&#125;; </span><br><span class="line">    <span class="comment">// 把每个参数添加到 args 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> qs.split(<span class="string">&quot;&amp;&quot;</span>).map(<span class="function"><span class="params">kv</span> =&gt;</span> kv.split(<span class="string">&quot;=&quot;</span>))) &#123; </span><br><span class="line">        <span class="keyword">let</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]), </span><br><span class="line">            value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123; </span><br><span class="line">            args[name] = value; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> args; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>URLSearchParams提供了一组标准API方法,通过它们可以检查和修改查询字符串。</li><li>实例上暴露了get()、set()、delete()等方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = <span class="string">&quot;?q=javascript&amp;num=10&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> URLSearchParams(qs); </span><br><span class="line">alert(searchParams.toString()); <span class="comment">// &quot; q=javascript&amp;num=10&quot; </span></span><br><span class="line">searchParams.has(<span class="string">&quot;num&quot;</span>); <span class="comment">// true </span></span><br><span class="line">searchParams.get(<span class="string">&quot;num&quot;</span>); <span class="comment">// 10 </span></span><br><span class="line">searchParams.set(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;3&quot;</span>); </span><br><span class="line">alert(searchParams.toString()); <span class="comment">// &quot; q=javascript&amp;num=10&amp;page=3&quot; </span></span><br><span class="line">searchParams.delete(<span class="string">&quot;q&quot;</span>); </span><br><span class="line">alert(searchParams.toString()); <span class="comment">// &quot; num=10&amp;page=3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h2><ul><li>通过修改location对象可以修改浏览器的地址。</li><li>assign()方法传入一个URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br><span class="line"><span class="comment">//下面两行代码都会执行与显式调用assign()一样的操作</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">&quot;http://www.wrox.com&quot;</span>; </span><br><span class="line">location.href = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>修改location对象的属性也会修改当前加载的页面。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前 URL 为 http://www.wrox.com/WileyCDA/ </span></span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.wrox.com/WileyCDA/#section1 </span></span><br><span class="line">location.hash = <span class="string">&quot;#section1&quot;</span>; </span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.wrox.com/WileyCDA/?q=javascript </span></span><br><span class="line">location.search = <span class="string">&quot;?q=javascript&quot;</span>; </span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com/WileyCDA/ </span></span><br><span class="line">location.hostname = <span class="string">&quot;www.somewhere.com&quot;</span>; </span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com/mydir/ </span></span><br><span class="line">location.pathname = <span class="string">&quot;mydir&quot;</span>; </span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com:8080/WileyCDA/ </span></span><br><span class="line">location.port = <span class="number">8080</span>; </span><br></pre></td></tr></table></figure><ul><li>以上所有方法都会在浏览器的历史记录中增加相应的记录。* 如果不希望增加历史记录，可以使用replace()方法。<ul><li>这个方法接收一个URL参数。</li><li>重新加载页面后不会增加历史记录，并且用户不能回到前一页。</li></ul></li><li>reload()方法也可以修改地址，作用是重新加载当前显示的页面。<ul><li>不传参数页面会以最有效的方式重新加载。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">// 重新加载，可能是从缓存加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">// 重新加载，从服务器加载</span></span><br></pre></td></tr></table></figure><h1 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h1><p>navigator是由Netscape Navigator2最早引入浏览器的，现在已经成为客户端标识浏览器的标准。只要浏览器启用JavaScript，navigator对象就一定存在。但是与其他BOM对象一样，每个浏览器都支持自己的属性。</p><img lazyload src="/images/loading.svg" data-src="/2021/11/17/js-33/pic2.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/11/17/js-33/pic3.png" class title="# tu1"><ul><li>navigator对象的属性通常用于确定浏览器的类型。</li></ul><h2 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h2><ul><li>除IE10及更低版本外的浏览器，都可以通过plugins数组来确定。这个数组中的每一项都包含如下属性。<ul><li>name：插件名称。</li><li>description：插件介绍。</li><li>filename：插件的文件名。</li><li>length：由当前插件处理的MIME类型数量。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件检测，IE10 及更低版本无效 </span></span><br><span class="line"><span class="keyword">let</span> hasPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">    name = name.toLowerCase(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> <span class="built_in">window</span>.navigator.plugins)&#123; </span><br><span class="line">        <span class="keyword">if</span> (plugin.name.toLowerCase().indexOf(name) &gt; -<span class="number">1</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 检测 Flash </span></span><br><span class="line">alert(hasPlugin(<span class="string">&quot;Flash&quot;</span>)); </span><br><span class="line"><span class="comment">// 检测 QuickTime </span></span><br><span class="line">alert(hasPlugin(<span class="string">&quot;QuickTime&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h2><ul><li>使用registerProtocolHandler()方法可以把一个网站注册为处理某种特定类型信息应用程序。</li><li>必须传入3个参数：<ul><li>要处理的协议；如：mailto或ftp</li><li>处理该协议的URL；</li><li>应用名称。</li></ul></li></ul><p>把一个Web应用程序注册为默认邮件客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个例子为&quot;mailto&quot;协议注册了一个处理程序，这样邮件地址就可以通过指定的Web应用程序打开。注意,第二个参数是负责处理请求的URL，%s表示原始的请求。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">navigator.registerProtocolHandler(<span class="string">&quot;mailto&quot;</span>, </span><br><span class="line"> <span class="string">&quot;http://www.somemailclient.com?cmd=%s&quot;</span>, </span><br><span class="line"> <span class="string">&quot;Some Mail Client&quot;</span>); </span><br></pre></td></tr></table></figure><h1 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h1><ul><li>该对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息。</li><li>screen对象上暴露的属性如下：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/11/17/js-33/pic4.png" class title="# tu1"><h1 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h1><ul><li>表示当前窗口首次使用以来用户的导航历史记录。</li><li>history是window的属性。</li></ul><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul><li>go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。</li><li>只接收一个参数：<ul><li>可以是一个整数：表示前进后退多少步；</li><li>负值：表示在历史记录中后退；</li><li>正值：表示在历史记录中前进；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.go(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.go(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>go()方法可以简写为：back()和forward()。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.back(); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.forward(); </span><br></pre></td></tr></table></figure><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><ul><li>hashchange会在页面URL的散列变化时被触发，开发者可以在此时执行某些操作。</li><li>状态管理API则可以让开发者改变浏览器URL而不会加载新页面。</li><li>history.pushState()方法接收3个参数：<ul><li>state对象；</li><li>新状态的标题；</li><li>(可选的)相对URL。</li></ul></li><li>pushstate()方法执行后，状态信息就会被推到历史记录中,浏览器地址栏也会改变以反映新的相对URL。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;location对象提供了当前窗口中加载文档的信息，以及通常的导</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="BOM" scheme="http://example.com/categories/BOM/"/>
    
    <category term="location对象" scheme="http://example.com/categories/location%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
