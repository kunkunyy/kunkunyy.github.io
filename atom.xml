<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚永坤的小窝</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-02T17:58:27.002Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>姚永坤</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS学习笔记（十三）结构与布局</title>
    <link href="http://example.com/2022/02/03/css-13/"/>
    <id>http://example.com/2022/02/03/css-13/</id>
    <published>2022-02-02T16:34:01.000Z</published>
    <updated>2022-02-02T17:58:27.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h1><ul><li>关键字：min-content<ul><li>将解析为这个容器内部最大的不可断行元素的宽度</li></ul></li><li>把 figure 设置为恰当的宽度，并让它水平居中。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">figure</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: min-content;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h1><ul><li>对于不固定的内容，表格布局很难预测。</li><li>table-layout属性：<ul><li>默认值是 auto，其行为模式被称作自动表格布局算法。</li><li>接受另外一个值fixed，这个值的行为要明显可控一些。它把更多的控制权交给了网页开发者。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">table-layout</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h1><ul><li>在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。</li><li>对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child。</li><li>:only-child 等效于 :first-child:last-child。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:only-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 只有一个列表项时的样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>:last-child 其实也是一个快捷写法，相当于 :nth-last-child(1)。</li><li>这个 1 其实是一个参数，我们可以根据需要来修改这个值。</li><li>li:first-child:nth-last-child(4)<ul><li>一个正好有四个列表项的列表中的第一个列表项。</li><li>可以用兄弟选择符（~）来命中它之后的所有兄弟元素：相当于在这个列表正好包含四个列表项时，命中它的每一项。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">:nth-last-child</span>(<span class="number">4</span>),</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">:nth-last-child</span>(<span class="number">4</span>) ~ <span class="selector-tag">li</span> &#123;</span><br><span class="line"> <span class="comment">/* 当列表正好包含四项时，命中所有列表项 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="根据兄弟元素的数量范围来匹配元素"><a href="#根据兄弟元素的数量范围来匹配元素" class="headerlink" title="根据兄弟元素的数量范围来匹配元素"></a>根据兄弟元素的数量范围来匹配元素</h2><ul><li>:nth-child()可以用它来命中一个范围<ul><li>参数：an+b，n 表示一个变量，理论上的范围是 0 到 + ∞；</li><li>如果使用 n+b 这种形式的表达式（此时相当于 a 的取值为 1），那么不论 n 如何取值，这个表达式都无法产生一个小于 b 的值。</li><li>因此，n+b 这种形式的表达式可以选中从第 b 个开始的所有子元素。</li></ul></li></ul><h1 id="满幅的背景，定宽的内容"><a href="#满幅的背景，定宽的内容" class="headerlink" title="满幅的背景，定宽的内容"></a>满幅的背景，定宽的内容</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">450px</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><h2 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h2><ul><li>它要求元素具有固定的宽度和高度。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">3em</span>; <span class="comment">/* 6/2 = 3 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">9em</span>; <span class="comment">/* 18/2 = 9 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于视口单位的解决方案"><a href="#基于视口单位的解决方案" class="headerlink" title="基于视口单位的解决方案"></a>基于视口单位的解决方案</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50vh</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-Flexbox-的解决方案"><a href="#基于-Flexbox-的解决方案" class="headerlink" title="基于 Flexbox 的解决方案"></a>基于 Flexbox 的解决方案</h2><ul><li>只需写两行声明即可：先给这个待居中元素的父元素设置 display: flex，再给这个元素自身设置我们再熟悉不过的 margin: auto。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自适应内部元素&quot;&gt;&lt;a href=&quot;#自适应内部元素&quot; class=&quot;headerlink&quot; title=&quot;自适应内部元素&quot;&gt;&lt;/a&gt;自适应内部元素&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关键字：min-content&lt;ul&gt;
&lt;li&gt;将解析为这个容器内部最大的不可断行元素的</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（十二）用户体验（一）</title>
    <link href="http://example.com/2022/01/28/css-12/"/>
    <id>http://example.com/2022/01/28/css-12/</id>
    <published>2022-01-28T10:51:01.000Z</published>
    <updated>2022-02-02T16:22:11.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十九、选用合适的鼠标光标"><a href="#二十九、选用合适的鼠标光标" class="headerlink" title="二十九、选用合适的鼠标光标"></a>二十九、选用合适的鼠标光标</h1><ul><li>鼠标指针的用途不仅在于显示鼠标在屏幕上的位置，还可以告诉用户当前可以执行什么动作。</li></ul><h2 id="1、提示禁用状态"><a href="#1、提示禁用状态" class="headerlink" title="1、提示禁用状态"></a>1、提示禁用状态</h2><ul><li>提示某个控件因为某些原因而变得无法交互（即控件已被禁用），用这个光标就再合适不过。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:disabled</span>, <span class="selector-attr">[disabled]</span>, <span class="selector-attr">[aria-disabled=<span class="string">&quot;true&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/28/css-12/pic1.png" class title="# tu1"><h2 id="2、隐藏鼠标光标"><a href="#2、隐藏鼠标光标" class="headerlink" title="2、隐藏鼠标光标"></a>2、隐藏鼠标光标</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">transparent.gif</span>);</span><br><span class="line">    <span class="attribute">cursor</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三十、扩大可点击区域"><a href="#三十、扩大可点击区域" class="headerlink" title="三十、扩大可点击区域"></a>三十、扩大可点击区域</h1><ul><li>针对按钮或者选择框扩大可点击区域，提高用户体验感。</li><li>使用内嵌投影+外边框实现。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>) inset;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>box-shadow 可以同时指定多层投影。</li><li>伪元素同样可以代表其宿主元素来响应鼠标交互。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* [其余样式] */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>; <span class="attribute">right</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">10px</span>; <span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三十一、自定义复选框"><a href="#三十一、自定义复选框" class="headerlink" title="三十一、自定义复选框"></a>三十一、自定义复选框</h1><ul><li>新的伪类 :checked。<ul><li>这个伪类只在复选框被勾选时才会匹配，不论这个勾选状态是由用户交互触发，还是由脚本触发。</li></ul></li><li>可以基于复选框的勾选状态借助组合选择符来给其他元素设置样式。</li><li>当 <code>&lt;label&gt;</code> 元素与复选框关联之后，也可以起到触发开关的作用。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;\a0&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">vertical-align</span>: .<span class="number">2em</span>;</span><br><span class="line"><span class="attribute">width</span>: .<span class="number">8em</span>;</span><br><span class="line"><span class="attribute">height</span>: .<span class="number">8em</span>;</span><br><span class="line"><span class="attribute">margin-right</span>: .<span class="number">2em</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: .<span class="number">2em</span>;</span><br><span class="line"><span class="attribute">background</span>: silver;</span><br><span class="line"><span class="attribute">text-indent</span>: .<span class="number">15em</span>;</span><br><span class="line"><span class="attribute">line-height</span>: .<span class="number">65</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;\2713&#x27;</span>;</span><br><span class="line"><span class="attribute">background</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:focus</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">1em</span> .<span class="number">1em</span> <span class="number">#58a</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:disabled</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: gray;</span><br><span class="line"><span class="attribute">box-shadow</span>: none;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line"><span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/28/css-12/pic2.png" class title="# tu1"><h2 id="开关式按钮"><a href="#开关式按钮" class="headerlink" title="开关式按钮"></a>开关式按钮</h2><ul><li>利用“复选框 hack”的思路来模拟。</li><li>只需要把 label 设置为按钮的样式即可，并不需要用到伪元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> + <span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">#ddd</span>, <span class="number">#bbb</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> white inset;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:active</span> + <span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: .<span class="number">05em</span> .<span class="number">1em</span> .<span class="number">2em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">6</span>) inset;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#bbb</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三十二、通过阴影来弱化背景"><a href="#三十二、通过阴影来弱化背景" class="headerlink" title="三十二、通过阴影来弱化背景"></a>三十二、通过阴影来弱化背景</h1><ul><li>通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注。</li><li>最常见的实现方法就是增加一个额外的 HTML 元素用于遮挡背景，这个方法稳定可靠，但需要增加一个额外的 HTML 元素，这意味着该效果无法由 CSS 单独实现。</li></ul><h2 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h2><ul><li>用伪元素来消除额外的 HTML 元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dimmed</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>存在的问题：</strong><ul><li>这个方法的可移植性还不够好；因为 <code>&lt;body&gt;</code>元素上可能有其他需求已经占用了 ::before 伪元素；</li><li>在使用这个效果时，我们往往还需要一点 JavaScript 来给 <code>&lt;body&gt;</code> 添加 dimmed 这个类.</li><li>伪元素无法绑定独立的 JavaScript 事件处理函数。</li></ul></li></ul><h2 id="box-shadow方案"><a href="#box-shadow方案" class="headerlink" title="box-shadow方案"></a>box-shadow方案</h2><ul><li>对于简单的应用场景和产品原型来说，box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。</li><li><strong>存在的问题：</strong><ul><li>由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们滚动页面时，遮罩层的边缘就露出来了，除非给它加上 position: fixed;这个样式，或者页面并没有长到需要滚动的程度。</li><li>当使用一个独立的元素（或伪元素）来实现遮罩层时，这个遮罩层不仅可以从视觉上把用户的注意力引导到关键元素上，还可以防止用户的鼠标与页面的其他部分发生交互，因为遮罩层会捕获所有指针事件。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50vmax</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="backdrop方案"><a href="#backdrop方案" class="headerlink" title="backdrop方案"></a>backdrop方案</h2><ul><li>如果你想引导用户关注的元素就是一个模态的 <code>&lt;dialog&gt;</code> 元素，那么根据浏览器的默认样式，它会自带一个遮罩层。</li><li>借助 ::backdrop 伪元素，这个原生的遮罩层也是可以设置样式的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dialog<span class="selector-pseudo">::backdrop</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三十三、通过模糊来弱化背景"><a href="#三十三、通过模糊来弱化背景" class="headerlink" title="三十三、通过模糊来弱化背景"></a>三十三、通过模糊来弱化背景</h1><ul><li>用一个额外的 HTML 元素来实现这个效果：<ul><li>需要把页面上除了关键元素之外的一切都包裹起来，这样就可以只对这个容器元素进行模糊处理了。</li><li><code>&lt;main&gt;</code> 元素在这里是极为合适的。</li></ul></li><li>结构代码基本上如下所示：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>Bacon Ipsum dolor sit amet...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dialog</span>&gt;</span></span><br><span class="line">    O HAI, I&#x27;m a dialog. Click on me to dismiss.</span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他对话框都写在这里 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>每当弹出一个对话框，都需要给 <code>&lt;main&gt;</code> 元素增加一个类，以便对它应用模糊滤镜。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span><span class="selector-class">.de-emphasized</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 brightness() 和 / 或 contrast() 滤镜：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span><span class="selector-class">.de-emphasized</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>) <span class="built_in">contrast</span>(.<span class="number">8</span>) <span class="built_in">brightness</span>(.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二十九、选用合适的鼠标光标&quot;&gt;&lt;a href=&quot;#二十九、选用合适的鼠标光标&quot; class=&quot;headerlink&quot; title=&quot;二十九、选用合适的鼠标光标&quot;&gt;&lt;/a&gt;二十九、选用合适的鼠标光标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;鼠标指针的用途不仅在于显示鼠标在屏幕上的</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（十一）字体排印（二）</title>
    <link href="http://example.com/2022/01/24/css-11/"/>
    <id>http://example.com/2022/01/24/css-11/</id>
    <published>2022-01-24T09:20:30.000Z</published>
    <updated>2022-01-28T10:53:11.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十三、调整tab的宽度"><a href="#二十三、调整tab的宽度" class="headerlink" title="二十三、调整tab的宽度"></a>二十三、调整tab的宽度</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><ul><li>由于tab导致文本间间隙过大进而影响视觉效果。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>tab-size属性：<ul><li>接受一个数字（表示字符数）或者一个长度值。</li><li>通常希望把它设置为 4（表示 4 个字符的宽度）或2。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pre &#123;</span><br><span class="line">    <span class="attribute">tab-size</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>视觉效果对比：</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic1.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic2.png" class title="# tu1"><h1 id="二十四、连字"><a href="#二十四、连字" class="headerlink" title="二十四、连字"></a>二十四、连字</h1><h2 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h2><ul><li>由于字形间的相互影响，导致字形模糊不清。</li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>font-variant-ligatures属性：<ul><li>该属性专门用来控制连字效果的开启和关闭。</li><li>如果要启用所有可能的连字，需要同时指定这三个标识符。</li><li>如果要把 font-variant-ligatures 属性复位为初始值，应该使用 normal 而不是 none。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">font-variant-ligatures</span>: common-ligatures</span><br><span class="line">        discretionary-ligatures</span><br><span class="line">        historical-ligatures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二十五、华丽的-amp-符号"><a href="#二十五、华丽的-amp-符号" class="headerlink" title="二十五、华丽的&amp;符号"></a>二十五、华丽的&amp;符号</h1><ul><li><p>通过@font-face规则实现基本的字体嵌入。</p></li><li><p>无法通过单一的字符实现不同样式的&amp;。</p></li></ul><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>原理：如果某款字体可用，但仅包括某几个字符，那它就只会用来显示这几个字符；而在显示其他字符时，浏览器就会回退到其他字体。</li><li>方法：创建一种只包含 &amp; 字形的 Web 字体，通过 @font-face 将其引入网页，然后把它排在字体队列中的第一位。<ul><li>@font-face 规则中的 src 描述符还可以接受 local()函数，用于指定本地字体的名称。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Ampersand;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">&#x27;Baskerville-Italic&#x27;</span>),</span><br><span class="line">    <span class="built_in">local</span>(<span class="string">&#x27;GoudyOldStyleT-Italic&#x27;</span>),</span><br><span class="line">    <span class="built_in">local</span>(<span class="string">&#x27;Palatino-Italic&#x27;</span>),</span><br><span class="line">    <span class="built_in">local</span>(<span class="string">&#x27;BookAntiqua-Italic&#x27;</span>);</span><br><span class="line">    unicode-range: U+<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Ampersand, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二十六、自定义下划线"><a href="#二十六、自定义下划线" class="headerlink" title="二十六、自定义下划线"></a>二十六、自定义下划线</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>CSS 渐变；</li><li>background-size；</li><li>text-shadow；</li><li>“条纹背景”。</li></ul><h2 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h2><ul><li>默认样式往往太过扎眼，更不要提在不同浏览器下的渲染效果大相径庭。</li></ul><h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(gray, gray) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">1.15em</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: .<span class="number">05em</span> <span class="number">0</span> white, -.<span class="number">05em</span> <span class="number">0</span> white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过渐变和background-size两个属性来产生灰色细线，然后使用background-position调整位置。</li><li>由于这样产生的下划线会穿过某些字母（比如 p 和 y）的降部。所以此时设置两层与背景色相同的 text-shadow 来模拟下划线在遇到字母时会自动断开避让这种效果。</li><li>生成一条虚线下划线：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,gray <span class="number">66%</span>, transparent <span class="number">0</span>) repeat-x;</span><br><span class="line">    <span class="attribute">background-size</span>: .<span class="number">2em</span> <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二十七、现实中的文字效果"><a href="#二十七、现实中的文字效果" class="headerlink" title="二十七、现实中的文字效果"></a>二十七、现实中的文字效果</h1><h2 id="凸版印刷效果"><a href="#凸版印刷效果" class="headerlink" title="凸版印刷效果"></a>凸版印刷效果</h2><ul><li><strong>当我们在浅色背景上使用深色文字时（比如眼前的这个例子），在底部加上浅色投影通常效果最佳。</strong></li><li><strong>如果把文字和背景的颜色深度对调，在这种情况下，给文字顶部加深色投影是最佳方案。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">210</span>, <span class="number">13%</span>, <span class="number">60%</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">hsl</span>(<span class="number">210</span>, <span class="number">13%</span>, <span class="number">30%</span>);</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic3.png" class title="# tu1"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">210</span>, <span class="number">13%</span>, <span class="number">40%</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">hsl</span>(<span class="number">210</span>, <span class="number">13%</span>, <span class="number">75%</span>);</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">1px</span> <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic4.png" class title="# tu1"><h2 id="空心字效果"><a href="#空心字效果" class="headerlink" title="空心字效果"></a>空心字效果</h2><ul><li>使用 text-shadows 属性的扩张参数就可让投影变大，看起来就像给文字勾边了一样。</li><li>方法一：使用多个 text-shadow 分别为这些投影加上不同方向的少量偏移。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> black, -<span class="number">1px</span> -<span class="number">1px</span> black,</span><br><span class="line">                <span class="number">1px</span> -<span class="number">1px</span> black, -<span class="number">1px</span> <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic5.png" class title="# tu1"><ul><li>方法二：重叠多层轻微模糊的投影来模拟描边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: deeppink;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black, <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black,</span><br><span class="line">                <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black, <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black,</span><br><span class="line">                <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black, <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文字外发光效果"><a href="#文字外发光效果" class="headerlink" title="文字外发光效果"></a>文字外发光效果</h2><ul><li><strong>方法一</strong>：只需要准备几层重叠的 text-shadow 即可，不需要考虑偏移量，颜色也只需跟文字保持一致。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#203</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffc</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">1em</span>, <span class="number">0</span> <span class="number">0</span> .<span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic6.png" class title="# tu1"><ul><li>依赖 text-shadow 来实现文字显示的做法无法实现平稳退化：如果浏览器不支持 text-shadow，那就什么字也看不见了。</li><li><strong>方法二</strong>：使用 CSS 滤镜来实现文字的模糊效果</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#203</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(.<span class="number">1em</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文字突起效果"><a href="#文字突起效果" class="headerlink" title="文字突起效果"></a>文字突起效果</h2><ul><li><strong>思路</strong>：使用一长串累加的投影，不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影，从而模拟完整的立体效果。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">85%</span>),</span><br><span class="line">                <span class="number">0</span> <span class="number">2px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">80%</span>),</span><br><span class="line">                <span class="number">0</span> <span class="number">3px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">75%</span>),</span><br><span class="line">                <span class="number">0</span> <span class="number">4px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">70%</span>),</span><br><span class="line">                <span class="number">0</span> <span class="number">5px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">65%</span>),</span><br><span class="line">                <span class="number">0</span> <span class="number">5px</span> <span class="number">10px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/24/css-11/pic7.png" class title="# tu1"><h1 id="二十八、环形文字"><a href="#二十八、环形文字" class="headerlink" title="二十八、环形文字"></a>二十八、环形文字</h1><ul><li>使用svg解决。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二十三、调整tab的宽度&quot;&gt;&lt;a href=&quot;#二十三、调整tab的宽度&quot; class=&quot;headerlink&quot; title=&quot;二十三、调整tab的宽度&quot;&gt;&lt;/a&gt;二十三、调整tab的宽度&lt;/h1&gt;&lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; cla</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（十）字体排印（一）</title>
    <link href="http://example.com/2022/01/15/css-10/"/>
    <id>http://example.com/2022/01/15/css-10/</id>
    <published>2022-01-15T13:31:28.000Z</published>
    <updated>2022-01-24T09:16:46.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十、连字符断行"><a href="#二十、连字符断行" class="headerlink" title="二十、连字符断行"></a>二十、连字符断行</h1><ul><li>在对文本进行两端对齐处理时，需要调整单词的间距，此时会出现“单词孤岛”现象。这个结果不仅看起来很糟糕，而且损伤了可读性。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: justify;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic1.png" class title="# tu1"><ul><li>解决方案：<ul><li>hyphens属性：接受三个值none、manual、auto。</li><li>默认值为manual。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">hyphens</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic2.png" class title="# tu1"><h1 id="二十一、插入换行"><a href="#二十一、插入换行" class="headerlink" title="二十一、插入换行"></a>二十一、插入换行</h1><ul><li><p>由于<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code>都是块级元素，当我们需要指定其在一行时会造成困难，如下所示：</p></li><li><p>我们需要创建以下格式列表：</p><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic3.png" class title="# tu1"></li><li><p>应用如下代码和样式，会得到这样的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Lea Verou<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>lea@verou.me<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Location:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Earth<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic4.png" class title="# tu1"></li><li><p>外加display:inline则会出现以下效果：</p></li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic5.png" class title="# tu1"><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>利用伪元素来实现。</li><li>有一个 Unicode 字符是专门代表换行符的：0x000A。在 CSS 中，这个字符可以写作 “\000A”，或简化为 “\A”。</li><li>我们可以用它来作为 ::after 伪元素的内容，并将其添加到每个 <code>&lt;dd&gt;</code> 元素的尾部。</li><li><strong>由于换行符会与空白符合并导致整体视觉效果压缩，所以需要保留换行符。</strong>（如果不保留，则结果与上图没有任何变化）</li><li>使用white-space: pre实现以上结果。</li></ul><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul><li>针对单对单采取以下步骤：<br>  1、 将块级元素转换为行级元素；<br>  2、 利用伪元素给每个<code>&lt;dd&gt;</code>添加换行；<br>  3、 使用white-space:pre属性来处理空白。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dt</span>, <span class="selector-tag">dd</span> &#123; <span class="attribute">display</span>: inline; &#125;</span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dd</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\A&quot;</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic6.png" class title="# tu1"><ul><li>如果有一对多情况则需要调整一下第二步：<ul><li>在每个前面有<code>&lt;dd&gt;</code>的<code>&lt;dd&gt;</code>头部插入逗号；</li><li>在每个前面有<code>&lt;dd&gt;</code>的<code>&lt;dt&gt;</code>头部插入换行。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dt</span>, <span class="selector-tag">dd</span> &#123; <span class="attribute">display</span>: inline; &#125;</span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dt</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;\A&#x27;</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;, &#x27;</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic6.png" class title="# tu1"><h1 id="二十二、文本行的斑马条纹"><a href="#二十二、文本行的斑马条纹" class="headerlink" title="二十二、文本行的斑马条纹"></a>二十二、文本行的斑马条纹</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>CSS 渐变；</li><li>background-size；</li><li>“条纹背景”；</li><li>“灵活的背景定位”。</li></ul><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li>无法在文本行中应用斑马纹效果；</li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>利用背景图像来做到模拟斑马纹的效果。</li><li>直接上代码：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">background</span>: beige;</span><br><span class="line">    <span class="attribute">background-size</span>: auto <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">background-origin</span>: content-box;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>) <span class="number">50%</span>,transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、 在利用background设置整体背景色后，利用background-image属性创建渐变来实现不同行不同颜色的效果。<br>2、 这里需要设置background-size为行高line-height的两倍，因为每个背景贴片需要覆盖两行代码（一行有实际颜色，一行为透明）。<br>3、 padding属性将整体的文本调整位置不至于太过于靠边影响视觉效果。<br>4、 由于文本调整了位置，这里我们需要将背景进行些调整：让它的默认外沿padding box调整为content box。</p><img lazyload src="/images/loading.svg" data-src="/2022/01/15/css-10/pic7.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二十、连字符断行&quot;&gt;&lt;a href=&quot;#二十、连字符断行&quot; class=&quot;headerlink&quot; title=&quot;二十、连字符断行&quot;&gt;&lt;/a&gt;二十、连字符断行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在对文本进行两端对齐处理时，需要调整单词的间距，此时会出现“单词孤岛”现象。这个</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（九）视觉效果</title>
    <link href="http://example.com/2022/01/11/css-9/"/>
    <id>http://example.com/2022/01/11/css-9/</id>
    <published>2022-01-11T12:16:16.000Z</published>
    <updated>2022-01-17T08:36:59.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十五、单侧投影"><a href="#十五、单侧投影" class="headerlink" title="十五、单侧投影"></a>十五、单侧投影</h1><ul><li>使用 box-shadow 的方法是，指定三个长度值和一个颜色值：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">3px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>box-shadow绘制原理：</p><ul><li>以选定的元素a为准，在相同的位置处绘制尺寸相同的元素b（a，b颜色不同）；</li><li>将元素b进行移动，移动大小由参数决定（第一二个参数）；</li><li>使用高斯模糊算法进行模糊处理（第三个参数决定）；</li><li>模糊后的元素b与元素a交集的部分会被切除掉。</li></ul></li><li><p>如何只在元素的一侧设置投影。</p><ul><li>box-shadow的第四个长度参数，这个参数会根据你指定的值去扩大或缩小投影的尺寸</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">4px</span> -<span class="number">4px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻边投影"><a href="#邻边投影" class="headerlink" title="邻边投影"></a>邻边投影</h2><ul><li>如何在元素的两条边上设置投影。</li><li><strong>扩张半径应该设为模糊半径相反值的一半。</strong></li><li><strong>两个偏移量它们的值需要大于或等于模糊半径的一半。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> -<span class="number">3px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双侧投影"><a href="#双侧投影" class="headerlink" title="双侧投影"></a>双侧投影</h2><ul><li>将投影设置在元素的两条对边。</li><li>将单侧投影使用两次来达到效果</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span> -<span class="number">5px</span> black,</span><br><span class="line">                -<span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span> -<span class="number">5px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十六、不规则投影"><a href="#十六、不规则投影" class="headerlink" title="十六、不规则投影"></a>十六、不规则投影</h1><ul><li>使用 drop-shadow 滤镜实现投影，任何非透明的部分都会被一视同仁地打上投影，包括文本，并且无法通过text-shadow:none; 来取消掉文本上的投影。</li></ul><h1 id="十七、染色效果"><a href="#十七、染色效果" class="headerlink" title="十七、染色效果"></a>十七、染色效果</h1><h2 id="基于滤镜的方案"><a href="#基于滤镜的方案" class="headerlink" title="基于滤镜的方案"></a>基于滤镜的方案</h2><ul><li>叠加滤镜效果的方式实现染色效果。</li><li>sepia()：它会给图片增加一种降饱和度的橙黄色染色效果，几乎所有像素的色相值会被收敛到 35~40。</li><li>saturate()：他会给每个像素提升饱和度。</li><li>hue-rotate()：把每个像素的色相以指定的度数进行偏移。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">sepia</span>(<span class="number">1</span>) <span class="built_in">saturate</span>(<span class="number">4</span>) <span class="built_in">hue-rotate</span>(<span class="number">295deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic1.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic2.png" class title="# tu1"><h2 id="基于混合模式的方案"><a href="#基于混合模式的方案" class="headerlink" title="基于混合模式的方案"></a>基于混合模式的方案</h2><ul><li>“混合模式”控制了上层元素的颜色与下层颜色进行混合的方式。</li><li>用它来实现染色效果时，需要用到的混合模式<br>是 luminosity。<ul><li>luminosity 混合模式会保留上层元素的 HSL 亮度信息，并从它的下层吸取色相和饱和度信息。</li></ul></li><li>要对一个元素设置混合模式，有两个属性可以派上用场：<ul><li>mix-blend-mode 可以为整个元素设置混合模式；mix-blend-mode 是把整个元素向下进行混合，而不管它的下层是什么。</li><li>background-blend-mode 可以为每层背景单独指定混合模式。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#something&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;tiger.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Rawrrr!&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">335</span>, <span class="number">100%</span>, <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    mix-blend-mode: luminosity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tinted-image&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;background-image:url(tiger.jpg)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tinted-image</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640px</span>; <span class="attribute">height</span>: <span class="number">440px</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">335</span>, <span class="number">100%</span>, <span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">background</span>-blend-mode: luminosity;</span><br><span class="line">    <span class="attribute">transition</span>: .<span class="number">5s</span> background-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tinted-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十八、毛玻璃效果"><a href="#十八、毛玻璃效果" class="headerlink" title="十八、毛玻璃效果"></a>十八、毛玻璃效果</h1><ul><li>半透明颜色背景：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        &quot;The only way to get rid of a temptation[...]&quot;</span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>－</span><br><span class="line">            <span class="tag">&lt;<span class="name">cite</span>&gt;</span></span><br><span class="line">                Oscar Wilde,</span><br><span class="line">                The Picture of Dorian Gray</span><br><span class="line">            <span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;tiger.jpg&quot;</span>) <span class="number">0</span> / cover fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic3.png" class title="# tu1"><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>由于我们不能直接对元素本身进行模糊处理，就对一个伪元素进行处理，然后将其定位到元素的下层，它的背景将会无缝匹配 <code>&lt;body&gt;</code> 的背景。</li><li>首先，我们添加一个伪元素，将其绝对定位，并把所有偏移量置为 0，这样就可以将它完整地覆盖到 <code>&lt;main&gt;</code> 元素之上：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* [其余样式] */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>); <span class="comment">/* 仅用于调试 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic4.png" class title="# tu1"><ul><li>使用 z-index: -1; 来把伪元素移动到宿主元素的后面。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic5.png" class title="# tu1"><ul><li>现在该把半透明红色背景换掉了，换成跟背层完全匹配的背景。要实现这一点，我们要么把 <code>&lt;body&gt;</code> 的背景复制过来，要么把伪元素的背景声明合并过去。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;tiger.jpg&quot;</span>) <span class="number">0</span> / cover fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic6.png" class title="# tu1"><ul><li>模糊效果在中心区域看起来非常完美，但在接近边缘处会逐渐消退。这是因为模糊效果会削减实色像素所能覆盖的范围，削减的幅度正是模糊半径的长度。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic7.png" class title="# tu1"><ul><li>为了补偿这种情况，我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少 20px（即它的模糊半径）。可以通过 -20px 的外边距来达到目的，由于不同浏览器的模糊算法可能存在差异，用一个更大的绝对值（比如 -30px）会更保险一些。</li><li>这个方法可以修复边缘模糊消退的问题，但现在的情况是有一圈模糊效果超出了容器，这让它看起来不像毛玻璃，而更像是玻璃脏了。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic8.png" class title="# tu1"><ul><li>不过幸运的是，这个问题也很容易修复：只要对 main 元素应用overflow: hidden;，就可以把多余的模糊区域裁切掉了。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;tiger.jpg&quot;</span>) <span class="number">0</span> / cover fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">20px</span>);</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/11/css-9/pic9.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十五、单侧投影&quot;&gt;&lt;a href=&quot;#十五、单侧投影&quot; class=&quot;headerlink&quot; title=&quot;十五、单侧投影&quot;&gt;&lt;/a&gt;十五、单侧投影&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用 box-shadow 的方法是，指定三个长度值和一个颜色值：&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（八）形状（四）</title>
    <link href="http://example.com/2022/01/10/css-8/"/>
    <id>http://example.com/2022/01/10/css-8/</id>
    <published>2022-01-10T14:26:56.000Z</published>
    <updated>2022-01-11T12:00:29.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十三、梯形标签页"><a href="#十三、梯形标签页" class="headerlink" title="十三、梯形标签页"></a>十三、梯形标签页</h1><ul><li>在 CSS 中用 3D 旋转来模拟出这个效果。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">perspective</span>(.<span class="number">5em</span>) <span class="built_in">rotateX</span>(<span class="number">5deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对元素使用了 3D 变形之后，其内部的变形效应是“不可逆转”的。</li><li>所以唯一可行的途径就是把变形效果作用在伪元素上。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tab</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span> <span class="number">1em</span> .<span class="number">35em</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>; <span class="comment">/* 用伪元素来生成一个矩形 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1.3</span>) <span class="built_in">perspective</span>(.<span class="number">5em</span>)</span><br><span class="line">                <span class="built_in">rotateX</span>(<span class="number">5deg</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这段代码会给标签页添加图中的那些样式。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">                        <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">6</span>),</span><br><span class="line">                        <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>);</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: .<span class="number">5em</span> .<span class="number">5em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> .<span class="number">15em</span> white inset;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">perspective</span>(.<span class="number">5em</span>) <span class="built_in">rotateX</span>(<span class="number">5deg</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-8/pic1.png" class title="# tu1"><h1 id="十四、简单的饼图"><a href="#十四、简单的饼图" class="headerlink" title="十四、简单的饼图"></a>十四、简单的饼图</h1><h2 id="基于transform的解决方案"><a href="#基于transform的解决方案" class="headerlink" title="基于transform的解决方案"></a>基于transform的解决方案</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-8/pic2.png" class title="# tu1"><ul><li><strong>把圆形的左右两部分指定为上述两种颜色，然后用伪元素覆盖上去，通过旋转来决定露出多大的扇区。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(to right, transparent <span class="number">50%</span>, <span class="number">#655</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pie</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪元素现在相对于整个饼图进行了重叠。不过现在还没有设置任何样式，它还起不到遮盖的作用：暂时只是一个透明的矩形。在开始为它设置样式之前，我们还要再做一些观察和分析。<ul><li>我们希望它能遮盖圆形中的棕色部分，<strong>因此应该给它指定绿色背景</strong>。在这里使用 background-color: inherit 声明可以避免代码的重复，因为我们希望它的背景色与其宿主元素保持一致。</li><li>我们希望它是绕着圆形的圆心来旋转的，对它自己来说，这个点就是它左边缘的中心点。因此，我们应该把它的 transform-origin 设置为 0 50%，或者干脆写成 left。</li><li>我们不希望它呈现出矩形的形状，否则它会突破整个饼图的圆形范围。因此要么给 .pie 设置 overflow: hidden 的样式，要么给这个伪元素指定合适的 border-radius 属性来把它变成一个半圆。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(to right, transparent <span class="number">50%</span>, <span class="number">#655</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pie</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: inherit;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用虚线框表示伪元素覆盖位置。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-8/pic3.png" class title="# tu1"><ul><li>如果把 50%~100% 的比率看作另外一个问题，我们就会发现，可以使用上述技巧的一个反向版本来实现这个范围内的比率：设置一个棕色的伪元素，让它在 0 至 .5turn 的范围内旋转。因此，要得到一个 60% 比率的饼图，伪元素的代码可能是这样的：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(to right, transparent <span class="number">50%</span>, <span class="number">#655</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pie</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#655</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(.<span class="number">1turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 CSS 动画来实现一个饼图从 0 变化到 100% 的动画，从而得到一个炫酷的进度指示器：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(to right, transparent <span class="number">50%</span>, <span class="number">#655</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line"> <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(.<span class="number">5turn</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bg &#123;</span><br><span class="line"> <span class="number">50%</span> &#123; <span class="attribute">background</span>: <span class="number">#655</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pie</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: inherit;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">3s</span> linear infinite,</span><br><span class="line">                bg <span class="number">6s</span> step-end infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十三、梯形标签页&quot;&gt;&lt;a href=&quot;#十三、梯形标签页&quot; class=&quot;headerlink&quot; title=&quot;十三、梯形标签页&quot;&gt;&lt;/a&gt;十三、梯形标签页&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在 CSS 中用 3D 旋转来模拟出这个效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;figu</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（七）形状（三）</title>
    <link href="http://example.com/2022/01/10/css-7/"/>
    <id>http://example.com/2022/01/10/css-7/</id>
    <published>2022-01-10T09:28:57.000Z</published>
    <updated>2022-01-10T14:27:46.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十二、切角效果"><a href="#十二、切角效果" class="headerlink" title="十二、切角效果"></a>十二、切角效果</h1><ul><li>使用渐变来达到目的。</li><li>一个角使用一层渐变，两个角使用两层渐变，以此类推。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-7/pic1.png" class title="# tu1"><ul><li>左下角和右下角的切角效果。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) right,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">15px</span>, <span class="number">#655</span> <span class="number">0</span>) left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-7/pic2.png" class title="# tu1"><ul><li>四个角都切。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) top left,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">135deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) top right,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) bottom right,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) bottom left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-7/pic3.png" class title="# tu1"><ul><li>SCSS如下，可以直接调用，并传入2~5个参数。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> beveled-corners(<span class="variable">$bg</span>,<span class="variable">$tl</span>:<span class="number">0</span>, <span class="variable">$tr</span>:<span class="variable">$tl</span>, <span class="variable">$br</span>:<span class="variable">$tl</span>, <span class="variable">$bl</span>:<span class="variable">$tr</span>) &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$bg</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        linear-gradient(<span class="number">135deg</span>, transparent <span class="variable">$tl</span>, <span class="variable">$bg</span> <span class="number">0</span>)</span><br><span class="line">        top left,</span><br><span class="line">        linear-gradient(<span class="number">225deg</span>, transparent <span class="variable">$tr</span>, <span class="variable">$bg</span> <span class="number">0</span>)</span><br><span class="line">        top right,</span><br><span class="line">        linear-gradient(-<span class="number">45deg</span>, transparent <span class="variable">$br</span>, <span class="variable">$bg</span> <span class="number">0</span>)</span><br><span class="line">        bottom right,</span><br><span class="line">        linear-gradient(<span class="number">45deg</span>, transparent <span class="variable">$bl</span>, <span class="variable">$bg</span> <span class="number">0</span>)</span><br><span class="line">        bottom left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弧形切角"><a href="#弧形切角" class="headerlink" title="弧形切角"></a>弧形切角</h2><ul><li>使用径向渐变来替代上述线性渐变。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">radial-gradient</span>(circle at top left,transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) top left,</span><br><span class="line">        <span class="built_in">radial-gradient</span>(circle at top right,transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) top right,</span><br><span class="line">        <span class="built_in">radial-gradient</span>(circle at bottom right,transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) bottom right,</span><br><span class="line">        <span class="built_in">radial-gradient</span>(circle at bottom left,transparent <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>) bottom left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/10/css-7/pic4.png" class title="# tu1"><h2 id="内联SVG与border-image方案"><a href="#内联SVG与border-image方案" class="headerlink" title="内联SVG与border-image方案"></a>内联SVG与border-image方案</h2><p>略</p><h2 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(</span><br><span class="line">        <span class="number">20px</span> <span class="number">0</span>, <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>) <span class="number">0</span>, <span class="number">100%</span> <span class="number">20px</span>,</span><br><span class="line">        <span class="number">100%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>), <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>) <span class="number">100%</span>,<span class="number">20px</span> <span class="number">100%</span>, <span class="number">0</span> <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>), <span class="number">0</span> <span class="number">20px</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充方案"><a href="#补充方案" class="headerlink" title="补充方案"></a>补充方案</h2><ul><li>corner-shape属性。</li><li>为容器的四个角指定 15px 的斜面切角。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    corner-shape: bevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十二、切角效果&quot;&gt;&lt;a href=&quot;#十二、切角效果&quot; class=&quot;headerlink&quot; title=&quot;十二、切角效果&quot;&gt;&lt;/a&gt;十二、切角效果&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用渐变来达到目的。&lt;/li&gt;
&lt;li&gt;一个角使用一层渐变，两个角使用两层渐变，以此类推</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（五）形状（一）</title>
    <link href="http://example.com/2022/01/10/css-5/"/>
    <id>http://example.com/2022/01/10/css-5/</id>
    <published>2022-01-10T03:22:21.000Z</published>
    <updated>2022-01-10T08:21:00.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="九、自适应的椭圆"><a href="#九、自适应的椭圆" class="headerlink" title="九、自适应的椭圆"></a>九、自适应的椭圆</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><ul><li>如果它的宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆。</li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>border-radius：<strong>它可以单独指定水平和垂直半径，只要用一个斜杠（/）分隔这两个值即可</strong>。</li><li>同时，它不仅可以接受长度值，还可以接受百分比值。这个<br>百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="半椭圆"><a href="#半椭圆" class="headerlink" title="半椭圆"></a>半椭圆</h2><ul><li><p>border-radius是一个简写属性。我们可以为元素的每个角<br>指定不同的值，而且还有两种方法可以做到这一点。<strong>第一种方法就是使用它所对应的各个展开式属性：</strong></p><ul><li>border-top-left-radius</li><li>border-top-right-radius</li><li>border-bottom-right-radius</li><li>border-bottom-left-radius</li></ul></li><li><p>一次性提供用空格分开的多个值。</p><ul><li>如果我们传给它四个值，这四个值就会被分别从左上角开始以顺时针顺序应用到元素的各个拐角。</li><li>如果我们提供的值少于四个，则它们会以 CSS 的常规方式重复，类似于 border-width 的值。</li><li>如果只提供了三个值，则意味着第四个值与第二值相同；如果只有两个值，则意味着第三个值与第一个相同。</li><li>我们甚至可以为所有四个角提供完全不同的水平和垂直半径，方法是在斜杠前指定 1<del>4 个值，在斜杠后指定另外 1</del>4 个值。</li></ul></li><li><p>沿横轴劈开的上半椭圆：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>沿横轴劈开的下半椭圆：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>沿横轴劈开的左半椭圆：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span> / <span class="number">50%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>沿横轴劈开的右半椭圆：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">border-radius</span>:  <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span>/ <span class="number">50%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四分之一椭圆"><a href="#四分之一椭圆" class="headerlink" title="四分之一椭圆"></a>四分之一椭圆</h2><ul><li>其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;九、自适应的椭圆&quot;&gt;&lt;a href=&quot;#九、自适应的椭圆&quot; class=&quot;headerlink&quot; title=&quot;九、自适应的椭圆&quot;&gt;&lt;/a&gt;九、自适应的椭圆&lt;/h1&gt;&lt;h2 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（四）背景与边框（四）</title>
    <link href="http://example.com/2022/01/08/css-4/"/>
    <id>http://example.com/2022/01/08/css-4/</id>
    <published>2022-01-08T07:07:26.000Z</published>
    <updated>2022-01-10T03:17:49.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、伪随机背景"><a href="#七、伪随机背景" class="headerlink" title="七、伪随机背景"></a>七、伪随机背景</h1><ul><li><strong>通过质数来增加随机真实性</strong>。</li></ul><h2 id="1、问题提出"><a href="#1、问题提出" class="headerlink" title="1、问题提出"></a>1、问题提出</h2><ul><li><strong>自然界中的事物都不是以无限平铺的方式存在的。即使重复，也往往伴随着多样性和随机性。</strong></li><li>当你注意到一个有辨识度的特征（比如，木纹上的节疤）在以固定的规律循环重复时，那它试图营造的自然随机性就会立刻崩塌。</li><li>重现大自然的随机性是一个挑战，因为 CSS 本身没有提供任何随机功能。</li></ul><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><ul><li><strong>把这组条纹从一个平面拆散为多个图层：一种颜色作为底色，另三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺。</strong></li><li>操作步骤：<ul><li>创建指定宽度的条纹；</li><li>使用background-size来控制条纹的间距。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">20</span>, <span class="number">40%</span>, <span class="number">90%</span>);</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#fb3</span> <span class="number">10px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#ab4</span> <span class="number">20px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#655</span> <span class="number">20px</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">80px</span> <span class="number">100%</span>, <span class="number">60px</span> <span class="number">100%</span>, <span class="number">40px</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic1.png" class title="# tu1"><ul><li>因为最顶层贴片的重复规律最容易被察觉（它没有被任何东西遮挡），我们应该把平铺间距最大的贴片安排在最顶层。</li><li><strong>这个组合图案中第一个贴片的终点，就是各层背景图像以不同间距重复数次后再次统一对齐的点。</strong></li><li>因此，这里贴片的尺寸实际上就是所有 background-size 的最小公倍数，而 40、60 和 80的最小公倍数正是 240。</li><li><strong>为了让最小公倍数最大化，这些数字最好是“相对质数”。</strong></li><li>要达成相对质数，最简单的办法就是<strong>尽量选择质数</strong>，因为质数跟其他任意数字都是相对质数。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsl</span>(<span class="number">20</span>, <span class="number">40%</span>, <span class="number">90%</span>);</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#fb3</span> <span class="number">11px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#ab4</span> <span class="number">23px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#655</span> <span class="number">41px</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">41px</span> <span class="number">100%</span>, <span class="number">61px</span> <span class="number">100%</span>, <span class="number">83px</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic2.png" class title="# tu1"><h1 id="八、连续的图像边框"><a href="#八、连续的图像边框" class="headerlink" title="八、连续的图像边框"></a>八、连续的图像边框</h1><h2 id="1、提出问题"><a href="#1、提出问题" class="headerlink" title="1、提出问题"></a>1、提出问题</h2><ul><li>把一幅图案或图片应用为边框，而不是背景。</li><li>我们期望望出现在拐角处的图片区域是随着元素宽高和边框厚度的变化而变化的，并不想让图片的某个特定部分固定在拐角处。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic4.png" class title="# tu1"><ul><li><p>border-image 工作原理：</p><ul><li>九宫格伸缩法：把图片切割成九块，然后把它们应用到元素边框相应的边和角。<img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic3.png" class title="# tu1"></li></ul></li><li><p>最简单的办法是使用两个 HTML 元素：<strong>一个元素用来把我们的石雕图片设为背景，另一个元素用来存放内容，并设置纯白背景，然后覆盖在前者之上</strong>：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;something-meaningful&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        I have a nice stone art border,</span><br><span class="line">        don&#x27;t I look pretty?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.something-meaningful</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">stone-art.jpg</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.something-meaningful</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只用一个元素，我们能做到这个效果吗？</li></ul><h2 id="2、解决问题"><a href="#2、解决问题" class="headerlink" title="2、解决问题"></a>2、解决问题</h2><ul><li>主要思路：<strong>在石雕背景图片之上，再叠加一层纯白的实色背景。</strong></li><li>为了让下层的图片背景透过边框区域显示出来，我们需要给两层背景指定不同的 background-clip 值。</li><li>最后一个要点在于，我们只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的 CSS 渐变来模拟出纯白实色背景的效果。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;something-meaningful&quot;</span>&gt;</span></span><br><span class="line">    I have a nice stone art border,</span><br><span class="line">    don&#x27;t I look pretty?</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.something-meaningful</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(white, white),</span><br><span class="line">                <span class="built_in">url</span>(<span class="string">stone-art.jpg</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box, border-box;</span><br><span class="line">    <span class="attribute">background-origin</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这些新属性也是可以整合到 background 这个简写属性中的，这样可以显著地减少代码量：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.something-meaningful</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(white, white) padding-box,</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">stone-art.jpg</span>) border-box <span class="number">0</span> / cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个老式信封："><a href="#实现一个老式信封：" class="headerlink" title="实现一个老式信封："></a>实现一个老式信封：</h3><img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic5.png" class title="# tu1"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(white, white) padding-box,</span><br><span class="line">                <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line">                red <span class="number">0</span>, red <span class="number">12.5%</span>,</span><br><span class="line">                transparent <span class="number">0</span>, transparent <span class="number">25%</span>,</span><br><span class="line">                <span class="number">#58a</span> <span class="number">0</span>, <span class="number">#58a</span> <span class="number">37.5%</span>,</span><br><span class="line">                transparent <span class="number">0</span>, transparent <span class="number">50%</span>)</span><br><span class="line">                <span class="number">0</span> / <span class="number">5em</span> <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码讲解：</p></li><li><p>创建两层背景：</p><ul><li>linear-gradient(white, white) padding-box：用于创建第一层背景纯白色覆盖在最上层；</li><li>repeating-linear-gradient：用于创建重复线性梯度渐变。效果如下：<img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic6.png" class title="# tu1"></li></ul></li><li><p>repeating-linear-gradient中参数解释：</p><ul><li>-45deg：用于将整个条纹旋转-45度；</li><li>red 0,red 12%：从0~12.5%位置均为红色；</li><li>transparent 0, transparent 25%：从上次的最大位置至25%的位置均为透明；</li><li>#58a 0, #58a 37.5%：从上次的最大位置至37.5%的位置均为#58；</li><li>transparent 0, transparent 50%：从上次的最大位置至50%的位置均为透明。</li></ul></li><li><p>0/ ：background-position的值为0 0。</p></li><li><p>5em 5em：background-size大小。</p></li></ul><h3 id="蚂蚁行军效果"><a href="#蚂蚁行军效果" class="headerlink" title="蚂蚁行军效果"></a>蚂蚁行军效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> ants &#123; <span class="selector-tag">to</span> &#123; <span class="attribute">background-position</span>: <span class="number">100%</span> &#125; &#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(white, white) padding-box,</span><br><span class="line">        <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line">            black <span class="number">0</span>, black <span class="number">25%</span>, white <span class="number">0</span>, white <span class="number">50%</span></span><br><span class="line">        ) <span class="number">0</span> / .<span class="number">6em</span> .<span class="number">6em</span>;</span><br><span class="line">    <span class="attribute">animation</span>: ants <span class="number">12s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/08/css-4/pic7.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、伪随机背景&quot;&gt;&lt;a href=&quot;#七、伪随机背景&quot; class=&quot;headerlink&quot; title=&quot;七、伪随机背景&quot;&gt;&lt;/a&gt;七、伪随机背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通过质数来增加随机真实性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（三）背景与边框（三）</title>
    <link href="http://example.com/2022/01/04/css-3/"/>
    <id>http://example.com/2022/01/04/css-3/</id>
    <published>2022-01-04T15:24:19.000Z</published>
    <updated>2022-01-08T07:27:16.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、复杂的背景图案"><a href="#六、复杂的背景图案" class="headerlink" title="六、复杂的背景图案"></a>六、复杂的背景图案</h1><ul><li><strong>水平渐变图案跟垂直渐变图案配合实现简单的蓝图网格图案。</strong></li></ul><h2 id="0、知识点"><a href="#0、知识点" class="headerlink" title="0、知识点"></a>0、知识点</h2><ul><li>linear-gradient(direction, color-stop1 position, color-stop2  position, …)：<ul><li>用于创建一个表示两种或多种颜色线性渐变的图片。</li><li>direction：用角度值指定渐变的方向（或角度）。</li><li>color-stop1, color-stop2,…：用于指定渐变的起止颜色。</li></ul></li><li>radial-gradient</li><li>repeating-linear-gradient</li><li>repeating-radial-gradient</li></ul><h2 id="1、网格"><a href="#1、网格" class="headerlink" title="1、网格"></a>1、网格</h2><ul><li><strong>把多个渐变图案组合起来，将其透过彼此的透明区域显现。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,</span><br><span class="line">                    <span class="built_in">rgba</span>(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>) <span class="number">50%</span>, transparent <span class="number">0</span>),</span><br><span class="line">                <span class="built_in">linear-gradient</span>(</span><br><span class="line">                    <span class="built_in">rgba</span>(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>) <span class="number">50%</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic1.png" class title="# tu1"><ul><li><strong>网格中每个格子的大小可以调整，而网格线条的粗细同时保持固定。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(white <span class="number">1px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, white <span class="number">1px</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic2.png" class title="# tu1"><ul><li><strong>把两幅不同线宽、不同颜色的网格图案叠加起来，得到一个更加逼真的蓝图网格。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(white <span class="number">2px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, white <span class="number">2px</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>) <span class="number">1px</span>,transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>) <span class="number">1px</span>,transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">75px</span> <span class="number">75px</span>, <span class="number">75px</span> <span class="number">75px</span>,</span><br><span class="line">    <span class="number">15px</span> <span class="number">15px</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic3.png" class title="# tu1"><h2 id="2、波点"><a href="#2、波点" class="headerlink" title="2、波点"></a>2、波点</h2><ul><li><strong>径向渐变创建最简单的圆点的阵列。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#655</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(tan <span class="number">30%</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic4.png" class title="# tu1"><ul><li><strong>通过两层圆点阵列图案的错位排列可以实现真正的波点图案，第二个背景图片的偏移量正好等于贴片宽高的一半。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#655</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: </span><br><span class="line">        <span class="built_in">radial-gradient</span>(tan <span class="number">30%</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">radial-gradient</span>(tan <span class="number">30%</span>, transparent <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic5.png" class title="# tu1"><h2 id="3、棋盘"><a href="#3、棋盘" class="headerlink" title="3、棋盘"></a>3、棋盘</h2><ul><li>棋盘图案是可以通过平铺生成的，平铺成这个图案的典型贴片包含两种不同颜色的方块，且相互间隔。</li><li>实现技巧在于用两个直角三角形来拼合出一个方块。</li><li>创建直角三角形渐变。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, <span class="number">#bbb</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic5.png" class title="# tu1"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="number">#bbb</span> <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, <span class="number">#bbb</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic6.png" class title="# tu1"><ul><li>把第二层渐变在水平和垂直方向均移动贴片长度的一半，把它们拼合成一个完整的方块。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="number">#bbb</span> <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, <span class="number">#bbb</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic7.png" class title="# tu1"><ul><li>要把现有的这一组渐变重复一份，创建出另一组正方形，并且偏移它们的定位值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="number">#bbb</span> <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, <span class="number">#bbb</span> <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="number">#bbb</span> <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, <span class="number">#bbb</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>,</span><br><span class="line">                        <span class="number">15px</span> <span class="number">15px</span>, <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic8.png" class title="# tu1"><ul><li>以把深灰色改成半透明的黑色，这样我们只需要修改底色就可以改变整个棋盘的色调，不需要单独调整各层渐变的色标了。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>) <span class="number">25%</span>, transparent <span class="number">0</span>,</span><br><span class="line">        transparent <span class="number">75%</span>, <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>) <span class="number">0</span>),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>) <span class="number">25%</span>, transparent <span class="number">0</span>,</span><br><span class="line">        transparent <span class="number">75%</span>, <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/04/css-3/pic9.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、复杂的背景图案&quot;&gt;&lt;a href=&quot;#六、复杂的背景图案&quot; class=&quot;headerlink&quot; title=&quot;六、复杂的背景图案&quot;&gt;&lt;/a&gt;六、复杂的背景图案&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平渐变图案跟垂直渐变图案配合实现简单的蓝图网格图案。&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（二）背景与边框（二）</title>
    <link href="http://example.com/2022/01/03/css-2/"/>
    <id>http://example.com/2022/01/03/css-2/</id>
    <published>2022-01-02T16:37:52.000Z</published>
    <updated>2022-01-08T07:26:47.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、条纹背景"><a href="#五、条纹背景" class="headerlink" title="五、条纹背景"></a>五、条纹背景</h1><h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><ul><li>不论是在网页设计中，还是在其他传统媒介中（比如杂志和墙纸等），各种尺寸、颜色、角度的条纹图案在视觉设计中无处不在。</li><li>要想在网页中实现条纹图案，其过程还远远不够理想。通常，我们的方法是创建一个单独的位图文件，然后每次需要做些调整时，都用图像编辑器来修改它。</li><li>可能有人试过用 SVG 来取代位图，但这样还是会有一个独立的文件，而且它的语法也远远不够友好。</li><li>如果可以直接在 CSS 中创建条纹图案，那该有多棒啊！你可能会惊讶地发现，我们居然真的可以。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>假设我们有一条基本的垂直线性渐变，颜色从 #fb3 过渡到 #58a。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span>, <span class="number">#58a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic1.png" class title="# tu1"><ul><li>现在，让我们试着把这两个色标拉近一点。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">20%</span>, <span class="number">#58a</span> <span class="number">80%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic1.png" class title="# tu1"><ul><li>现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被填充为 #58a 实色。<strong>真正的渐变只出现在容器 60% 的高度区域</strong>。</li><li>如果我们把两个色标继续拉近（分别改为 40% 和 60%），那真正的渐变区域就变得更窄了。</li><li><strong>如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。</strong>从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">50%</span>, <span class="number">#58a</span> <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>因为渐变是一种由代码生成的图像，我们能像对待其他任何背景图像那样对待它，而且还可以通过 background-size 来调整其尺寸。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">50%</span>, <span class="number">#58a</span> <span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic3.png" class title="# tu1"><ul><li>我们还可以用相同的方法来创建不等宽的条纹，只需调整色标的位置值即可。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">30%</span>, <span class="number">#58a</span> <span class="number">30%</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic4.png" class title="# tu1"><ul><li>为了避免每次改动条纹宽度时都要修改两个数字，我们可以再次从规范那里找到捷径。<ul><li><strong>如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值</strong>。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">30%</span>, <span class="number">#58a</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果要创建超过两种颜色的条纹，也是很容易的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#fb3</span> <span class="number">33.3%</span>,<span class="number">#58a</span> <span class="number">0</span>, <span class="number">#58a</span> <span class="number">66.6%</span>, yellowgreen <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">45px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic5.png" class title="# tu1"><h2 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h2><ul><li>垂直条纹的代码跟水平条纹几乎是一样的，差别主要在于：<strong>我们需要在开头加上一个额外的参数来指定渐变的方向。</strong></li><li>在水平条纹的代码中，我们其实也可以加上这个参数，只不过它的默认值 to bottom 本来就跟我们的意图一致，于是就省略了。</li><li>最后，我们还需要把 background-size 的值颠倒一下。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, /* 或 <span class="number">90deg</span> */<span class="number">#fb3</span> <span class="number">50%</span>, <span class="number">#58a</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic6.png" class title="# tu1"><h2 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h2><ul><li>如果我们再次改变 background-size 的值和渐变的方向，是不是就可以得到斜向（比如45°）的条纹图案。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>,<span class="number">#fb3</span> <span class="number">50%</span>, <span class="number">#58a</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic7.png" class title="# tu1"><ul><li>这个办法行不通。原因在于我们<strong>只是把每个“贴片”内部的渐变旋转了 45°，而不是把整个重复的背景都旋转了</strong>。</li><li>单个贴片包含了四条条纹，而不是两条，只有这样才有可能做到无缝拼接它正是我们需要在 CSS 代码中重新实现的贴片，因此我们需要增加一些色标。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>,</span><br><span class="line">                <span class="number">#fb3</span> <span class="number">25%</span>, <span class="number">#58a</span> <span class="number">0</span>, <span class="number">#58a</span> <span class="number">50%</span>,</span><br><span class="line">                <span class="number">#fb3</span> <span class="number">0</span>, <span class="number">#fb3</span> <span class="number">75%</span>, <span class="number">#58a</span> <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic8.png" class title="# tu1"><h2 id="更好的斜向条纹"><a href="#更好的斜向条纹" class="headerlink" title="更好的斜向条纹"></a>更好的斜向条纹</h2><ul><li>设置任意角度倾斜：<ul><li>repeating-gradient()和repeating-radial-gradient()方法。</li><li><strong>色标是无限循环重复的，直到填满整个背景</strong>。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(<span class="number">45deg</span>,<span class="number">#fb3</span>, <span class="number">#58a</span> <span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic9.png" class title="# tu1"><ul><li>将斜向45°条纹修改为60°。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(<span class="number">60deg</span>,<span class="number">#fb3</span>, <span class="number">#fb3</span> <span class="number">15px</span>, <span class="number">#58a</span> <span class="number">0</span>, <span class="number">#58a</span> <span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic10.png" class title="# tu1"><h2 id="灵活的同色系条纹"><a href="#灵活的同色系条纹" class="headerlink" title="灵活的同色系条纹"></a>灵活的同色系条纹</h2><ul><li>不再为每种条纹单独指定颜色，而是把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(<span class="number">30deg</span>,</span><br><span class="line">                    <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">1</span>),</span><br><span class="line">                    <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">1</span>) <span class="number">15px</span>,</span><br><span class="line">                    transparent <span class="number">0</span>, transparent <span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2022/01/03/css-2/pic11.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、条纹背景&quot;&gt;&lt;a href=&quot;#五、条纹背景&quot; class=&quot;headerlink&quot; title=&quot;五、条纹背景&quot;&gt;&lt;/a&gt;五、条纹背景&lt;/h1&gt;&lt;h2 id=&quot;难题&quot;&gt;&lt;a href=&quot;#难题&quot; class=&quot;headerlink&quot; title=&quot;难题&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（一）背景与边框（一）</title>
    <link href="http://example.com/2021/12/30/css-1/"/>
    <id>http://example.com/2021/12/30/css-1/</id>
    <published>2021-12-30T08:41:09.000Z</published>
    <updated>2022-01-02T16:36:10.905Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">78</span>, <span class="number">78</span>, <span class="number">85</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        #pic&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;pic&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="一、半透明边框"><a href="#一、半透明边框" class="headerlink" title="一、半透明边框"></a>一、半透明边框</h1><ul><li><p>假设给一个容器设置一层白色背景和一道半透明的边框。body的背景会从它的半透明边框透上来。</p></li><li><p>该代码会得到以下效果：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">5</span>);</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic1.png" class title="# tu1"><ul><li>通过background-clip属性来指定背景绘制区域。<ul><li>background-clip属性默认值为border-box：背景绘制在边框方框内。</li><li>padding-box：将背景绘制在衬距方框内。</li></ul></li></ul><h1 id="二、多重边框"><a href="#二、多重边框" class="headerlink" title="二、多重边框"></a>二、多重边框</h1><h2 id="1、box-shadow方案"><a href="#1、box-shadow方案" class="headerlink" title="1、box-shadow方案"></a>1、box-shadow方案</h2><ul><li><strong>利用box-shadow的第四个参数指定正值或负值来让投影面积加大或减小</strong>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#655</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic2.png" class title="# tu1"><ul><li><strong>box-shadow支持逗号分隔语法，可以创建任意数量的投影。</strong></li><li>box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#655</span>, <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic3.png" class title="# tu1"><h2 id="2、outline方案"><a href="#2、outline方案" class="headerlink" title="2、outline方案"></a>2、outline方案</h2><ul><li>用于设置两层边框：先设置一层常规边框，再加上outline属性来产生外层的边框。</li><li><strong>优点：在于边框样式十分灵活，不像box-shadow方案只能模拟实线边框。</strong></li><li>以下代码也可以实现上图效果。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#655</span>;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">5px</span> solid deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、灵活的背景定位"><a href="#三、灵活的背景定位" class="headerlink" title="三、灵活的背景定位"></a>三、灵活的背景定位</h1><ul><li><strong>难题：</strong><ul><li>针对某个角对背景图片做偏移定位。</li><li>在CSS 2.1中，我们只能指定距离左上角的偏移量，或者干脆完全靠齐到其他三个角。如下图：</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic4.png" class title="# tu1"><h2 id="1、background-position的扩展语法方案"><a href="#1、background-position的扩展语法方案" class="headerlink" title="1、background-position的扩展语法方案"></a>1、background-position的扩展语法方案</h2><ul><li><strong>background-position属性得到扩展：</strong><ul><li><strong>允许我们指定背景图片距离任意角的偏移量</strong>；</li><li><strong>只需要在偏移量前面指定关键字</strong>。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">code-pirate.svg</span>) no-repeat <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: right <span class="number">20px</span> bottom <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic5.png" class title="# tu1"><ul><li>在不支持background-position扩展语法的浏览器中，背景图片会紧贴在左上角（背景图片的默认位置）。</li><li>提供一个回退方案也很简单，就是把老套的bottom right 定位值写进 background 的简写属性中</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">code-pirate.svg</span>)</span><br><span class="line">                no-repeat bottom right <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: right <span class="number">20px</span> bottom <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，background-position是以padding box为准，这样边框才不会遮住背景图片。</li></ul><h2 id="2、background-origin方案"><a href="#2、background-origin方案" class="headerlink" title="2、background-origin方案"></a>2、background-origin方案</h2><ul><li>background-origin默认情况下，它的值是padding-box。</li><li>如果把它的值改成 content-box ，我们在 background-position 属性中使用的边角关键字将会以内容区的边缘作为基准。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">code-pirate.svg</span>)</span><br><span class="line">                no-repeat bottom right <span class="number">#58a</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: right <span class="number">20px</span> bottom <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>视觉效果同上。</li></ul><h2 id="3、calc-方案"><a href="#3、calc-方案" class="headerlink" title="3、calc()方案"></a>3、calc()方案</h2><ul><li>如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。</li><li>calc()函数允许我们执行此类运算，它可以完美地在background-position 属性中使用。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pic</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;code-pirate.svg&quot;</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>) <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、边框内圆角"><a href="#四、边框内圆角" class="headerlink" title="四、边框内圆角"></a>四、边框内圆角</h1><ul><li>有时我们需要一个容器，<strong>只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状</strong>，如图下所示。这是一个有趣的效果，目前还没有被滥用。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic6.png" class title="# tu1"><ul><li>用两个元素可以实现这个效果，这并没有什么特别的。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/30/css-1/pic7.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS学习" scheme="http://example.com/tags/CSS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十八）网络请求与远程资源（四）</title>
    <link href="http://example.com/2021/12/30/js-51/"/>
    <id>http://example.com/2021/12/30/js-51/</id>
    <published>2021-12-29T16:06:09.000Z</published>
    <updated>2021-12-29T17:41:31.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><ul><li>Web Socket (套接字)的目标是通过一个长时连接实现与服务器全双工、双向的通信。</li></ul><h2 id="1、API"><a href="#1、API" class="headerlink" title="1、API"></a>1、API</h2><ul><li>要创建一个新的WebSocket，就要实例化一个WebSocket对象并传人提供连接的URL。</li><li>必须给WebSocket构造函数传人一个绝对URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>同源策略不适用于Web Socket，因此可以打开到任意站点的连接。</strong></li><li>至于是否与来自特定源的页面通信，则完全取决于服务器。(在握手阶段就可以确定请求来自哪里。)</li><li><strong>浏览器会在初始化WebSocket对象之后立即创建连接。</strong></li><li>与XHR类似，WebSocket也有一个readyState属性表示当前状态。不过，这个值与XHR中相应的值不一样。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/30/js-51/pic1.png" class title="# tu1"><ul><li><strong>WebSocket对象没有readystatechange 事件，而是有与上述不同状态对应的其他事件。</strong>readyState值从0开始。</li><li>任何时候都可以调用close()方法关闭Web Socket连接，调用close()之后，readyState立即变为2 (连接正在关闭),并会在关闭后变为3 (连接已经关闭)。</li></ul><h2 id="2、发送和接收数据"><a href="#2、发送和接收数据" class="headerlink" title="2、发送和接收数据"></a>2、发送和接收数据</h2><ul><li>打开Web Socket之后，可以通过连接发送和接收数据。</li><li><strong>要向服务器发送数据，使用send()方法并传入一个字符串、ArrayBuffer或Blob。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> stringData = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> arrayBufferData = <span class="built_in">Uint8Array</span>.from([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]); </span><br><span class="line"><span class="keyword">let</span> blobData = <span class="keyword">new</span> Blob([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]); </span><br><span class="line">socket.send(stringData); </span><br><span class="line">socket.send(arrayBufferData.buffer); </span><br><span class="line">socket.send(blobData);</span><br></pre></td></tr></table></figure><ul><li>服务器向客户端发送消息时，WebSocket 对象上会触发message事件。这个message事件与其他消息协议类似，可以通过event.data属性访问到有效载荷。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> data = event.data; </span><br><span class="line">    <span class="comment">// 对数据执行某些操作</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>与通过send()方法发送的数据类似，event.data返回的数据也可能是ArrayBuffer或Blob。这由WebSocket对象的binaryType属性决定，该属性可能是”blob”或” arraybuffer”。</li></ul><h2 id="3、其他事件"><a href="#3、其他事件" class="headerlink" title="3、其他事件"></a>3、其他事件</h2><ul><li>open：在连接成功建立时触发。</li><li>error：在发生错误时触发。连接无法存续。</li><li>close：在连接关闭时触发。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>); </span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> alert(<span class="string">&quot;Connection established.&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> alert(<span class="string">&quot;Connection error.&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> alert(<span class="string">&quot;Connection closed.&quot;</span>); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web-Socket&quot;&gt;&lt;a href=&quot;#Web-Socket&quot; class=&quot;headerlink&quot; title=&quot;Web Socket&quot;&gt;&lt;/a&gt;Web Socket&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Web Socket (套接字)的目标是通过一个长时连接实现与服</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Web Socket" scheme="http://example.com/categories/Web-Socket/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十八）网络请求与远程资源（三）</title>
    <link href="http://example.com/2021/12/25/js-50/"/>
    <id>http://example.com/2021/12/25/js-50/</id>
    <published>2021-12-25T12:05:11.000Z</published>
    <updated>2021-12-29T16:02:28.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Fetch-API"><a href="#五、Fetch-API" class="headerlink" title="五、Fetch API"></a>五、Fetch API</h1><ul><li>Fetch API则必须是异步</li></ul><h2 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h2><ul><li>fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。</li></ul><h3 id="1）分派请求"><a href="#1）分派请求" class="headerlink" title="1）分派请求"></a>1）分派请求</h3><ul><li><strong>fetch()只有一个必需的参数input</strong>。多数情况下，这个参数是要获取资源的URL。</li><li><strong>这个方法返回一个期约</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = fetch(<span class="string">&#x27;/bar&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>请求完成、资源可用时，期约会解决为一个Response对象</strong>。</li><li>这个对象是API的封装，可以通过它取得相应资源。<strong>获取资源要使用这个对象的属性和方法</strong>，掌握响应的情况并将负载转换为有用的形式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;bar.txt&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// Response &#123; type: &quot;basic&quot;, url: ... &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、读取响应"><a href="#2、读取响应" class="headerlink" title="2、读取响应"></a>2、读取响应</h3><ul><li>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。<ul><li>这个方法返回一个期约，会解决为取得资源的完整内容。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;bar.txt&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">        response.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(data); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure><ul><li>内容的结构通常是打平的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;bar.txt&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.text()) </span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data)); </span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3）处理状态码和请求失败"><a href="#3）处理状态码和请求失败" class="headerlink" title="3）处理状态码和请求失败"></a>3）处理状态码和请求失败</h3><ul><li>Fetch API支持通过Response的status ( 状态码)和statusText (状态文本)属性检查响应状态。</li><li><strong>成功获取响应的请求通常会产生值为200的状态码</strong>。</li><li><strong>请求不存在的资源通常会产生值为 404 的状态码</strong>。</li><li><strong>请求的 URL 如果抛出服务器错误会产生值为 500 的状态码</strong>。</li><li>只要服务器返回了响应，fetch()期约都会解决。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/bar&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.status); <span class="comment">// 200 </span></span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText); <span class="comment">// OK </span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><ul><li>通常状态码为200时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非200-299时检查Response对象的ok属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/bar&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.status); <span class="comment">// 200 </span></span><br><span class="line">    <span class="built_in">console</span>.log(response.ok); <span class="comment">// true </span></span><br><span class="line"> &#125;); </span><br><span class="line">fetch(<span class="string">&#x27;/does-not-exist&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.status); <span class="comment">// 404 </span></span><br><span class="line">    <span class="built_in">console</span>.log(response.ok); <span class="comment">// false </span></span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure><ul><li><strong>违反CORS、无网络连接、HTTPS错配及其他浏览器/网络策略问题都会导致期约被拒绝</strong>。</li><li>可以通过url属性检查通过fetch()发送请求时使用的完整URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.com/bar/baz 发送的请求</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.href); <span class="comment">// https://foo.com/bar/baz </span></span><br><span class="line">fetch(<span class="string">&#x27;qux&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response.url)); </span><br><span class="line"><span class="comment">// https://foo.com/bar/qux</span></span><br><span class="line">fetch(<span class="string">&#x27;/qux&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response.url)); </span><br><span class="line"><span class="comment">// https://foo.com/qux</span></span><br><span class="line">fetch(<span class="string">&#x27;//qux.com&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response.url)); </span><br><span class="line"><span class="comment">// https://qux.com</span></span><br><span class="line">fetch(<span class="string">&#x27;https://qux.com&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response.url)); </span><br><span class="line"><span class="comment">// https://qux.com</span></span><br></pre></td></tr></table></figure><h3 id="4）自定义选项"><a href="#4）自定义选项" class="headerlink" title="4）自定义选项"></a>4）自定义选项</h3><ul><li>只使用URL时，fetch()会发送GET请求，只包含最低限度的请求头。</li><li>要进一步配置如何发送请求，需要传入可选的第二个参数init对象。</li></ul><h2 id="2、常见Fetch请求模式"><a href="#2、常见Fetch请求模式" class="headerlink" title="2、常见Fetch请求模式"></a>2、常见Fetch请求模式</h2><h3 id="1）发送JSON数据"><a href="#1）发送JSON数据" class="headerlink" title="1）发送JSON数据"></a>1）发送JSON数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="built_in">JSON</span>.stringify(&#123; </span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> Headers(&#123; </span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line">fetch(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123; </span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line">    body: payload, </span><br><span class="line">    headers: jsonHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2）在请求体中发送参数"><a href="#2）在请求体中发送参数" class="headerlink" title="2）在请求体中发送参数"></a>2）在请求体中发送参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> Headers(&#123; </span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line">fetch(<span class="string">&#x27;/send-me-params&#x27;</span>, &#123; </span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line">    body: payload, </span><br><span class="line">    headers: paramHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3）发送文件"><a href="#3）发送文件" class="headerlink" title="3）发送文件"></a>3）发送文件</h3><ul><li>因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> FormData(); </span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>); </span><br><span class="line">imageFormData.append(<span class="string">&#x27;image&#x27;</span>, imageInput.files[<span class="number">0</span>]); </span><br><span class="line">fetch(<span class="string">&#x27;/img-upload&#x27;</span>, &#123; </span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line">    body: imageFormData </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4）加载Blob文件"><a href="#4）加载Blob文件" class="headerlink" title="4）加载Blob文件"></a>4）加载Blob文件</h3><ul><li>Fetch API也能提供Blob类型的响应，而Blob又可以兼容多种浏览器API。</li><li>可以使用响应对象上暴露的blob()方法。<ul><li>方法返回一个期约，解决为一个Blob的实例。可以将这个实例传给URL.create0bjectUrl()以生成可以添加给图片元素src属性的值。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imageElement = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>); </span><br><span class="line">fetch(<span class="string">&#x27;my-image.png&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.blob()) </span><br><span class="line">    .then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123; </span><br><span class="line">        imageElement.src = URL.createObjectURL(blob); </span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure><h3 id="5）发送跨源请求"><a href="#5）发送跨源请求" class="headerlink" title="5）发送跨源请求"></a>5）发送跨源请求</h3><ul><li>从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;//cross-origin.com&#x27;</span>); </span><br><span class="line"><span class="comment">// TypeError: Failed to fetch </span></span><br><span class="line"><span class="comment">// No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. </span></span><br></pre></td></tr></table></figure><ul><li>如果代码不需要访问响应，也可以发送no-cors请求。此时响应的type属性值为opaque，因此无法读取相应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;//cross-origin.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;no-cors&#x27;</span> &#125;) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response.type)); </span><br><span class="line"><span class="comment">// opaque</span></span><br></pre></td></tr></table></figure><h3 id="6）中断请求"><a href="#6）中断请求" class="headerlink" title="6）中断请求"></a>6）中断请求</h3><ul><li>Fetch API支持通过AbortController/AbortSignal 对中断请求。</li><li>调用AbortController.abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。</li><li>中断进行中的fetch()请求会导致包含错误的拒绝。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abortController = <span class="keyword">new</span> AbortController(); </span><br><span class="line">fetch(<span class="string">&#x27;wikipedia.zip&#x27;</span>, &#123; <span class="attr">signal</span>: abortController.signal &#125;) </span><br><span class="line">    .catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;aborted!&#x27;</span>); </span><br><span class="line"><span class="comment">// 10 毫秒后中断请求</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> abortController.abort(), <span class="number">10</span>); </span><br><span class="line"><span class="comment">// 已经中断</span></span><br></pre></td></tr></table></figure><h2 id="3、Headers对象"><a href="#3、Headers对象" class="headerlink" title="3、Headers对象"></a>3、Headers对象</h2><ul><li><strong>Headers对象是所有外发请求和入站响应头部的容器</strong>。</li><li>每个外发的Request实例都包含一个空的Headers实例，可以通过Request.prototype.headers 访问，每个入站Response实例也可以通过Response.prototype.headers访问包含着响应头部的Headers对象。<strong>这两个属性都是可修改属性</strong>。</li><li><strong>使用new Headers()也可以创建一个新实例。</strong></li></ul><h3 id="1）Headers与Map的相似之处"><a href="#1）Headers与Map的相似之处" class="headerlink" title="1）Headers与Map的相似之处"></a>1）Headers与Map的相似之处</h3><ul><li>因为HTTP头部本质上是<strong>序列化后的键/值对，它们的JavaScript表示则是中间接口</strong>。</li><li>Headers与Map类型都有get()、set()、has()和delete()等实例方法。</li><li>Headers和Map都可以使用一个可迭代对象来初始化。</li><li>都有相同的keys()、values()和entries()迭代器接口。</li></ul><h3 id="2）Headers独有的特性"><a href="#2）Headers独有的特性" class="headerlink" title="2）Headers独有的特性"></a>2）Headers独有的特性</h3><p>1、 在初始化Headers对象时，可以使用键/值对形式的对象，而Map不可以。<br>2、 Headers对象通过append()方法支持添加多个值。在Headers实例中还不存在的头部上调用append()方法相当于调用set ()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seed = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Headers(seed); </span><br><span class="line"><span class="built_in">console</span>.log(h.get(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(seed); </span><br><span class="line"><span class="comment">// TypeError: object is not iterable </span></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Headers(); </span><br><span class="line">h.append(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(h.get(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar&quot;</span></span><br><span class="line">h.append(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(h.get(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar, baz&quot; </span></span><br></pre></td></tr></table></figure><h3 id="3）头部护卫"><a href="#3）头部护卫" class="headerlink" title="3）头部护卫"></a>3）头部护卫</h3><ul><li>Headers对象使用护卫来防止不被允许的修改。</li><li>不同的护卫设置会改变set()、append()和 delete()的行为。违反护卫限制会抛出TypeError。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/25/js-50/pic1.png" class title="# tu1"><h2 id="4、Request对象"><a href="#4、Request对象" class="headerlink" title="4、Request对象"></a>4、Request对象</h2><ul><li>Request对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。</li></ul><h3 id="1）创建Request对象"><a href="#1）创建Request对象" class="headerlink" title="1）创建Request对象"></a>1）创建Request对象</h3><ul><li>通过构造函数初始化Request对象，为此需要传入一个input参数，一般是URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(r); </span><br><span class="line"><span class="comment">// Request &#123;...&#125; </span></span><br></pre></td></tr></table></figure><ul><li>Request构造函数也接收第二个参数一个 init 对象。</li><li>没有在init对象中涉及的值则会使用默认值。</li></ul><h3 id="2）克隆Request对象"><a href="#2）克隆Request对象" class="headerlink" title="2）克隆Request对象"></a>2）克隆Request对象</h3><ul><li>Fetch API提供了两种不太一样的方式用于创建Request对象的副本：<ul><li>使用Request构造函数；</li><li>使用clone()方法。</li></ul></li><li>将Request实例作为input参数传给Request构造函数，会得到该请求的一个副本：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1); </span><br><span class="line"><span class="built_in">console</span>.log(r2.url); <span class="comment">// https://foo.com/ </span></span><br></pre></td></tr></table></figure><ul><li>如果再传入init对象，则init对象的值会覆盖源对象中同名的值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1, &#123;<span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(r1.method); <span class="comment">// GET</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.method); <span class="comment">// POST </span></span><br></pre></td></tr></table></figure><ul><li><strong>这种克隆方式并不总能得到一模一样的副本</strong>。最明显的是，第一个请求的请求体会被标记为“已使用”：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1); </span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyUsed); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.bodyUsed); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>第二种克隆Request对象的方式是使用clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。</li><li>与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”。</li><li><strong>如果请求对象的bodyUsed属性为true (即请求体已被读取),那么上述任何一种方式都不能用来创建这个对象的副本</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">let</span> r2 = r1.clone(); </span><br><span class="line"><span class="built_in">console</span>.log(r1.url); <span class="comment">// https://foo.com/ </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.url); <span class="comment">// https://foo.com/ </span></span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyUsed); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.bodyUsed); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="3）在fetch-中使用Request对象"><a href="#3）在fetch-中使用Request对象" class="headerlink" title="3）在fetch()中使用Request对象"></a>3）在fetch()中使用Request对象</h3><ul><li>在调用fetch()时，可以传入已经创建好的Request实例而不是URL。</li><li>fetch()会在内部克隆传入的Requeat对象。</li><li>fetch()也不能拿请求体已经用过的Request对象来发送请求。</li><li><strong>有请求体的Request只能在一次fetch中使用</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="comment">// 向 foo.com 发送 GET 请求</span></span><br><span class="line">fetch(r); </span><br><span class="line"><span class="comment">// 向 foo.com 发送 POST 请求</span></span><br><span class="line">fetch(r, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;); </span><br></pre></td></tr></table></figure><ul><li>要想基于包含请求体的相同Request对象多次调用fetch(),必须在第一次发送fetch()请求前调用clone()。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// 3 个都会成功</span></span><br><span class="line">fetch(r.clone()); </span><br><span class="line">fetch(r.clone()); </span><br><span class="line">fetch(r); </span><br></pre></td></tr></table></figure><h2 id="5、Response对象"><a href="#5、Response对象" class="headerlink" title="5、Response对象"></a>5、Response对象</h2><ul><li><strong>Response 对象是获取资源响应的接口</strong>。</li><li><strong>这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式</strong>。</li></ul><h3 id="1）创建Response对象"><a href="#1）创建Response对象" class="headerlink" title="1）创建Response对象"></a>1）创建Response对象</h3><ul><li>可以通过构造函数初始化Response对象且不需要参数。</li><li>此时响应实例的属性均为默认值，因为它并不代表实际的HTTP响应。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Response(); </span><br><span class="line"><span class="built_in">console</span>.log(r); </span><br><span class="line"><span class="comment">/*Response &#123; </span></span><br><span class="line"><span class="comment">    body: (...) </span></span><br><span class="line"><span class="comment">    bodyUsed: false </span></span><br><span class="line"><span class="comment">    headers: Headers &#123;&#125; </span></span><br><span class="line"><span class="comment">    ok: true </span></span><br><span class="line"><span class="comment">    redirected: false </span></span><br><span class="line"><span class="comment">    status: 200 </span></span><br><span class="line"><span class="comment">    statusText: &quot;OK&quot; </span></span><br><span class="line"><span class="comment">    type: &quot;default&quot; </span></span><br><span class="line"><span class="comment">    url: &quot;&quot; </span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure><ul><li>Response构造函数接收一个可选的body参数。<ul><li>这个body可以是null，等同于fetch()参数init中的body。</li></ul></li><li>还可以接收一个可选的init对象，这个对象可以包含下表所列的键和值。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/25/js-50/pic2.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Response(<span class="string">&#x27;foobar&#x27;</span>, &#123; </span><br><span class="line">    status: <span class="number">418</span>, </span><br><span class="line">    statusText: <span class="string">&#x27;I\&#x27;m a teapot&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(r); </span><br><span class="line"><span class="comment">/*Response &#123; </span></span><br><span class="line"><span class="comment">    body: (...) </span></span><br><span class="line"><span class="comment">    bodyUsed: false </span></span><br><span class="line"><span class="comment">    headers: Headers &#123;&#125; </span></span><br><span class="line"><span class="comment">    ok: false </span></span><br><span class="line"><span class="comment">    redirected: false </span></span><br><span class="line"><span class="comment">    status: 418</span></span><br><span class="line"><span class="comment">    statusText: &quot;I&#x27;m a teapot&quot;</span></span><br><span class="line"><span class="comment">    type: &quot;default&quot; </span></span><br><span class="line"><span class="comment">    url: &quot;&quot; </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><ul><li>**大多数情况下，产生Response 对象的主要方式是调用fetch()**， 它返回一个最后会解决为Response对象的期约，这个Response 对象代表实际的HTTP响应。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(response); </span><br><span class="line"> &#125;); </span><br><span class="line"><span class="comment">/*Response &#123; </span></span><br><span class="line"><span class="comment">    body: (...) </span></span><br><span class="line"><span class="comment">    bodyUsed: false </span></span><br><span class="line"><span class="comment">    headers: Headers &#123;&#125; </span></span><br><span class="line"><span class="comment">    ok: true </span></span><br><span class="line"><span class="comment">    redirected: false </span></span><br><span class="line"><span class="comment">    status: 200 </span></span><br><span class="line"><span class="comment">    statusText: &quot;OK&quot; </span></span><br><span class="line"><span class="comment">    type: &quot;basic&quot; </span></span><br><span class="line"><span class="comment">    url: &quot;https://foo.com/&quot; </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><ul><li>Response类还有两个用于生成Response对象的静态方法: Response.redirect()和Response.error()。<ul><li>前者接收一个URL和一个重定向状态码(301、302、303、307或308)，返回重定向的Response对象。</li><li>提供的状态码必须对应重定向，否则会抛出错误。</li></ul></li><li>另一个静态方法Response.error()用于产生表示网络错误的Response 对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Response.redirect(<span class="string">&#x27;https://foo.com&#x27;</span>, <span class="number">301</span>)); </span><br><span class="line"><span class="comment">/*Response &#123; </span></span><br><span class="line"><span class="comment">    body: (...) </span></span><br><span class="line"><span class="comment">    bodyUsed: false </span></span><br><span class="line"><span class="comment">    headers: Headers &#123;&#125; </span></span><br><span class="line"><span class="comment">    ok: false </span></span><br><span class="line"><span class="comment">    redirected: false </span></span><br><span class="line"><span class="comment">    status: 301 </span></span><br><span class="line"><span class="comment">    statusText: &quot;&quot; </span></span><br><span class="line"><span class="comment">    type: &quot;default&quot; </span></span><br><span class="line"><span class="comment">    url: &quot;&quot; </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h3 id="2）读取响应状态信息"><a href="#2）读取响应状态信息" class="headerlink" title="2）读取响应状态信息"></a>2）读取响应状态信息</h3><ul><li>Response对象包含一组只读属性，描述了请求完成后的状态，如下表所示。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/25/js-50/pic3.png" class title="# tu1"><ul><li>以下代码演示了返回200、302、404和500状态码的URL对应的响应：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;//foo.com&#x27;</span>).then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Response &#123; </span></span><br><span class="line">    <span class="comment">// body: (...) </span></span><br><span class="line">    <span class="comment">// bodyUsed: false </span></span><br><span class="line">    <span class="comment">// headers: Headers &#123;&#125; </span></span><br><span class="line">    <span class="comment">// ok: true </span></span><br><span class="line">    <span class="comment">// redirected: false </span></span><br><span class="line">    <span class="comment">// status: 200 </span></span><br><span class="line">    <span class="comment">// statusText: &quot;OK&quot; </span></span><br><span class="line">    <span class="comment">// type: &quot;basic&quot; </span></span><br><span class="line">    <span class="comment">// url: &quot;https://foo.com/&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line">fetch(<span class="string">&#x27;//foo.com/redirect-me&#x27;</span>).then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Response &#123; </span></span><br><span class="line">    <span class="comment">// body: (...) </span></span><br><span class="line">    <span class="comment">// bodyUsed: false </span></span><br><span class="line">    <span class="comment">// headers: Headers &#123;&#125; </span></span><br><span class="line">    <span class="comment">// ok: true </span></span><br><span class="line">    <span class="comment">// redirected: true</span></span><br><span class="line">    <span class="comment">// status: 200 </span></span><br><span class="line">    <span class="comment">// statusText: &quot;OK&quot; </span></span><br><span class="line">    <span class="comment">// type: &quot;basic&quot; </span></span><br><span class="line">    <span class="comment">// url: &quot;https://foo.com/redirected-url/&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line">fetch(<span class="string">&#x27;//foo.com/does-not-exist&#x27;</span>).then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Response &#123; </span></span><br><span class="line">    <span class="comment">// body: (...) </span></span><br><span class="line">    <span class="comment">// bodyUsed: false </span></span><br><span class="line">    <span class="comment">// headers: Headers &#123;&#125; </span></span><br><span class="line">    <span class="comment">// ok: false </span></span><br><span class="line">    <span class="comment">// redirected: true </span></span><br><span class="line">    <span class="comment">// status: 404 </span></span><br><span class="line">    <span class="comment">// statusText: &quot;Not Found&quot;</span></span><br><span class="line">    <span class="comment">// type: &quot;basic&quot; </span></span><br><span class="line">    <span class="comment">// url: &quot;https://foo.com/does-not-exist/&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line">fetch(<span class="string">&#x27;//foo.com/throws-error&#x27;</span>).then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Response &#123; </span></span><br><span class="line">    <span class="comment">// body: (...) </span></span><br><span class="line">    <span class="comment">// bodyUsed: false </span></span><br><span class="line">    <span class="comment">// headers: Headers &#123;&#125; </span></span><br><span class="line">    <span class="comment">// ok: false </span></span><br><span class="line">    <span class="comment">// redirected: true </span></span><br><span class="line">    <span class="comment">// status: 500 </span></span><br><span class="line">    <span class="comment">// statusText: &quot;Internal Server Error&quot;</span></span><br><span class="line">    <span class="comment">// type: &quot;basic&quot; </span></span><br><span class="line">    <span class="comment">// url: &quot;https://foo.com/throws-error/&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><h3 id="3）克隆Response对象"><a href="#3）克隆Response对象" class="headerlink" title="3）克隆Response对象"></a>3）克隆Response对象</h3><ul><li>克隆Response对象的主要方式是使用clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Response(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> r2 = r1.clone(); </span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyUsed); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.bodyUsed); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>如果响应对象的bodyUsed属性为true (即响应体已被读取),则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出TypeError。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Response(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">r.clone(); </span><br><span class="line"><span class="comment">// 没有错误</span></span><br><span class="line">r.text(); <span class="comment">// 设置 bodyUsed 为 true </span></span><br><span class="line">r.clone(); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Response&#x27;: Response body is already used </span></span><br></pre></td></tr></table></figure><ul><li>有响应体的Response对象只能读取一次。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Response(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">r.text().then(<span class="built_in">console</span>.log); <span class="comment">// foobar </span></span><br><span class="line">r.text().then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure><ul><li>要多次读取包含响应体的同一个Response对象，必须在第一次读取前调用clone()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Response(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">r.clone().text().then(<span class="built_in">console</span>.log); <span class="comment">// foobar </span></span><br><span class="line">r.clone().text().then(<span class="built_in">console</span>.log); <span class="comment">// foobar </span></span><br><span class="line">r.text().then(<span class="built_in">console</span>.log); <span class="comment">// foobar </span></span><br></pre></td></tr></table></figure><h2 id="6、Request、Response及Body混入"><a href="#6、Request、Response及Body混入" class="headerlink" title="6、Request、Response及Body混入"></a>6、Request、Response及Body混入</h2><h3 id="1）Body-text"><a href="#1）Body-text" class="headerlink" title="1）Body.text()"></a>1）Body.text()</h3><ul><li>Body.text ()方法返回期约，解决为将缓冲区转存得到的UTF-8 格式字符串。下面的代码展示了在Response对象上使用Body.text()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.text()) </span><br><span class="line">    .then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;head&gt; </span></span><br><span class="line"><span class="comment">// &lt;meta charset=&quot;utf-8&quot;&gt; </span></span><br><span class="line"><span class="comment">// ... </span></span><br></pre></td></tr></table></figure><ul><li>以下代码展示了在Request对象上使用Body.text()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;barbazqux&#x27;</span> &#125;); </span><br><span class="line">request.text() </span><br><span class="line">    .then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// barbazqux</span></span><br></pre></td></tr></table></figure><h3 id="2）Body-json"><a href="#2）Body-json" class="headerlink" title="2）Body.json()"></a>2）Body.json()</h3><ul><li>Body.json()方法返回期约，解决为将缓冲区转存得到的JSON。下面的代码展示了在Response对象上使用Body.json()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com/foo.json&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json()) </span><br><span class="line">    .then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// &#123;&quot;foo&quot;: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下代码展示了在Request对象上使用Body.json()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span> &#125;) &#125;); </span><br><span class="line">request.json().then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// &#123;bar: &#x27;baz&#x27;&#125; </span></span><br></pre></td></tr></table></figure><h3 id="3）Body-formData"><a href="#3）Body-formData" class="headerlink" title="3）Body.formData()"></a>3）Body.formData()</h3><ul><li><strong>浏览器可以将FormData对象序列化/反序列化为主体。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFormData = <span class="keyword">new</span> FormData(); </span><br><span class="line">myFormData.append(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br></pre></td></tr></table></figure><ul><li><strong>Body.formData()方法返回期约，解决为将缓冲区转存得到的FormData实例。</strong></li><li>下面的代码展示了在Response对象上使用Body.formData()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com/form-data&#x27;</span>) </span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.formData()) </span><br><span class="line"> .then(<span class="function">(<span class="params">formData</span>) =&gt;</span> <span class="built_in">console</span>.log(formData.get(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line"><span class="comment">// bar </span></span><br></pre></td></tr></table></figure><ul><li>以下代码展示了在Request对象上使用Body.formData()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFormData = <span class="keyword">new</span> FormData(); </span><br><span class="line">myFormData.append(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: myFormData &#125;); </span><br><span class="line">request.formData() .then(<span class="function">(<span class="params">formData</span>) =&gt;</span> <span class="built_in">console</span>.log(formData.get(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line"><span class="comment">// bar </span></span><br></pre></td></tr></table></figure><h3 id="4）Body-arrayBuffer"><a href="#4）Body-arrayBuffer" class="headerlink" title="4）Body.arrayBuffer()"></a>4）Body.arrayBuffer()</h3><ul><li>可以使用Body.arrayBuffer()将主体内容转换为ArrayBuffer实例。</li><li>Body.arrayBuffer()方法返回期约，解决为将缓冲区转存得到的ArrayBuffer实例。</li><li>下面的代码展示了在Response对象上使用Body.arrayBuffer()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.arrayBuffer()) </span><br><span class="line">    .then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// ArrayBuffer(...) &#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下代码展示了在Request对象上使用Body.arrayBuffer()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// 以整数形式打印二进制编码的字符串</span></span><br><span class="line">request.arrayBuffer()</span><br><span class="line"> .then(<span class="function">(<span class="params">buf</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Int8Array</span>(buf))); </span><br><span class="line"><span class="comment">// Int8Array(7) [97, 98, 99, 100, 101, 102, 103] </span></span><br></pre></td></tr></table></figure><h3 id="5）Body-blob"><a href="#5）Body-blob" class="headerlink" title="5）Body.blob()"></a>5）Body.blob()</h3><ul><li>有时候，可能需要以原始二进制格式使用主体，不用查看和修改。</li><li>可以使用Body.blob()将主体内容转换为Blob实例。</li><li><strong>Body.blob()方法返回期约，解决为将缓冲区转存得到的Blob实例</strong>。</li><li>下面的代码展示了在Response对象上使用Body.blob()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.blob()) </span><br><span class="line">    .then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Blob(...) &#123;size:..., type: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下代码展示了在Request对象上使用Body.blob()：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;); </span><br><span class="line">request.blob().then(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="comment">// Blob(7) &#123;size: 7, type: &quot;text/plain;charset=utf-8&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6）一次性流"><a href="#6）一次性流" class="headerlink" title="6）一次性流"></a>6）一次性流</h3><ul><li>因为Body混入是构建在ReadableStream之上的，所以<strong>主体流只能使用一次</strong>。</li><li>这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.blob().then(<span class="function">() =&gt;</span> response.blob())); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked </span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line">request.blob().then(<span class="function">() =&gt;</span> request.blob()); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked </span></span><br></pre></td></tr></table></figure><ul><li>即使是在读取流的过程中，所有这些方法也会在它们被调用时给ReadableStream加锁，以阻止其他读取器访问：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">        response.blob(); <span class="comment">// 第一次调用给流加锁</span></span><br><span class="line">        response.blob(); <span class="comment">// 第二次调用再次加锁会失败</span></span><br><span class="line">    &#125;); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked </span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line">request.blob(); <span class="comment">// 第一次调用给流加锁</span></span><br><span class="line">request.blob(); <span class="comment">// 第二次调用再次加锁会失败</span></span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、Fetch-API&quot;&gt;&lt;a href=&quot;#五、Fetch-API&quot; class=&quot;headerlink&quot; title=&quot;五、Fetch API&quot;&gt;&lt;/a&gt;五、Fetch API&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Fetch API则必须是异步&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Fetch" scheme="http://example.com/categories/Fetch/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十八）网络请求与远程资源（二）</title>
    <link href="http://example.com/2021/12/24/js-49/"/>
    <id>http://example.com/2021/12/24/js-49/</id>
    <published>2021-12-24T06:24:34.000Z</published>
    <updated>2021-12-25T11:57:34.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、跨源资源共享"><a href="#三、跨源资源共享" class="headerlink" title="三、跨源资源共享"></a>三、跨源资源共享</h1><ul><li><p><strong>跨源资源共享(CORS, Cross-Origin Resource Sharing)定义了浏览器与服务器如何实现跨源通信</strong>。</p></li><li><p>CORS背后的基本思路就是<strong>使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败</strong>。</p></li><li><p>对于简单的请求，比如GET或POST请求，没有自定义头部，而且请求体是text/plain类型，这样的请求在发送时会有一个额外的头部叫Origin。Origin头部包含发送请求的页面的源(协议域名和端口)，以便服务器确定是否为其提供响应。</p></li><li><p><strong>现代浏览器通过XMLHttpRequest对象原生支持CORS。</strong></p></li><li><p>要向不同域的源发送请求，可以使用标准XHR对象并给open()方法传入一个绝对URL。</p></li><li><p>跨域XHR对象允许访问status和statusText属性，也允许同步请求。</p></li><li><p>跨域XHR对象有以下额外限制：</p><ul><li>不能使用setRequestHeader()设置自定义头部。</li><li>不能发送和接收cookie。</li><li>getAllResponseHeaders()方法始终返回空字符串。</li></ul></li></ul><h2 id="1、预检请求"><a href="#1、预检请求" class="headerlink" title="1、预检请求"></a>1、预检请求</h2><ul><li>CORS通过一种叫预检请求的服务器验证机制，允许使用自定义头部、除GET和POST之外的方法，以及不同请求体内容类型。</li><li><strong>这个请求使用OPTIONS方法发送并包含以下头部</strong>。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/24/js-49/pic1.png" class title="# tu1"><ul><li>在这个请求发送后，服务器可以确定是否允许这种类型的请求。</li><li>服务器会通过在响应中发送如下头部与浏览器沟通这些信息。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/24/js-49/pic2.png" class title="# tu1"><h2 id="2、凭据请求"><a href="#2、凭据请求" class="headerlink" title="2、凭据请求"></a>2、凭据请求</h2><ul><li>默认情况下，跨源请求不提供凭据（cookie、HTTP认证和客户端SSL证书）。</li><li>可以通过将withCredentials属性设置为true来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：</li></ul><p>Access-Control-Allow-Credentials: true </p><h1 id="四、替代性跨源技术"><a href="#四、替代性跨源技术" class="headerlink" title="四、替代性跨源技术"></a>四、替代性跨源技术</h1><h2 id="1、图片探测"><a href="#1、图片探测" class="headerlink" title="1、图片探测"></a>1、图片探测</h2><ul><li>图片探测是利用<code>&lt;img&gt;</code>标签实现跨域通信的最早的一种技术。</li><li>原理是：<strong>任何页面都可以跨域加载图片而不必担心限制</strong>。</li><li>图片探测是与服务器之间简单、跨域、单向的通信。</li><li>数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为204的状态码。</li></ul><h2 id="2、JSONP"><a href="#2、JSONP" class="headerlink" title="2、JSONP"></a>2、JSONP</h2><ul><li>JSONP是JSON with padding 的简写，是在Web服务上流行的一种JSON变体。</li><li><strong>JSONP格式包含两个部分：回调和数据</strong>：<ul><li>回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。</li><li>数据就是作为参数传给回调函数的JSON数据。</li></ul></li><li>优点：相比于图片探测，使用JSONP可以直接访问响应，实现浏览器与服务器的双向通信。</li><li>缺点：①JSONP是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加人恶意内容。②不好确定JSONP请求是否失败。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、跨源资源共享&quot;&gt;&lt;a href=&quot;#三、跨源资源共享&quot; class=&quot;headerlink&quot; title=&quot;三、跨源资源共享&quot;&gt;&lt;/a&gt;三、跨源资源共享&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;跨源资源共享(CORS, Cross-Origin Res</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="跨域问题" scheme="http://example.com/categories/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十八）网络请求与远程资源（一）</title>
    <link href="http://example.com/2021/12/22/js-48/"/>
    <id>http://example.com/2021/12/22/js-48/</id>
    <published>2021-12-22T07:24:56.000Z</published>
    <updated>2021-12-24T06:20:50.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、XMLHttpRequest对象"><a href="#一、XMLHttpRequest对象" class="headerlink" title="一、XMLHttpRequest对象"></a>一、XMLHttpRequest对象</h1><h2 id="1、使用XHR"><a href="#1、使用XHR" class="headerlink" title="1、使用XHR"></a>1、使用XHR</h2><ul><li>open()方法<ul><li>接收3个参数：<strong>请求类型、请求URL、表示请求是否异步的布尔值。</strong></li><li>调用open不会实际发送请求，只是为发送请求做好准备。</li></ul></li><li>send()方法用于发送定义好的请求<ul><li>方法接收一个参数：<strong>作为请求体发送的数据</strong>。</li><li>该请求为同步请求，JavaScript代码会等待服务器响应之后再继续执行。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>); </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>收到响应后，XHR对象的以下属性会被填充上数据。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/22/js-48/pic1.png" class title="# tu1"><ul><li><p>收到响应后，第一步要检查status属性以确保响应成功返回。</p><ul><li>一般来说，HTTP 状态码为2xx表示成功。此时，responseText 或responseXML (如果内容类型正确)属性中会有内容。</li><li>如果HTTP状态码是304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。</li></ul></li><li><p>XHR对象有一个readyState属性，表示当前处在请求/响应过程的哪个阶段。属性有如下可能的值：</p><img lazyload src="/images/loading.svg" data-src="/2021/12/22/js-48/pic2.png" class title="# tu1"></li><li><p>每次readyState从一个值变成另一个值，都会触发readystatechange事件。为保证跨浏览器兼容，onreadystatechange事件处理程序应该在调用open()之前赋值。</p></li><li><p>在收到响应之前如果想取消异步请求，可以调用 abort()方法。</p></li></ul><h2 id="2、HTTP头部"><a href="#2、HTTP头部" class="headerlink" title="2、HTTP头部"></a>2、HTTP头部</h2><ul><li>默认情况下，XHR请求会发送以下头部字段。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/22/js-48/pic3.png" class title="# tu1"><ul><li>setRequestHeader方法可以发送额外的请求头部。<ul><li>接收两个参数：头部字段的名称和值。</li><li>为保证请求头部被发送，必须在open()之后、send()之前调用。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123; </span><br><span class="line">            alert(xhr.responseText); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;MyHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>); </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>getResponseHeader()方法可以从XHR对象获取响应头部。</li><li>getAllResponseHeaders()方法获取所有响应头部。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myHeader = xhr.getResponseHeader(<span class="string">&quot;MyHeader&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> allHeaders xhr.getAllResponseHeaders(); </span><br></pre></td></tr></table></figure><h2 id="3、GET请求"><a href="#3、GET请求" class="headerlink" title="3、GET请求"></a>3、GET请求</h2><ul><li><strong>GET请求用于向服务器查询某些信息</strong>。必要时，需要在GET请求的URL后面添加查询字符串参数。</li><li>对XHR而言，查询字符串必须正确编码后添加到URL后面，然后再传给open()方法。</li><li>查询字符串中的每个名和值都必须使用encodeURIComponent ()编码，所有名/值对必须以和号(&amp;)分隔。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php?name1=value1&amp;name2=value2&quot;</span>, <span class="literal">true</span>); </span><br></pre></td></tr></table></figure><h2 id="4、POST请求"><a href="#4、POST请求" class="headerlink" title="4、POST请求"></a>4、POST请求</h2><ul><li><strong>POST请求，用于向服务器发送应该保存的数据。</strong></li><li>每个POST请求都应该在请求体中携带提交的数据，而GET请求则不然。</li><li>POST请求的请求体可以包含非常多的数据，而且数据可以是任意格式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>); </span><br></pre></td></tr></table></figure><ul><li>POST请求相比GET请求要占用更多资源。</li><li><strong>从性能方面说，发送相同数量的数据，GET请求比POST请求要快两倍。</strong></li></ul><h2 id="5、XMLHttpRequest-Level-2"><a href="#5、XMLHttpRequest-Level-2" class="headerlink" title="5、XMLHttpRequest Level 2"></a>5、XMLHttpRequest Level 2</h2><h3 id="1）FormData类型"><a href="#1）FormData类型" class="headerlink" title="1）FormData类型"></a>1）FormData类型</h3><ul><li>FormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData(); </span><br><span class="line">data.append(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>append()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。</li><li>通过直接给FormData构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123; </span><br><span class="line">            alert(xhr.responseText); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="keyword">let</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;user-info&quot;</span>); </span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(form)); </span><br></pre></td></tr></table></figure><h3 id="2）超时"><a href="#2）超时" class="headerlink" title="2）超时"></a>2）超时</h3><ul><li>XHR对象有一个timeout属性，用于表示<strong>发送请求后等待多少毫秒</strong>，如果响应不成功就中断请求。</li><li>当超时后，XHR对象就会触发timeout事件，调用ontimeout事件处理程序。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面这个例子演示了使用timeout设置超时。给timeout设置1000 毫秒意味着，如果请求没有在1秒钟内返回则会中断。此时则会触发ont imeout事件处理程序，readyState 仍然会变成4，因此也会调用onreadystatechange事件处理程序。不过，如果在超时之后访问status属性则会发生错误。为做好防护，可以把检查status属性的代码封装在try/catch语句中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123; </span><br><span class="line">            alert(xhr.responseText); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status); </span><br><span class="line">        &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123; </span><br><span class="line">            <span class="comment">// 假设由 ontimeout 处理</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;timeout.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.timeout = <span class="number">1000</span>; <span class="comment">// 设置 1 秒超时</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;Request did not return in a second.&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="3）overrideMineType-方法"><a href="#3）overrideMineType-方法" class="headerlink" title="3）overrideMineType()方法"></a>3）overrideMineType()方法</h3><ul><li>overrideMineType()方法<strong>用于重写XHR响应的MIME类型</strong>。</li><li>假设服务器实际发送了XML数据，但响应头设置的MIME类型是text/plain。结果就会导致虽然数据是XML，但responseXML属性值是null。此时调用overrideMimeType()可以保证将响应当成XML而不是纯文本来处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;text.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.overrideMimeType(<span class="string">&quot;text/xml&quot;</span>); </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h1 id="二、进度事件"><a href="#二、进度事件" class="headerlink" title="二、进度事件"></a>二、进度事件</h1><img lazyload src="/images/loading.svg" data-src="/2021/12/22/js-48/pic4.png" class title="# tu1"><ul><li>每次请求都会首先触发loadstart事件，之后是一个或多个progress事件，接着是error、abort或load中的一个，最后以loadend事件结束。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、XMLHttpRequest对象&quot;&gt;&lt;a href=&quot;#一、XMLHttpRequest对象&quot; class=&quot;headerlink&quot; title=&quot;一、XMLHttpRequest对象&quot;&gt;&lt;/a&gt;一、XMLHttpRequest对象&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十七）JSON</title>
    <link href="http://example.com/2021/12/22/js-47/"/>
    <id>http://example.com/2021/12/22/js-47/</id>
    <published>2021-12-22T05:15:11.000Z</published>
    <updated>2021-12-22T07:19:23.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><ul><li>JSON语法支持表示3种类型的值：<ul><li>简单值：字符串、数值、布尔值和null可以在JSON中出现，就像在JavaScript中一样。特殊值undefined不可以。</li><li>对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。</li><li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象,甚至其他数组。</li></ul></li><li><strong>JSON没有变量声明</strong>。</li><li>JSON没有变量、函数或对象实例的概念。JSON的所有记号都只为表示结构化数据</li><li>布尔值和null本身也是有效的JSON值。</li><li>JavaScript字符串与JSON字符串的主要区别是：<strong>JSON字符串必须使用双引号</strong>。</li><li><strong>数组在 JSON 中使用 JavaScript 的数组字面量形式表示</strong>。</li></ul><h1 id="二、解析与序列化"><a href="#二、解析与序列化" class="headerlink" title="二、解析与序列化"></a>二、解析与序列化</h1><h2 id="1、JSON对象"><a href="#1、JSON对象" class="headerlink" title="1、JSON对象"></a>1、JSON对象</h2><ul><li>stringify()和parse()方法可用于将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。<ul><li>如果给JSON.parse()传入的JSON字符串无效，则会导致抛出错误。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">    title: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">    authors: [ </span><br><span class="line">        <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">    ], </span><br><span class="line">    edition: <span class="number">4</span>, </span><br><span class="line">    year: <span class="number">2017</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;], &quot;edition&quot;:4,&quot;year&quot;:2017&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2、序列化选项"><a href="#2、序列化选项" class="headerlink" title="2、序列化选项"></a>2、序列化选项</h2><ul><li>JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化JavaScript对象的方式。<ul><li><strong>第一个参数是过滤器，可以是数组或函数</strong>；</li><li><strong>第二个参数是用于缩进结果JSON字符串的选项</strong>。</li><li>单独或组合使用这些参数可以更好地控制JSON序列化。</li></ul></li></ul><h3 id="1）过滤结果"><a href="#1）过滤结果" class="headerlink" title="1）过滤结果"></a>1）过滤结果</h3><ul><li>如果第二个参数是一个<strong>数组</strong>，那么JSON.stringify()返回的结果<strong>只会包含该数组中列出的对象属性</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">    title: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">    authors: [ </span><br><span class="line">        <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">    ], </span><br><span class="line">    edition: <span class="number">4</span>, </span><br><span class="line">    year: <span class="number">2017</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;edition&quot;</span>]); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:4&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>如果第二个参数是一个函数，提供的函数接收两个参数:属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作。</li><li><strong>函数过滤器会应用到要序列化的对象所包含的所有对象</strong>，因此如果数组中包含多个具有这些属性的对象，则<strong>序列化之后每个对象都只会剩下上面这些属性</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">    title: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">    authors: [ </span><br><span class="line">        <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">    ], </span><br><span class="line">    edition: <span class="number">4</span>, </span><br><span class="line">    year: <span class="number">2017</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">switch</span>(key) &#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;authors&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> value.join(<span class="string">&quot;,&quot;</span>) </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;year&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">5000</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;edition&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,Matt Frisbie&quot;,&quot;year&quot;:5000&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2）字符串缩进"><a href="#2）字符串缩进" class="headerlink" title="2）字符串缩进"></a>2）字符串缩进</h3><ul><li><strong>JSON.stringify()方法的第三个参数控制缩进和空格。</strong><ul><li>在这个参数是数值时，表示每一级缩进的空格数。</li></ul></li><li>JSON.stringify()方法还为方便阅读插入了换行符。</li><li>最大缩进值为10，大于10的值会自动设置为10。</li><li>如果缩进参数是一个字符串而非数值，那么JSON字符串中就会使用这个字符串而不是空格来缩进。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">    title: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">    authors: [ </span><br><span class="line">        <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">    ], </span><br><span class="line">    edition: <span class="number">4</span>, </span><br><span class="line">    year: <span class="number">2017</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">    &quot;title&quot;: &quot;Professional JavaScript&quot;, </span></span><br><span class="line"><span class="comment">    &quot;authors&quot;: [ </span></span><br><span class="line"><span class="comment">        &quot;Nicholas C. Zakas&quot;, </span></span><br><span class="line"><span class="comment">        &quot;Matt Frisbie&quot; </span></span><br><span class="line"><span class="comment">    ], </span></span><br><span class="line"><span class="comment">    &quot;edition&quot;: 4, </span></span><br><span class="line"><span class="comment">    &quot;year&quot;: 2017 </span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3）toJSON-方法"><a href="#3）toJSON-方法" class="headerlink" title="3）toJSON()方法"></a>3）toJSON()方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">    title: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">    authors: [ </span><br><span class="line">        <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">    ], </span><br><span class="line">    edition: <span class="number">4</span>, </span><br><span class="line">    year: <span class="number">2017</span>, </span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.title; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book); </span><br></pre></td></tr></table></figure><p>这里book对象中定义的toJSON()方法简单地返回了图书的书名(this.title)。</p><ul><li><strong>箭头函数不能用来定义toJSON()方法</strong>。<ul><li>主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。</li></ul></li><li>toJSON()方法可以与过滤函数一起使用，在把对象传给JSON.stringify()时会执行如下步骤。<br>  (1)如果可以获取实际的值，则调用toJSON()方法获取实际的值，否则使用默认的序列化。<br>  (2)如果提供了第二个参数，则应用过滤。传人过滤函数的值就是第(1)步返回的值。<br>  (3)第(2)步返回的每个值都会相应地进行序列化。<br>  (4) 如果提供了第三个参数，则相应地进行缩进。</li></ul><h2 id="3、解析选项"><a href="#3、解析选项" class="headerlink" title="3、解析选项"></a>3、解析选项</h2><ul><li>JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。</li><li>为区别于传给JSON.stringify()的起过滤作用的替代函数(replacer)，这个函数被称为还原函数(reviver)。实际上它们的格式完全一样。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、语法&quot;&gt;&lt;a href=&quot;#一、语法&quot; class=&quot;headerlink&quot; title=&quot;一、语法&quot;&gt;&lt;/a&gt;一、语法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSON语法支持表示3种类型的值：&lt;ul&gt;
&lt;li&gt;简单值：字符串、数值、布尔值和null可以在JSON中出现，</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Json" scheme="http://example.com/categories/Json/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十六）动画与Canvas图形（二）</title>
    <link href="http://example.com/2021/12/20/js-46/"/>
    <id>http://example.com/2021/12/20/js-46/</id>
    <published>2021-12-20T07:44:37.000Z</published>
    <updated>2021-12-21T13:13:13.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h1><h2 id="1、WebGL上下文"><a href="#1、WebGL上下文" class="headerlink" title="1、WebGL上下文"></a>1、WebGL上下文</h2><ul><li>在完全支持的浏览器中：<ul><li>**WebGL 2.0上下文的名字叫” webgl2”**；</li><li>**WebGL 1.0上下文的名字叫” webgl1”**。</li></ul></li><li>检测浏览器是否支持WebGL：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> gl = drawing.getContext(<span class="string">&quot;webgl&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (gl)&#123; </span><br><span class="line">        <span class="comment">// 使用 WebGL </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="2、WebGL基础"><a href="#2、WebGL基础" class="headerlink" title="2、WebGL基础"></a>2、WebGL基础</h2><ul><li>可以在调用getContext ()取得WebGL上下文时指定一些选项。这些选项通过一个参数对象传入，选项就是参数对象的一个或多个属性。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/20/js-46/pic1.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> gl = drawing.getContext(<span class="string">&quot;webgl&quot;</span>, &#123; <span class="attr">alpha</span>: <span class="literal">false</span> &#125;); </span><br><span class="line">    <span class="keyword">if</span> (gl) &#123; </span><br><span class="line">        <span class="comment">// 使用 WebGL </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="1）常量"><a href="#1）常量" class="headerlink" title="1）常量"></a>1）常量</h3><ul><li>常量在OpenGL中的名字以GL_开头。<strong>在WebGL 中，context对象上的常量则不包含GL_前缀。</strong></li></ul><h3 id="2）方法命名"><a href="#2）方法命名" class="headerlink" title="2）方法命名"></a>2）方法命名</h3><ul><li>接收不同类型和不同数量参数的方法，会通过方法名的后缀体现这些信息。</li><li><strong>表示参数数量的数字(1~4)在先，表示数据类型的字符串(“f”表示浮点数,”i”表示整数)在后，还有很多方法接收数组，这类方法用字母“v”(vector )来表示。</strong></li><li>比如，gl.uniform4f()的意思是需要4个浮点数值参数，gl.uniform3iv()就是要接收一个包含3个值的数组参数。</li></ul><h3 id="3）准备绘图"><a href="#3）准备绘图" class="headerlink" title="3）准备绘图"></a>3）准备绘图</h3><ul><li>准备使用WebGL上下文之前，通常需要先指定一种实心颜色清除<code>&lt;canvas&gt;</code>。为此，要<strong>调用clearcolor()方法并传入4个参数，分别表示红、绿、蓝和透明度值。</strong>每个参数必须是0~1范围内的值,表示各个组件在最终颜色的强度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.clearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 黑色</span></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT); </span><br></pre></td></tr></table></figure><h3 id="4）视口与坐标"><a href="#4）视口与坐标" class="headerlink" title="4）视口与坐标"></a>4）视口与坐标</h3><ul><li>绘图前还要定义WebGL 视口。默认情况下，视口使用整个<code>&lt;canvas&gt;</code>区域。</li><li>要改变视口，可以调用viewport()方法并传入视口相对于<code>&lt;canvas&gt;</code>元素的x、y坐标及宽度和高度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.viewport(<span class="number">0</span>, <span class="number">0</span>, drawing.width,drawing.height);</span><br></pre></td></tr></table></figure><ul><li>这个视口的坐标系统与网页中通常的坐标系统不一样。视口的x和y坐标起点(0,0)表示<code>&lt;canvas&gt;</code>元素的左下角，向上、向右增长可以用点(width-1, height-1)定义。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/20/js-46/pic2.png" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视口是&lt;canvas&gt; 左下角四分之一区域</span></span><br><span class="line">gl.viewport(<span class="number">0</span>, <span class="number">0</span>, drawing.width/<span class="number">2</span>, drawing.height/<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 视口是&lt;canvas&gt; 左上角四分之一区域</span></span><br><span class="line">gl.viewport(<span class="number">0</span>, drawing.height/<span class="number">2</span>, drawing.width/<span class="number">2</span>, drawing.height/<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 视口是&lt;canvas&gt; 右下角四分之一区域</span></span><br><span class="line">gl.viewport(drawing.width/<span class="number">2</span>, <span class="number">0</span>, drawing.width/<span class="number">2</span>, d</span><br></pre></td></tr></table></figure><h3 id="5）缓冲区"><a href="#5）缓冲区" class="headerlink" title="5）缓冲区"></a>5）缓冲区</h3><ul><li>gl.createBuffer()方法用于创建缓冲区。</li><li>gl.bindBuffer()方法用于将缓冲区绑定到WebGL上下文。绑定后就可以用数据填充缓冲区了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = gl.createBuffer(); </span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">//初始化buffer</span></span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>([<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]), gl.STATIC_DRAW); </span><br></pre></td></tr></table></figure><ul><li>drawElements()方法同时传入gl.ELEMENT_ARRAY_BUFFER可用于输出缓冲区内容。</li><li>gl.bufferData()方法的最后一个参数表示如何使用缓冲区。这个参数可以是以下常量值。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/20/js-46/pic3.png" class title="# tu1"><h3 id="6）错误"><a href="#6）错误" class="headerlink" title="6）错误"></a>6）错误</h3><ul><li>gl.getError()方法<ul><li>方法返回一个常量，表示发生的错误类型，下面列出了这些常量：</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/20/js-46/pic4.png" class title="# tu1"><ul><li>每次调用gl.getError()方法会返回一个错误值。第一次调用之后，再调用gl.getError ()可能会返回另一个错误值。如果有多个错误，则可以重复这个过程，直到 gl.getError ()返回gl.NO_ERROR。</li></ul><h3 id="7）着色器"><a href="#7）着色器" class="headerlink" title="7）着色器"></a>7）着色器</h3><ul><li>WebGL 中有两种着色器：<strong>顶点着色器</strong>和<strong>片段(或像素)着色器</strong>。<ul><li>顶点着色器用于把3D顶点转换为可以渲染的2D点。</li><li>片段着色器用于计算绘制一个像素的正确颜色。</li></ul></li><li>WebGL着色器的独特之处在于，它们不是JavaScript实现的，而是使用一种与C或JavaScript完全不同的语言GLSL ( OpenGL Shading Language)写的。</li></ul><h3 id="8）绘图"><a href="#8）绘图" class="headerlink" title="8）绘图"></a>8）绘图</h3><ul><li>WebGL只能绘制三种形状：<strong>点、线和三角形</strong>。</li><li>drawArrays()方法：使用数组缓冲区<ul><li>接收三个参数：常量、数组缓冲区起点索引、数组缓冲区包含的顶点集合的数量。</li></ul></li><li>drawElements()操作元素数组缓冲区。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/20/js-46/pic5.png" class title="# tu1"><h3 id="9）纹理"><a href="#9）纹理" class="headerlink" title="9）纹理"></a>9）纹理</h3><ul><li>gl.createTexture()方法创建新的纹理，然后将图片绑定到这个纹理。</li><li>如果图片还没有加载，则可以创建一个 Image对象来动态加载。图片加载完成后才能初始化纹理,因此在图片的load事件之后才能使用纹理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image(), </span><br><span class="line">    texture; </span><br><span class="line">image.src = <span class="string">&quot;smile.gif&quot;</span>; </span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    texture = gl.createTexture(); </span><br><span class="line">    gl.bindTexture(gl.TEXTURE_2D, texture); </span><br><span class="line">    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <span class="literal">true</span>); </span><br><span class="line">    gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); </span><br><span class="line">    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); </span><br><span class="line">    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); </span><br><span class="line">    <span class="comment">// 除当前纹理</span></span><br><span class="line">    gl.bindTexture(gl.TEXTURE_2D, <span class="literal">null</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10）读取像素"><a href="#10）读取像素" class="headerlink" title="10）读取像素"></a>10）读取像素</h3><ul><li>readPixels()方法。<ul><li>参数包括：x、y坐标、宽度、高度、图像格式、类型和定型数组。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pixels = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">25</span>*<span class="number">25</span>); </span><br><span class="line">gl.readPixels(<span class="number">0</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">25</span>, gl.RGBA, gl.UNSIGNED_BYTE, pixels);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebGL&quot;&gt;&lt;a href=&quot;#WebGL&quot; class=&quot;headerlink&quot; title=&quot;WebGL&quot;&gt;&lt;/a&gt;WebGL&lt;/h1&gt;&lt;h2 id=&quot;1、WebGL上下文&quot;&gt;&lt;a href=&quot;#1、WebGL上下文&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="WebGL" scheme="http://example.com/categories/WebGL/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十五）动画与Canvas图形（一）</title>
    <link href="http://example.com/2021/12/14/js-45/"/>
    <id>http://example.com/2021/12/14/js-45/</id>
    <published>2021-12-14T09:02:37.000Z</published>
    <updated>2021-12-19T15:17:11.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用requestAnimationFrame"><a href="#使用requestAnimationFrame" class="headerlink" title="使用requestAnimationFrame"></a>使用requestAnimationFrame</h1><h2 id="1、早期定时动画"><a href="#1、早期定时动画" class="headerlink" title="1、早期定时动画"></a>1、早期定时动画</h2><ul><li>早期使用setInterval()控制动画的执行。</li><li>存在的问题：<ul><li>无法准确知晓循环之间的延时。</li><li>不能保证时间精度。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateAnimations</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        doAnimation1(); </span><br><span class="line">        doAnimation2(); </span><br><span class="line">        <span class="comment">// 其他任务</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">setInterval</span>(updateAnimations, <span class="number">100</span>); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="2、requestAnimationFrame"><a href="#2、requestAnimationFrame" class="headerlink" title="2、requestAnimationFrame"></a>2、requestAnimationFrame</h2><ul><li><p>requestAnimationFrame()</p><ul><li>方法接收一个参数：要在重绘屏幕前调用的函数。这个函数就是修改DOM样式以反映下一次重绘有什么变化的地方。</li><li>为了实现动画循环，可以串联调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>); </span><br><span class="line">    div.style.width = (<span class="built_in">parseInt</span>(div.style.width, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>; </span><br><span class="line">    <span class="keyword">if</span> (div.style.left != <span class="string">&quot;100%&quot;</span>) &#123; </span><br><span class="line">        requestAnimationFrame(updateProgress); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">requestAnimationFrame(updateProgress);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因为requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。</p></li><li><p>传给requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimestamp 的实例(比如performance.now()返回的值)，表示下次重绘的时间。</p></li></ul><h2 id="3、cancelAnimationFrame"><a href="#3、cancelAnimationFrame" class="headerlink" title="3、cancelAnimationFrame"></a>3、cancelAnimationFrame</h2><ul><li>与setTimeout类似，requestAnimationFrame()返回一个请求ID；</li><li>cancelAnimationFrame()来取消重绘任务。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> requestID = <span class="built_in">window</span>.requestAnimationFrame(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Repaint!&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame(requestID);</span><br></pre></td></tr></table></figure><h2 id="4、通过requestAnimationFrame节流"><a href="#4、通过requestAnimationFrame节流" class="headerlink" title="4、通过requestAnimationFrame节流"></a>4、通过requestAnimationFrame节流</h2><ul><li>支持该方法的浏览器会暴露作为钩子的回调队列。<ul><li>钩子就是浏览器在执行下一次重绘前的一个点。</li><li><strong>通过requestAnimationFrame ()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。</strong></li></ul></li></ul><h1 id="基本的画布功能"><a href="#基本的画布功能" class="headerlink" title="基本的画布功能"></a>基本的画布功能</h1><ul><li>创建<code>&lt;canvas&gt;</code>元素时至少需要width和height属性。</li><li>getContext()方法可以获取对绘图上下文的引用。<ul><li>对于平面图形，需要传入参数：2d。</li></ul></li><li>toDataURL()方法可以导出<code>&lt;canvas&gt;</code>元素上的图像。<ul><li>方法接收一个参数：要生成图像的MIME类型。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2D绘图上下文"><a href="#2D绘图上下文" class="headerlink" title="2D绘图上下文"></a>2D绘图上下文</h1><h2 id="1、填充和描边"><a href="#1、填充和描边" class="headerlink" title="1、填充和描边"></a>1、填充和描边</h2><ul><li>两个属性：fillStyle和strokeStyle。<ul><li>可以是字符串】渐变对象或图案对象；</li><li>默认值为”#000000”；</li><li>字符串表示颜色值，可以是CSS支持的任意格式：名称、十六进制代码、rgb、rgba、hsl或hsla。</li></ul></li></ul><h2 id="2、绘制矩形"><a href="#2、绘制矩形" class="headerlink" title="2、绘制矩形"></a>2、绘制矩形</h2><ul><li>fillRect()、strokeRect()、clearRect()：<ul><li>方法都接收4个参数：矩形x坐标、矩形y坐标、矩形宽度和矩形高度（单位均为像素）。</li><li>fillRect()方法用于以指定颜色在画布上绘制并填充矩形；填充颜色使用fillStyle属性指定（<strong>实心矩形</strong>）。</li><li>strokeRect()方法可以通过strokeStyle属性指定的颜色绘制举行轮廓（<strong>绘制边框，内部空心</strong>）。</li><li>clearRect()方法可以擦除画布中某个区域<ul><li>方法用于把绘图上下文种的某个区域变透明。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 引自 MDN 文档</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="comment">// 绘制红色矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">    <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line">    context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">    <span class="comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span></span><br><span class="line">    context.clearRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="3、绘制路径"><a href="#3、绘制路径" class="headerlink" title="3、绘制路径"></a>3、绘制路径</h2><ul><li>beginPath()方法是开始绘制新路径必须首先调用的方法。</li><li>再用以下方法来绘制路径：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic1.png" class title="# tu1"><ul><li>创建路径之后，可以使用closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定fillstyle 属性并调用fill ()方法来填充路径，也可以指定strokeStyle 属性并调用stroke ()方法来描画路径，还可以调用clip()方法基于已有路径创建一 个新剪切区域。</li><li>isPointInPath()方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用<ul><li>接收x轴和y轴坐标作为参数。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123; </span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">    <span class="comment">// 创建路径</span></span><br><span class="line">    context.beginPath(); </span><br><span class="line">    <span class="comment">// 绘制外圆</span></span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>); </span><br><span class="line">    <span class="comment">// 绘制内圆</span></span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>); </span><br><span class="line">    <span class="comment">// 绘制分针</span></span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>); </span><br><span class="line">    <span class="comment">// 绘制时针</span></span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>); </span><br><span class="line">    <span class="comment">// 描画路径</span></span><br><span class="line">    context.stroke(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic2.png" class title="# tu1"><h2 id="4、绘制文本"><a href="#4、绘制文本" class="headerlink" title="4、绘制文本"></a>4、绘制文本</h2><ul><li>fillText()和strokeText()用于绘制文本。<ul><li>两个方法接收4个参数：字符串、x坐标、y坐标和可选的最大像素宽度。</li><li>fillText()方法使用fillStyle属性绘制文本；</li><li>strokeText()方法使用strokeStyle属性；</li><li>两个方法最终绘制的结果都取决于以下3个属性：</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic3.png" class title="# tu1"><ul><li>measureText()方法<ul><li>接收一个参数：要绘制的文本；</li><li>返回一个TextMetrics对象；</li><li>使用font、textAlign和textBaseline属性当前的值计算绘制指定文本后的大小。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fontSize = <span class="number">100</span>; </span><br><span class="line">context.font = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line"><span class="keyword">while</span>(context.measureText(<span class="string">&quot;Hello world!&quot;</span>).width &gt; <span class="number">140</span>) &#123; </span><br><span class="line"> fontSize--; </span><br><span class="line"> context.font = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">context.fillText(<span class="string">&quot;Hello world!&quot;</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">context.fillText(<span class="string">&quot;Font size is &quot;</span> + fontSize + <span class="string">&quot;px&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="5、变换"><a href="#5、变换" class="headerlink" title="5、变换"></a>5、变换</h2><ul><li>以下方法可用于改变绘制上下文的变换矩阵：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic4.png" class title="# tu1"><ul><li><strong>所有这些变换，包括fillstyle和strokestyle属性，会一直保留在上下文中，直到再次修改它们</strong>。</li></ul><h2 id="6、绘制图像"><a href="#6、绘制图像" class="headerlink" title="6、绘制图像"></a>6、绘制图像</h2><ul><li>drawImage()方法用于把现有图像绘制到画布上。</li><li>方法可以接收3组不同的参数：<br>  1、 传入HTML种img元素/canvas元素、绘制目标的x和y坐标；（直接绘制）<br>  2、 传入HTML img元素、绘制目标的x、y坐标、目标宽度、目标高度；（可用于改变图像大小）<br>  3、 要绘制的图像、源图像x坐标、源图像y坐标、源图像宽度、源图像高度、目标区域x坐标、目标区域y坐标、目标区域宽度、目标区域高度。（只把图像绘制到上下文中的一个区域）</li></ul><h2 id="7、阴影"><a href="#7、阴影" class="headerlink" title="7、阴影"></a>7、阴影</h2><ul><li>2D上下文可以根据以下属性的值自动为已有形状或路径生成阴影：<img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic5.png" class title="# tu1"></li><li>这些属性都可以通过context对象读写。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"><span class="comment">// 设置阴影</span></span><br><span class="line">context.shadowOffsetX = <span class="number">5</span>; </span><br><span class="line">context.shadowOffsetY = <span class="number">5</span>; </span><br><span class="line">context.shadowBlur = <span class="number">4</span>; </span><br><span class="line">context.shadowColor = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>; </span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="8、渐变"><a href="#8、渐变" class="headerlink" title="8、渐变"></a>8、渐变</h2><ul><li>渐变通过CanvasGradient的实例表示，在2D上下文中创建和修改都非常简单。</li><li>createLinearGradient()方法用于创建线性渐变。<ul><li>接收4个参数：起点x坐标、起点y坐标、终点x坐标和终点y坐标。</li><li>调用之后,该方法会以指定大小创建一个新的CanvasGradient对象并返回实例。</li></ul></li><li>addColorStop()方法为渐变指定色标。<ul><li>方法接收两个参数：色标位置和CSS颜色字符串。</li><li>色标位置通过0~1范围的值表示，0是第一种颜色，1是最后一种颜色。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.createLinearGradient(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>); </span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.addColorStop(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.fillStyle = gradient; </span><br><span class="line">context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="9、图案"><a href="#9、图案" class="headerlink" title="9、图案"></a>9、图案</h2><ul><li>createPattern()方法。<ul><li>接收两个参数：一个HTML<code>&lt;img&gt;</code>和一个表示该如何重复图像的字符串。</li><li>第二个参数的值与CSS的background-repeat属性，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。</li><li>第一个参数也可以是<code>&lt;video&gt;</code>元素或者另一个<code>&lt;canvas&gt;</code>元素。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>], </span><br><span class="line"> pattern = context.createPattern(image, <span class="string">&quot;repeat&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line">context.fillStyle = pattern; </span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>); </span><br></pre></td></tr></table></figure><h2 id="10、图像数据"><a href="#10、图像数据" class="headerlink" title="10、图像数据"></a>10、图像数据</h2><ul><li>getImageData()方法获取原始图像数据。<ul><li>方法接收4个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。</li><li>返回的对象是一个ImageData的实例。每个对象都包含3个属性：<ul><li>width：图像宽；</li><li>height：图像高；</li><li>data：包含图像的原始像素信息的数组。每个data中的元素都由4个值表示，分别代表红、绿、蓝和透明度。</li></ul></li></ul></li></ul><h2 id="11、合成"><a href="#11、合成" class="headerlink" title="11、合成"></a>11、合成</h2><ul><li>globalAlpha属性是一个范围在0~1的值(包括0和1),用于指定所有绘制内容的透明度，默认值为0。</li><li>globalCompositionOperation属性表示新绘制的形状如何与上下文中已有的形状融合。该属性为一个字符串，可以取下列值：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/14/js-45/pic6.png" class title="# tu1">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用requestAnimationFrame&quot;&gt;&lt;a href=&quot;#使用requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;使用requestAnimationFrame&quot;&gt;&lt;/a&gt;使用requestAnimatio</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="Canvas" scheme="http://example.com/categories/Canvas/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（四十四）事件（二）</title>
    <link href="http://example.com/2021/12/12/js-44/"/>
    <id>http://example.com/2021/12/12/js-44/</id>
    <published>2021-12-12T14:59:09.000Z</published>
    <updated>2021-12-14T08:58:47.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><h2 id="1、用户界面事件"><a href="#1、用户界面事件" class="headerlink" title="1、用户界面事件"></a>1、用户界面事件</h2><h3 id="1）load事件"><a href="#1）load事件" class="headerlink" title="1）load事件"></a>1）load事件</h3><ul><li>在window对象上，load事件会在整个页面（包括所有外部资源如图片、JavaScript文件和CSS文件)加载完成后触发。</li><li>可以通过两种方式指定load事件处理程序：<ul><li>JavaScript方式；</li><li>向<code>&lt;body&gt;</code>元素添加onload属性。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Loaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Load Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Loaded!&#x27;)&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）unload事件"><a href="#2）unload事件" class="headerlink" title="2）unload事件"></a>2）unload事件</h3><ul><li>与load事件相对。</li><li>unload事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。</li><li>使用方法与load完全一样。</li></ul><h3 id="3）resize事件"><a href="#3）resize事件" class="headerlink" title="3）resize事件"></a>3）resize事件</h3><ul><li>当浏览器窗口被缩放到新高度或宽度是，会触发resize事件。</li><li>事件在window上触发。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Resized&quot;</span>); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h3 id="4）scroll事件"><a href="#4）scroll事件" class="headerlink" title="4）scroll事件"></a>4）scroll事件</h3><ul><li>scroll事件发生在window上，但实际上反映的是页面中相应元素的变化。</li></ul><h2 id="2、焦点事件"><a href="#2、焦点事件" class="headerlink" title="2、焦点事件"></a>2、焦点事件</h2><ul><li>焦点事件在页面元素获得或失去焦点时触发。</li><li>焦点事件有以下6种：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic1.png" class title="# tu1"><ul><li>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件：<ul><li>focuscout在失去焦点的元素上触发。</li><li>focusin在获得焦点的元素上触发。</li><li>blur在失去焦点的元素上触发。</li><li>DOMFocusOut在失去焦点的元素上触发。</li><li>focus在获得焦点的元素上触发。</li><li>DOMFocusIn在获得焦点的元素上触发。</li></ul></li><li>blur、DOMF ocusOut和focusout的事件目标是失去焦点的元素；</li><li>focus、DOMFocusIn和focusin的事件目标是获得焦点的元素。</li></ul><h2 id="3、鼠标和滚轮事件"><a href="#3、鼠标和滚轮事件" class="headerlink" title="3、鼠标和滚轮事件"></a>3、鼠标和滚轮事件</h2><ul><li>DOM3 Events定义了9种鼠标事件：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic2.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic3.png" class title="# tu1"><ul><li>页面中的所有元素都支持鼠标事件。</li><li>除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。</li></ul><h3 id="1）客户端坐标"><a href="#1）客户端坐标" class="headerlink" title="1）客户端坐标"></a>1）客户端坐标</h3><ul><li>客户端坐标使用：event.clientX和event.clientY。</li></ul><h3 id="2）页面坐标"><a href="#2）页面坐标" class="headerlink" title="2）页面坐标"></a>2）页面坐标</h3><ul><li>页面坐标使用：event.pageX和event.pageY。</li><li>页面没有滚动时客户端与页面坐标对应相等。</li></ul><h3 id="3）屏幕坐标"><a href="#3）屏幕坐标" class="headerlink" title="3）屏幕坐标"></a>3）屏幕坐标</h3><ul><li>客户端坐标使用：event.screenX和event.screenY。</li></ul><h3 id="4）修饰键"><a href="#4）修饰键" class="headerlink" title="4）修饰键"></a>4）修饰键</h3><ul><li>键盘上的修饰键：Shift、Ctrl、Alt、Meta。</li><li>DOM规定4个属性表示修饰键状态：<ul><li>shiftKey、ctrlKey、altKey 和 metaKey。</li><li>修饰键被按下时包含布尔值true，没有被按下时包含false。</li></ul></li></ul><h3 id="5）相关元素"><a href="#5）相关元素" class="headerlink" title="5）相关元素"></a>5）相关元素</h3><ul><li>简单解释就是：事件发生存在与事件相关的其他元素。</li><li>涉及到mouseover和mouseout两个事件。<ul><li>对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。</li><li>对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。</li></ul></li><li>DOM通过event对象的relatedTarget属性提供了相关元素的信息。<ul><li>这个属性只有在mouseover和mouseout事件发生时才包含值，其他所有事件的这个属性的值都是 null。</li></ul></li></ul><h3 id="6）鼠标按键"><a href="#6）鼠标按键" class="headerlink" title="6）鼠标按键"></a>6）鼠标按键</h3><ul><li>只有在元素上单击鼠标主键（或按下键盘上的回车键)时click 事件才会触发，因此按键信息并不是必需的。</li><li>对mousedown 和 mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。</li><li>DOM为这个button 属性定义了3个值:0表示鼠标主键、1表示鼠标中键（通常也是滚轮键)、2表示鼠标副键。</li></ul><h3 id="7）额外事件信息"><a href="#7）额外事件信息" class="headerlink" title="7）额外事件信息"></a>7）额外事件信息</h3><ul><li>DOM2 Events规范在event对象上提供了detail 属性，以给出关于事件的更多信息。<ul><li>对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少次单击。</li><li><strong>单击相当于在同一个像素上发生一次mousedown 紧跟一次mouseup</strong>。detail的值从1开始，每次单击会加1。</li><li>如果鼠标在mousedown和mouseup之间移动了，则detail会重置为0。</li></ul></li></ul><h3 id="8）mousewheel事件"><a href="#8）mousewheel事件" class="headerlink" title="8）mousewheel事件"></a>8）mousewheel事件</h3><ul><li>事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。</li><li>这个事件会在任何元素上触发,并(在IE8中）冒泡到document和(在所有现代浏览器中) window。</li><li>mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为 wheelDelta的新属性。<ul><li>当鼠标滚轮向前滚动时，wheelDelta每次都是+120；</li><li>当鼠标滚轮向后滚动时，wheelDelta每次都是-120。</li></ul></li><li>可以为页面上的任何元素或文档添加onmousewheel 事件处理程序，以处理所有鼠标滚轮交互。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousewheel&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(event.wheelDelta); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4、键盘与输入事件"><a href="#4、键盘与输入事件" class="headerlink" title="4、键盘与输入事件"></a>4、键盘与输入事件</h2><ul><li>键盘事件包含 3 个事件：<ul><li>keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。</li><li>keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了keypress事件，而推荐text Input事件。</li><li>keyup，用户释放键盘上某个键时触发。</li></ul></li><li>输入事件只有一个：textInput</li></ul><h3 id="1）键码"><a href="#1）键码" class="headerlink" title="1）键码"></a>1）键码</h3><ul><li>对于keydown和 keyup事件,event对象的keycode属性中会保存一个键码，对应键盘上特定的一个键。</li><li>对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic4.png" class title="# tu1"><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic5.png" class title="# tu1"><h3 id="2）字符编码"><a href="#2）字符编码" class="headerlink" title="2）字符编码"></a>2）字符编码</h3><ul><li>浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。</li><li>通常，charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。</li></ul><h2 id="5、合成事件"><a href="#5、合成事件" class="headerlink" title="5、合成事件"></a>5、合成事件</h2><ul><li>合成事件是DOM3 Events中新增的，用于处理通常使用IME输人时的复杂输入序列。<ul><li>IME可以让用户输入物理键盘上没有的字符。</li></ul></li><li>合成事件有以下3种：<ul><li>compositionstart，在 IME的文本合成系统打开时触发，表示输入即将开始；</li><li>compositionupdate，在新字符插入输入字段时触发；</li><li>compositionend，在 IME的文本合成系统关闭时触发，表示恢复正常键盘输人。</li></ul></li><li>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，其中包含的值视情况而异：<ul><li>在compositionstart事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换)；</li><li>在compositionupdate事件中,包含要插人的新字符；</li><li>在compositionend事件中，包含本次合成过程中输入的全部内容。</li></ul></li></ul><h2 id="6、变化事件"><a href="#6、变化事件" class="headerlink" title="6、变化事件"></a>6、变化事件</h2><ul><li>已废弃</li></ul><h2 id="7、HTML5事件"><a href="#7、HTML5事件" class="headerlink" title="7、HTML5事件"></a>7、HTML5事件</h2><h3 id="1）contextmenu事件"><a href="#1）contextmenu事件" class="headerlink" title="1）contextmenu事件"></a>1）contextmenu事件</h3><ul><li>专门用于表示何时该显示上下文菜单。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ContextMenu Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Right click or Ctrl+click me to get a custom context menu. Click anywhere else to get the default context menu.<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myMenu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;visibility:hidden;background-color: </span></span></span><br><span class="line"><span class="tag"><span class="string">    silver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere.com&quot;</span>&gt;</span> somewhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.wrox.com&quot;</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere-else.com&quot;</span>&gt;</span>somewhere-else<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">    div.addEventListener(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">        event.preventDefault(); </span><br><span class="line">        <span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myMenu&quot;</span>); </span><br><span class="line">        menu.style.left = event.clientX + <span class="string">&quot;px&quot;</span>; </span><br><span class="line">        menu.style.top = event.clientY + <span class="string">&quot;px&quot;</span>; </span><br><span class="line">        menu.style.visibility = <span class="string">&quot;visible&quot;</span>; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myMenu&quot;</span>).style.visibility = <span class="string">&quot;hidden&quot;</span>; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>以上代码实现效果如下：这里在<code>&lt;div&gt;</code>元素上指定了一个oncontextmenu事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于event对象的clientx和clientY属性把<code>&lt;ul&gt;</code>元素放到适当位置。最后一步通过将visibility属性设置为”visible”让自定义上下文菜单显示出来。另外，又给document添加了一个onclick事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的)。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic6.png" class title="# tu1"><ul><li>当鼠标右键点击/ctrl+点击文字会发生以下变化：</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic7.png" class title="# tu1"><h3 id="2）beforeunload事件"><a href="#2）beforeunload事件" class="headerlink" title="2）beforeunload事件"></a>2）beforeunload事件</h3><ul><li>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。</li><li>这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。</li><li>这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。</li></ul><h3 id="3）DOMContentLoaded事件"><a href="#3）DOMContentLoaded事件" class="headerlink" title="3）DOMContentLoaded事件"></a>3）DOMContentLoaded事件</h3><ul><li>DOMContentLoaded事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。</li><li>相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</li><li>要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Content loaded&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4）readystatechange事件"><a href="#4）readystatechange事件" class="headerlink" title="4）readystatechange事件"></a>4）readystatechange事件</h3><ul><li>readystatechange 事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。</li><li>支持readystatechange 事件的每个对象都有一个readyState属性，该属性具有一个以下列出的可能的字符串值。<img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic8.png" class title="# tu1"></li></ul><h3 id="5）pageshow与pagehide事件"><a href="#5）pageshow与pagehide事件" class="headerlink" title="5）pageshow与pagehide事件"></a>5）pageshow与pagehide事件</h3><ul><li>往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。</li><li>这个缓存不仅存储页面数据，也存储 DOM 和JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。</li><li><strong>pageshow，其会在页面显示时触发，无论是否来自往返缓存。</strong><ul><li>在新加载的页面上，pageshow会在 load事件之后触发；</li><li>在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。</li><li><strong>虽然这个事件的目标是document，但事件处理程序必须添加到window上</strong>。</li><li>pageshow 的 event 对象中还包含一个名为 persisted 的属性，这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。</li></ul></li><li><strong>pagehide与pageshow相对，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。</strong></li></ul><h3 id="6）hashchange事件"><a href="#6）hashchange事件" class="headerlink" title="6）hashchange事件"></a>6）hashchange事件</h3><ul><li>HTML5增加了hashchange事件，<strong>用于在URL散列值(URL最后#后面的部分)发生变化时通知开发者</strong>。这是因为开发者经常在Ajax应用程序中使用URL 散列值存储状态信息或路由导航信息。</li><li>onhashchange事件处理程序必须添加给window，每次URL散列值发生变化时会调用它。</li><li>event对象有两个新属性: oldURL 和newURL。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。</li></ul><h2 id="8、设备事件"><a href="#8、设备事件" class="headerlink" title="8、设备事件"></a>8、设备事件</h2><ul><li>设备事件可以用于确定用户使用设备的方式。</li></ul><h3 id="1）orientationchange事件"><a href="#1）orientationchange事件" class="headerlink" title="1）orientationchange事件"></a>1）orientationchange事件</h3><ul><li>用于确定用户的设备是处于垂直模式还是水平模式。</li><li>每当用户旋转设备改变了模式，就会触发orientationchange事件。</li><li>可以从window.orientation 属性中获取有用的信息。</li></ul><h3 id="2）deviceorientation"><a href="#2）deviceorientation" class="headerlink" title="2）deviceorientation"></a>2）deviceorientation</h3><ul><li>deviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。</li><li>设备本身处于3D空间即拥有x轴、y轴和z轴的坐标系中。如果把设备静止放在水平的表面上,那么三轴的值均为0，其中，x轴方向为从设备左侧到右侧,y轴方向为从设备底部到上部、z轴方向为从设备背面到正面。</li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic9.png" class title="# tu1"><ul><li>当deviceorientation触发时，event对象中会包含各个轴相对于设备静置时坐标值的变化,主要是以下5个属性。<ul><li>alpha：0~360范围内的浮点值，表示围绕z轴旋转时y轴的度数(左右转)。</li><li>beta：-180~180范围内的浮点值，表示围绕x轴旋转时z轴的度数（前后转)。</li><li>gamma：-90~90范围内的浮点值，表示围绕y轴旋转时z轴的度数（扭转)。</li><li>absolute：布尔值，表示设备是否返回绝对值。</li><li>compassCalibrated：布尔值，表示设备的指南针是否正确校准。</li></ul></li></ul><img lazyload src="/images/loading.svg" data-src="/2021/12/12/js-44/pic10.png" class title="# tu1"><h3 id="3）devicemotion事件"><a href="#3）devicemotion事件" class="headerlink" title="3）devicemotion事件"></a>3）devicemotion事件</h3><ul><li>DeviceOrientationEvent规范也定义了devicemotion事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。</li><li>当devicemotion事件触发时，event对象中包含如下额外的属性。<ul><li>acceleration：对象，包含x、y和z属性，反映不考虑重力情况下各个维度的加速信息。</li><li>accelerationIncludingGravity：对象，包含x、y和z属性，反映各个维度的加速信息,包含z轴自然重力加速度。</li><li>interval：毫秒,距离下次触发devicemotion事件的时间。此值在事件之间应为常量。</li><li>rotationRate：对象，包含alpha、beta和l gamma属性，表示设备朝向。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件类型&quot;&gt;&lt;a href=&quot;#事件类型&quot; class=&quot;headerlink&quot; title=&quot;事件类型&quot;&gt;&lt;/a&gt;事件类型&lt;/h1&gt;&lt;h2 id=&quot;1、用户界面事件&quot;&gt;&lt;a href=&quot;#1、用户界面事件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="前端学习笔记" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="事件" scheme="http://example.com/categories/%E4%BA%8B%E4%BB%B6/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
