<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚永坤的小窝</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-13T16:29:51.925Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>姚永坤</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="http://example.com/2022/03/14/lc-104/"/>
    <id>http://example.com/2022/03/14/lc-104/</id>
    <published>2022-03-13T16:29:11.000Z</published>
    <updated>2022-03-13T16:29:51.925Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针 II</title>
    <link href="http://example.com/2022/03/14/lc-117/"/>
    <id>http://example.com/2022/03/14/lc-117/</id>
    <published>2022-03-13T16:13:47.000Z</published>
    <updated>2022-03-13T16:37:21.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree//">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue =[],result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length !==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/maximum-depth-o</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>116. 填充每个节点的下一个右侧节点指针</title>
    <link href="http://example.com/2022/03/13/lc-116/"/>
    <id>http://example.com/2022/03/13/lc-116/</id>
    <published>2022-03-13T15:15:05.000Z</published>
    <updated>2022-03-13T15:52:13.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例 1：</p><img lazyload src="/images/loading.svg" data-src="/2022/03/13/lc-116/pic1.png" class title="# tu1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>进阶：<br>    你只能使用常量级额外空间。<br>    使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>整体思路还是层序遍历，这里我们利用栈来调整next指针的指向。</li><li>我们在利用栈进行层序遍历的时候，根本上就是利用了先进先出的特点。我们可以将当前元素出栈，然后判断栈内是否还有元素，如果有则将当前元素next指针指向栈顶元素；反之则将next指针指向null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue =[];</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len-<span class="number">1</span> ) node.next = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> node.next = <span class="literal">null</span>;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/populating-next</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="http://example.com/2022/03/13/lc-515/"/>
    <id>http://example.com/2022/03/13/lc-515/</id>
    <published>2022-03-13T13:36:32.000Z</published>
    <updated>2022-03-13T13:46:02.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [1,2,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用层序遍历查找最大值。</li><li>注意用于记录最大值的变量的初始化赋值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestValues = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue =[], result =[];</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> cur_max = -<span class="literal">Infinity</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            cur_max = cur_max &gt; node.val ? cur_max : node.val;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(cur_max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/find-largest-va</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>429. N 叉树的层序遍历</title>
    <link href="http://example.com/2022/03/13/lc-429/"/>
    <id>http://example.com/2022/03/13/lc-429/</id>
    <published>2022-03-13T13:00:05.000Z</published>
    <updated>2022-03-13T13:21:54.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li><p>这里解题思路与二叉树的层序遍历一样，我们只需要注意N叉树的存储结构就可以很轻松的完成遍历。</p></li><li><p>针对示例中的N叉树存储结构如下：</p></li></ul><img lazyload src="/images/loading.svg" data-src="/2022/03/13/lc-429/pic1.png" class title="# tu1"><p>所以我们每次只需要访问其children，如果不为null，则将它们拼接起来，然后返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node|null&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue =[], result =[];</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">console</span>.log(root);</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length !==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curLevel =[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.children)</span><br><span class="line">                queue = queue.concat(node.children);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/average-of-leve</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="http://example.com/2022/03/13/lc-637/"/>
    <id>http://example.com/2022/03/13/lc-637/</id>
    <published>2022-03-13T12:16:35.000Z</published>
    <updated>2022-03-13T12:31:41.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><p>示例 1：</p><img lazyload src="/images/loading.svg" data-src="/2022/03/13/lc-637/tree.jpg" class title="# tu1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> averageOfLevels = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue =[], result =[];</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            tmp += node.val;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(tmp / len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/average-of-leve</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="http://example.com/2022/03/13/lc-199/"/>
    <id>http://example.com/2022/03/13/lc-199/</id>
    <published>2022-03-13T10:28:38.000Z</published>
    <updated>2022-03-13T12:28:35.592Z</updated>
    
    <content type="html"><![CDATA[<ol start="637"><li>二叉树的层平均值</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;637&quot;&gt;
&lt;li&gt;二叉树的层平均值&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记（六）二叉树的层序遍历（理论）</title>
    <link href="http://example.com/2022/03/13/algo-6/"/>
    <id>http://example.com/2022/03/13/algo-6/</id>
    <published>2022-03-13T08:16:12.000Z</published>
    <updated>2022-03-13T08:19:55.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><ul><li>层序遍历一个二叉树就是：<strong>从左到右一层一层的去遍历二叉树。</strong></li><li>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></li></ul><h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><a href="/2022/03/13/lc-102/" title="102. 二叉树的层序遍历">102. 二叉树的层序遍历</a><a href="/2022/03/13/lc-107/" title="107. 二叉树的层序遍历 II">107. 二叉树的层序遍历 II</a><a href="/2021/07/21/js-5-1/" title="Undefined、Null、Boolean">Undefined、Null、Boolean</a>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;层序遍历一个二叉树就是：&lt;strong&gt;从左到右一层一层的去遍历二叉树。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;需</summary>
      
    
    
    
    <category term="算法学习笔记" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="算法学习" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>107. 二叉树的层序遍历 II</title>
    <link href="http://example.com/2022/03/13/lc-107/"/>
    <id>http://example.com/2022/03/13/lc-107/</id>
    <published>2022-03-13T08:12:57.000Z</published>
    <updated>2022-03-13T08:18:55.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><p><a class="link" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>示例 1：</p><img lazyload src="/images/loading.svg" data-src="/2022/03/13/lc-107/tree1.png" class title="# tu1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>与lc-102思路一样。</li></ul><a href="/2022/03/13/lc-102/" title="102. 二叉树的层序遍历">102. 二叉树的层序遍历</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [],result =[];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.unshift(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目一&quot;&gt;&lt;a href=&quot;#题目一&quot; class=&quot;headerlink&quot; title=&quot;题目一&quot;&gt;&lt;/a&gt;题目一&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/binary-tree</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://example.com/2022/03/13/lc-102/"/>
    <id>http://example.com/2022/03/13/lc-102/</id>
    <published>2022-03-13T07:46:52.000Z</published>
    <updated>2022-03-13T10:56:07.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><img lazyload src="/images/loading.svg" data-src="/2022/03/13/lc-102/tree1.png" class title="# tu1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [],result = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">// 将当前节点取出</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            <span class="comment">// 存储当前层中的节点</span></span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="comment">// 只有该节点存在左/右子节点的时候才会将值存在queue中</span></span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储形成二维数组形式</span></span><br><span class="line">        result.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/binary-tree-lev</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://example.com/categories/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记（五）回溯算法</title>
    <link href="http://example.com/2022/03/13/algo-5/"/>
    <id>http://example.com/2022/03/13/algo-5/</id>
    <published>2022-03-13T07:08:02.000Z</published>
    <updated>2022-03-13T07:10:59.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是回溯法&quot;&gt;&lt;a href=&quot;#什么是回溯法&quot; class=&quot;headerlink&quot; title=&quot;什么是回溯法&quot;&gt;&lt;/a&gt;什么是回溯法&lt;/h1&gt;</summary>
      
    
    
    
    <category term="算法学习笔记" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="回溯算法" scheme="http://example.com/categories/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法学习" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记（四）常见的排序算法</title>
    <link href="http://example.com/2022/03/01/algo-4/"/>
    <id>http://example.com/2022/03/01/algo-4/</id>
    <published>2022-03-01T14:43:17.000Z</published>
    <updated>2022-03-13T07:06:48.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><ul><li>比较类排序：<strong>通过比较来决定元素间的相对次序</strong>，由于其时间复杂度不能突破O(nlogn)，因此也称为<strong>非线性时间比较类排序</strong>。</li><li>非比较类排序：<strong>不通过比较来决定元素间的相对次序</strong>，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/03/01/algo-4/pic1.webp" class title="# tu1"><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><img lazyload src="/images/loading.svg" data-src="/2022/03/01/algo-4/pic2.webp" class title="# tu1"><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul><li>将原序列分为已排序与未排序的两部分。</li><li>外层循环遍历整个序列，标记当前待插入元素。</li><li>内层循环遍历已排序序列，从有序表的尾部开始与当前值进行比较移动。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/03/01/algo-4/pic3.webp" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j-<span class="number">1</span>] &gt; nums[j])&#123;</span><br><span class="line">                [nums[j - <span class="number">1</span>],nums[j]] = [nums[j],nums[j-<span class="number">1</span>]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li></ul><img lazyload src="/images/loading.svg" data-src="/2022/03/01/algo-4/pic4.webp" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[min] &gt; nums[j])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [nums[i],nums[min]]=[nums[min],nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>找一个目标值，将数组中值与与其比较，小于它的放在一个数组中，大于它的放在另一个数组中；</li><li>分别对以上两个数组进行同等操作，直至排序完成，然后从左至右再次将其连接起来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;=<span class="number">1</span> ) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">let</span> midIndex = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> mid = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left = [],right = [];</span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e &lt; mid) left.push(e);</span><br><span class="line">        <span class="keyword">else</span> right.push(e);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sortArray(left).concat(mid,sortArray(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序不是一个比较排序算法，该算法于1954年由 Harold H. Seward提出，通过计数将时间复杂度降到了O(N)。</p><p>第一步：找出原数组中元素值最大的，记为max。</p><p>第二步：创建一个新数组count，其长度是max加1，其元素默认值都为0。</p><p>第三步：遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</p><p>第四步：创建结果数组result，起始索引index。</p><p>第五步：遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。</p><p>第六步：返回结果数组result。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...nums);</span><br><span class="line">    <span class="keyword">let</span> len = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        arr[i - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result.push(i + min);</span><br><span class="line">            arr[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;算法分类&quot;&gt;&lt;a href=&quot;#算法分类&quot; class=&quot;headerlink&quot; title=&quot;算法分类&quot;&gt;&lt;/a&gt;算法分类&lt;/h</summary>
      
    
    
    
    <category term="算法学习笔记" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="排序算法" scheme="http://example.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法学习" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>lc-94</title>
    <link href="http://example.com/2022/02/28/lc-94/"/>
    <id>http://example.com/2022/02/28/lc-94/</id>
    <published>2022-02-28T14:10:34.000Z</published>
    <updated>2022-02-28T14:10:34.580Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="http://example.com/2022/02/28/lc-145/"/>
    <id>http://example.com/2022/02/28/lc-145/</id>
    <published>2022-02-28T14:06:41.000Z</published>
    <updated>2022-02-28T15:00:18.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[3,2,1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        result.push(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 根节点先入栈</span></span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="comment">// 栈顶出战</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        result.push(cur.val);</span><br><span class="line">        <span class="comment">// 中右左进栈</span></span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/binary-tree-pos</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树遍历" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>144. 二叉树的前序遍历</title>
    <link href="http://example.com/2022/02/28/lc-144/"/>
    <id>http://example.com/2022/02/28/lc-144/</id>
    <published>2022-02-28T14:00:55.000Z</published>
    <updated>2022-02-28T14:54:59.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.push(root.val);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><img lazyload src="/images/loading.svg" data-src="/2022/02/28/lc-144/pic1.gif" class title="# tu1"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 根节点先入栈</span></span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="comment">// 栈顶出战</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        result.push(cur.val);</span><br><span class="line">        <span class="comment">// 中左右进栈</span></span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/binary-tree-pre</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树遍历" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>347.前 K 个高频元素</title>
    <link href="http://example.com/2022/02/28/lc-347/"/>
    <id>http://example.com/2022/02/28/lc-347/</id>
    <published>2022-02-28T13:34:44.000Z</published>
    <updated>2022-02-28T14:02:15.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/valid-anagram">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>首先利用哈希表进行频数统计；</li><li>将哈希表转换成数组，利用sort函数进行排序</li><li>输出排序结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length === <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">let</span> hmap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        hmap.set(v,(hmap.get(v) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Array</span>.from(hmap).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> result.slice(<span class="number">0</span>,k).map(<span class="function"><span class="params">n</span>=&gt;</span>n[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="算法优化（小顶堆）"><a href="#算法优化（小顶堆）" class="headerlink" title="算法优化（小顶堆）"></a>算法优化（小顶堆）</h2><p>待定……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/valid-anagram&quot;&gt;</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="小顶堆" scheme="http://example.com/categories/%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题-JS篇（一）</title>
    <link href="http://example.com/2022/02/27/interview-JS-1/"/>
    <id>http://example.com/2022/02/27/interview-JS-1/</id>
    <published>2022-02-27T08:18:12.000Z</published>
    <updated>2022-03-08T14:48:59.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、浏览器本地存储是怎样的？"><a href="#1、浏览器本地存储是怎样的？" class="headerlink" title="1、浏览器本地存储是怎样的？"></a>1、浏览器本地存储是怎样的？</h1><ul><li>Cookie存储：明文，大小限制 4k 等。</li><li>localStorage：持久化存储方式之一，不用在两端之间传输，且限制大小为10M</li><li>sessionStorage，会话级存储方式，浏览器关闭立即数据丢失</li><li>indexDb，浏览器端的数据库</li></ul><h1 id="2、AJAX的优缺点"><a href="#2、AJAX的优缺点" class="headerlink" title="2、AJAX的优缺点"></a>2、AJAX的优缺点</h1><ul><li>优点：<ul><li>可以无刷新页面与服务端进行通信</li><li>允许你根据用户事件来更新部分页面内容</li></ul></li><li>缺点：<ul><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好（爬虫获取不到信息）</li></ul></li></ul><h1 id="3、防抖和节流"><a href="#3、防抖和节流" class="headerlink" title="3、防抖和节流"></a>3、防抖和节流</h1><ul><li>防抖：用户触发事件过于频繁，只需要最后一次事件的结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">el.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======封装========</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antiShaking</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>);</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>节流：控制高频事件的执行次数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======封装========</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.call(<span class="built_in">this</span>);</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、call、apply、bind"><a href="#4、call、apply、bind" class="headerlink" title="4、call、apply、bind"></a>4、call、apply、bind</h1><ul><li>这三个方法均为函数对象上的方法。</li><li>三个方法均用于改变函数中this指向。</li><li>区别：<ul><li>call vs apply ： 传参形式不一样；</li><li>call vs bind ： call改变this指向后会立即调用，bind不会。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    food : <span class="string">&quot;骨头&quot;</span>,</span><br><span class="line">    name : <span class="string">&quot;汪汪&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params">food1,food2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我爱吃&quot;</span> + food1 + food2);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    name: <span class="string">&quot;喵喵&quot;</span>,</span><br><span class="line">    food: <span class="string">&quot;鱼&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.say(cat);<span class="comment">//我是喵喵</span></span><br><span class="line">dog.eat.call(cat,<span class="string">&quot;鱼&quot;</span>,<span class="string">&quot;猫粮&quot;</span>);<span class="comment">//我爱吃鱼猫粮</span></span><br><span class="line">dog.eat.apply(cat,[<span class="string">&quot;鱼&quot;</span>,<span class="string">&quot;猫粮&quot;</span>]);<span class="comment">//我爱吃鱼猫粮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = dog.eat.bind(cat,<span class="string">&quot;鱼&quot;</span>,<span class="string">&quot;猫粮&quot;</span>);</span><br><span class="line">fn();<span class="comment">//我爱吃鱼猫粮</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、浏览器本地存储是怎样的？&quot;&gt;&lt;a href=&quot;#1、浏览器本地存储是怎样的？&quot; class=&quot;headerlink&quot; title=&quot;1、浏览器本地存储是怎样的？&quot;&gt;&lt;/a&gt;1、浏览器本地存储是怎样的？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Cookie存储：明文，大小限制</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端面试题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题-CSS篇（二）</title>
    <link href="http://example.com/2022/02/27/interview-CSS-2/"/>
    <id>http://example.com/2022/02/27/interview-CSS-2/</id>
    <published>2022-02-27T06:28:50.000Z</published>
    <updated>2022-02-27T07:56:32.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、自适应布局"><a href="#1、自适应布局" class="headerlink" title="1、自适应布局"></a>1、自适应布局</h1><ul><li>使用flex；</li><li>左侧浮动或者绝对定位，右侧margin撑开使用div包含，靠-margin形成BFC；</li></ul><h1 id="2、display相关参数"><a href="#2、display相关参数" class="headerlink" title="2、display相关参数"></a>2、display相关参数</h1><ul><li>block：块级元素；</li><li>inline：等行元素；</li><li>table：table类型</li><li>flex：弹性布局，子元素的float、clear和vertical-align属性将失效</li><li>inline-block：行内块元素</li></ul><h1 id="3、display-none-和-visibility-hidden-的区别"><a href="#3、display-none-和-visibility-hidden-的区别" class="headerlink" title="3、display:none 和 visibility:hidden 的区别"></a>3、display:none 和 visibility:hidden 的区别</h1><ul><li>display:none 隐藏对应的元素，<strong>在文档布局中不再给它分配空间</strong>，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden 隐藏对应的元素，但是<strong>在文档布局中仍保留原来的空间</strong>。</li></ul><h1 id="4、position的absolute-与fixed共同点与不同点"><a href="#4、position的absolute-与fixed共同点与不同点" class="headerlink" title="4、position的absolute 与fixed共同点与不同点"></a>4、position的absolute 与fixed共同点与不同点</h1><ul><li>共同点：<ul><li>改变行内元素的呈现方式，display被置为block；</li><li>让元素脱离普通流，不占据空间；</li><li>默认会覆盖到非定位元素上不同点；</li></ul></li><li>不同点：<ul><li>absolute的“根元素”是可以设置的，而 fixed 的“根元素”固定为浏览器窗口。</li></ul></li></ul><h1 id="5、position的值分别是相对于谁进行定位的"><a href="#5、position的值分别是相对于谁进行定位的" class="headerlink" title="5、position的值分别是相对于谁进行定位的"></a>5、position的值分别是相对于谁进行定位的</h1><ul><li>absolute：相对于static定位以外的第一个祖先元素。</li><li>fixed：相对于浏览器窗口进行定位。</li><li>relative：相对于其在普通流中的位置进行定位</li><li>static，默认值，没有定位，元素出现在正常的流中。</li><li>inherit：从父元素继承position。</li></ul><h1 id="6、为什么要初始化CSS"><a href="#6、为什么要初始化CSS" class="headerlink" title="6、为什么要初始化CSS"></a>6、为什么要初始化CSS</h1><ul><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</li></ul><h1 id="7、canvas在标签山设置宽高和在style中设置宽高有什么区别"><a href="#7、canvas在标签山设置宽高和在style中设置宽高有什么区别" class="headerlink" title="7、canvas在标签山设置宽高和在style中设置宽高有什么区别"></a>7、canvas在标签山设置宽高和在style中设置宽高有什么区别</h1><ul><li>标签的width和height是画布实际宽度和高度；</li><li>style的是canvas在浏览器中被渲染的高度和宽度。</li></ul><h1 id="8、CSS预处理器"><a href="#8、CSS预处理器" class="headerlink" title="8、CSS预处理器"></a>8、CSS预处理器</h1><ul><li>Sass，Less，Postcss</li><li>原理：将类CSS语言通过Webpack编译转成浏览器可读的真正CSS。</li></ul><h1 id="9、哪些属性可以继承"><a href="#9、哪些属性可以继承" class="headerlink" title="9、哪些属性可以继承"></a>9、哪些属性可以继承</h1><ul><li>可继承：font-size, font-family, color等</li><li>不可继承border, padding, margin, width, height</li></ul><h1 id="10、-before-和-after-中双冒号和单冒号有什么区别"><a href="#10、-before-和-after-中双冒号和单冒号有什么区别" class="headerlink" title="10、::before 和 :after 中双冒号和单冒号有什么区别"></a>10、::before 和 :after 中双冒号和单冒号有什么区别</h1><ul><li>单冒号用于CSS3伪类，双冒号用于CSS3伪元素。</li><li>CSS 伪类用于向某些选择器添加特殊的效果。</li><li>CSS 伪元素用于将特殊的效果添加到某些选择器。</li></ul><h1 id="11、什么是响应式设计？其基本原理是什么？"><a href="#11、什么是响应式设计？其基本原理是什么？" class="headerlink" title="11、什么是响应式设计？其基本原理是什么？"></a>11、什么是响应式设计？其基本原理是什么？</h1><ul><li>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</li><li>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</li><li>页面头部必须有meta声明的viewport。</li></ul><h1 id="12、浏览器是怎样解析CSS选择器的？"><a href="#12、浏览器是怎样解析CSS选择器的？" class="headerlink" title="12、浏览器是怎样解析CSS选择器的？"></a>12、浏览器是怎样解析CSS选择器的？</h1><ul><li>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则,需要进行回溯，会损失很多性能。</li><li>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</li><li>在CSS解析完毕后，需要将解析的结果与DOM Tree 的内容一起进行分析建立一棵Render Tree，最终用来进行绘图。</li></ul><h1 id="13、CSS优化、提高性能的方法有哪些？"><a href="#13、CSS优化、提高性能的方法有哪些？" class="headerlink" title="13、CSS优化、提高性能的方法有哪些？"></a>13、CSS优化、提高性能的方法有哪些？</h1><ul><li>避免过度约束</li><li>避免后代选择符避免链式选择符使用紧凑的语法</li><li>避免不必要的命名空间</li><li>避免不必要的重复</li><li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li><li>避免! important，可以选择其他选择器</li><li>尽可能的精简规则，你可以合并不同类里的重复规则</li></ul><h1 id="14-position跟display、overflow、float这些特性相互叠加后会怎么样"><a href="#14-position跟display、overflow、float这些特性相互叠加后会怎么样" class="headerlink" title="14.position跟display、overflow、float这些特性相互叠加后会怎么样?"></a>14.position跟display、overflow、float这些特性相互叠加后会怎么样?</h1><ul><li>display属性规定元素应该生成的框的类型;</li><li>position 属性规定元素的定位类型;</li><li>float属性是一种布局方式，定义元素在哪个方向浮动。</li><li>类似于优先级机制: <ul><li>position: absolute/fixed优先级最高,有他们在时, float不起作用, display值需要调整。</li><li>float或者absolute定位的元素，只能是块元素或表格。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、自适应布局&quot;&gt;&lt;a href=&quot;#1、自适应布局&quot; class=&quot;headerlink&quot; title=&quot;1、自适应布局&quot;&gt;&lt;/a&gt;1、自适应布局&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用flex；&lt;/li&gt;
&lt;li&gt;左侧浮动或者绝对定位，右侧margin撑开使用div包</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    <category term="前端面试题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JS学习" scheme="http://example.com/tags/JS%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="http://example.com/2022/02/27/lc-150/"/>
    <id>http://example.com/2022/02/27/lc-150/</id>
    <published>2022-02-26T18:00:36.000Z</published>
    <updated>2022-02-27T05:27:58.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用栈的思想，先进后出。</li><li>使用map来进行存储计算符对应的计算操作。</li><li>当遇到计算符的时候，将栈顶前两个元素出栈，然后映射到对应方法上，再将计算的结果存入栈中。</li><li>循环以上操作直至遍历完整个数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">tokens</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&quot;+&quot;</span>,<span class="function">(<span class="params">a,b</span>)=&gt;</span> a * <span class="number">1</span> + b * <span class="number">1</span>],</span><br><span class="line">        [<span class="string">&quot;-&quot;</span>,<span class="function">(<span class="params">a,b</span>)=&gt;</span> b - a],</span><br><span class="line">        [<span class="string">&quot;*&quot;</span>,<span class="function">(<span class="params">a,b</span>)=&gt;</span> b * a],</span><br><span class="line">        [<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">a,b</span>)=&gt;</span> (b / a) | <span class="number">0</span>]</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> tokens)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(i))&#123;</span><br><span class="line">            tmp.push(i);</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push(map.get(i)(tmp.pop(),tmp.pop()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/evaluate-revers</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈和队列" scheme="http://example.com/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1047. 删除字符串中的所有相邻重复项</title>
    <link href="http://example.com/2022/02/26/lc-1047/"/>
    <id>http://example.com/2022/02/26/lc-1047/</id>
    <published>2022-02-26T13:28:54.000Z</published>
    <updated>2022-02-26T14:31:56.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a class="link" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">点击前往<i class="fas fa-external-link-alt"></i></a></p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul><li>利用栈的思想，判断相邻的两个字符是否相同，如果相同则将栈顶元素出栈，否则该字符入栈。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.length === <span class="number">0</span>) stack.push(i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack[stack.length-<span class="number">1</span>]===i)</span><br><span class="line">                stack.pop(stack[stack.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/remove-all-adja</summary>
      
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    <category term="前端刷题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈和队列" scheme="http://example.com/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="LeetCode刷题" scheme="http://example.com/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
