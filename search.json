[{"title":"Hello World","url":"/2021/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Markdown学习笔记","url":"/2021/03/12/markdown-study-notes/","content":" 之前只是用markdown写过博客并没有系统的去了markdown语法，现在将创建博客后的第一篇文章用来记录我学习markdown的经历以及对于知识点的理解。\nmarkdown官方介绍和个人理解菜鸟教程介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n个人理解\nMarkdown是一种纯文本标记语言\n语法简单，容易上手\n按照语法，自动排版，格式易操作\n……\n\n语法学习标题标题有两种书写格式，推荐使用第一种。\n# 号标识标题\n用法：使用 # 号可表示 1-6 级标题，每升一级添加一个 # 号\n易错点：最后一个 # 号后空一格\n示例：# 一级标题## 二级标题\n结果\n  \n\n\n= 和 - 标记标题\n用法：在对应文字下方输入 = （-）即可\n示例：一级标题=二级标题-\n结果\n\n\n\n段落格式换行\n实现方式：\n句子末尾空两格然后回车\n空一行实现换行\n\n\n\n字体斜体*猫猫头*_猫猫头_\n粗体**猫猫头**__猫猫头__\n粗斜体***猫猫头***___猫猫头___\n\n分割线\n实现方式：\n在一行中用三个以上的星号、减号、底线来建立一个分隔线。\n行内不能有其他东西。\n可以在星号或是减号中间插入空格。\n\n\n\n删除线（在文字上添加删除线）\n实现方式：~~猫猫头的小窝~~\n效果展示：猫猫头的小窝\n\n下划线\n实现方式：&lt;u&gt;猫猫头的小窝&lt;/u&gt;\n效果展示：猫猫头的小窝\n\n脚注\n补充说明词语或者句子内容。\n可用于标注出处，翻译等。\n实现方式：“[^情不知所起，一往而深。]”[^情不知所起，一往而深。]:感情不知道什么时候就开始了，而且愈来愈深厚。\n效果展示：“情不知所起，一往而深。”\n\n列表有序、无序列表\n实现方式：\n有序：数字并加上 . 号来表示。\n无序：星号(*)、加号(+)或是减号(-)作为列表标记，且标记后面要添加一个空格。\n\n\n\n列表嵌套\n实现方式：在子列表中的选项前面添加四个空格（或者一个Tab键）\n例子：1. 猫猫头：    - 猫猫头的代码库    - 猫猫头的图片库\n\n\n\n\n区块\n实现方式：在段落开头使用 &gt; 符号，后面紧跟一个空格符号。\n嵌套使用：\n区块嵌套：每增加一个 &gt; 符号增加一层。\n区块嵌套列表：&gt; + 猫猫头的代码库&gt; + 猫猫头的图片库\n\n\n猫猫头的代码库\n猫猫头的图片库\n\n\n\n列表嵌套区块：1. 猫猫头    &gt; 猫猫头的图片库    &gt; 猫猫头的代码库\n\n\n猫猫头\n猫猫头的图片库猫猫头的代码库\n\n\n\n\n\n代码\n实现方式：\n代码区块：\n使用 4 个空格或者一个制表符（Tab 键）。\n用 ``` 包裹一段代码，并指定一种语言，也可以不指定（推荐）。\n\n\n\n\n\n链接\n实现方法：[链接名称](链接地址)或者&lt;链接地址&gt;\n例子：[百度](www.baidu.com)\n\n图片\n实现方式：![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n\n补充：可以使用&lt;img&gt;标签，用于指定图片的高度与宽度。\n\n表格\n实现方式：\n使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n\n示例：| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n总结这里就暂时总结了markdown一些基本用法，能够满足用来写博客就可以了，后面继续加油吧！有什么问题可以留言哦！\n","categories":["markdown"],"tags":["markdown","study notes"]},{"title":"Python max函数不同参数结果比较","url":"/2021/03/15/python-skill-max/","content":"前言&emsp; &emsp; 在菜鸟教程中对于max函数描述是这样的：max() 方法返回给定参数的最大值，参数可以为序列。这个描述只是客观的将这个函数的功能给描述出来了，但这只是一个模糊的定义。由于没有指定可传入参数的类型，所以说这就带给了这个函数无限种可能。现在就来讨论讨论吧！如果有哪些地方表述不是很正确希望大家在评论区指出来哦！\n数字类型&emsp; &emsp; 首先我们来看看最简单大数字类型。毋庸置疑，当参数是数字的时候，直接返回最大的数就好了。但是要注意的是这里的数字指的是一系列数，返回其中最大的。下面来看一个简单的例子。\n&gt;&gt;&gt; max(1,2,3,4,5,6,7,8,9)9\n\n字符串类型&emsp; &emsp; 我们知道python中字符串是由单引号双引号括起来的一个字符序列。那么当输入max的变量为一个字符串它会返回给我们什么结果呢？\n&emsp; &emsp; 我们先看下面这个例子：\n&gt;&gt;&gt;a=&#x27;1,6,0,4,5&#x27;&gt;&gt;&gt;max(a)&#x27;6&#x27;\n我们输入一个由单个数字组成的字符串，穿入max函数后返回了其中的 ‘6’ 这个字符。难道是将字符转化为数字然后再比较大小吗？那字符串中的 ‘,’ 又去哪了呢？那如果是字母又如何进行比较呢？来看下一个例子：\n&gt;&gt;&gt;b=&#x27;fabced&#x27;&gt;&gt;&gt;max(b)&#x27;f&#x27;\n这里变量b为一个字母组成的字符串，结果返回给我们的是字符 ‘f’ ，这里我们大致应该可以判断出来：当max函数的输入变量为一个字符串的时候，则返回字符串中字符所对应的ASCII码最大的那个字符。\n&emsp; &emsp; 为了验证这一结论我们利用下面这个例子进行验证：\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;max(c)&#x27;c&#x27;\n&emsp; &emsp; 从这个例子我们就可以验证刚刚的结论了：c这个字符串中字符’1’’a’’2’’c’对应的ASCII码的大小分别为49，97，50，99，所以字符’c’所对应的ASCII码值最大固返回字符’c’。那么字符’,’去哪了呢？实际上字符’,’也是参与了比较，由于它所对应的ASCII码为44最小，所以看似跟舍弃了一样。\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;min(c)&#x27;,&#x27;\n\n另外，max函数还可以对于传入的可迭代对象找出元素中的最大值。这里可迭代的对象主要是列表和字典\n列表同样对于列表，它满足可迭代这样一个特点，这里我们主要分四种情况来讨论：\n\n元素全为数字&gt;&gt;&gt;a=[1,2,3,4,5]&gt;&gt;&gt;max(a)5\n元素全为字符&gt;&gt;&gt;b=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]&gt;&gt;&gt;max(b)&#x27;e&#x27;\n&gt;&gt;&gt;c=[&#x27;ab&#x27;,&#x27;ac&#x27;,&#x27;ad&#x27;,&#x27;ae&#x27;]&gt;&gt;&gt;max(c)&#x27;ae&#x27;\n&gt;&gt;&gt;d=[&#x27;1a&#x27;,&#x27;1b&#x27;,&#x27;2a&#x27;,&#x27;2b&#x27;]&gt;&gt;&gt;max(d)&#x27;2b&#x27;\n通过以上几个例子我们不难发现：\n列表中元素类型需一致；（前提条件）\n若列表中元素数字类型值，则返回列表中元素的最大值；\n若列表中元素为字符，字符转换为对应ASCII码值输出最大的；\n若列表中元素为字符串，将组成字符串的每个字符的ASCII码相加，然后输出最大的。\n\n列表（元组）刚刚我们讨论了简单元素组成的列表作为参数的情况，接下来我们看一看由元组组成的列表：我们还是按照上面的步骤来。\n\n全为数字\n&gt;&gt;&gt;a=[(1,3),(2,2),(1,4),(3,0)]&gt;&gt;&gt;max(a)(3,0)\n对应位置元素类型相同\n&gt;&gt;&gt;b=[(&#x27;a&#x27;,1),(&#x27;b&#x27;,5),(&#x27;a&#x27;,6)]&gt;&gt;&gt;max(b)(&#x27;b&#x27;,5)\n&gt;&gt;&gt;c=[(&#x27;a&#x27;,&#x27;A&#x27;),(&#x27;a&#x27;,&#x27;B&#x27;)]&gt;&gt;&gt;max(c)(&#x27;a&#x27;,&#x27;B&#x27;)\n元组大小不一致\n&gt;&gt;&gt;d=[(1,4),(3,1,5),(3,1)]&gt;&gt;&gt;max(d)(3,1,5)\n对应位置元素不同\n&gt;&gt;&gt;e=[(6,4),(6,1,5),(3,&#x27;a&#x27;)]&gt;&gt;&gt;max(e)(6,4)\n&gt;&gt;&gt;f=[(1,4),(&#x27;a&#x27;,2),(3,1)]&gt;&gt;&gt;max(e)TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;\n通过以上几个例子对比分析我们不难发现：\n\n按照元组内部排列顺序从前到后对应位置进行比较，如果对应位置元素类型和大小相同，则比较下一个位置的元素，按照此规则进行比较直至找到最大值或者出错。\n\n类型不匹配：列表元组中当比较到对应位置发现存在相比较的两个元素类型不相同时报错；\n\n当比较位置不存在元素时，默认为NUL；\n\n当比较的元素为数字类型值，则返回列表中元素的最大值；\n\n当比较的元素为字符，字符转换为对应ASCII码值返回；\n\n当比较的元素为字符串，将组成字符串的每个字符的ASCII码相加返回。\n\n\n字典\n对于字典类型来说相比较容易一些，只需要比较字典的键值，输出最大的键值；\n键值的比较同上。\n\n&gt;&gt;&gt;a=&#123;1:1,2:19,3:100,4:1&#125;&gt;&gt;&gt;max(a)4&gt;&gt;&gt;b=&#123;20:21,5:20,13:14&#125;&gt;&gt;&gt;max(b)20","categories":["python"],"tags":["Skill","python"]},{"title":"Python 字符串连接方法","url":"/2021/03/16/python-skill-string-concatenation/","content":"之前在学习Python的时候对于字符串的连接并没有过多的研究，能应付考试就好啦。最近在写博客遇到相关内容去查了查，发现字符串连接的方法还是非常多的，这篇博客就来记录一下方便以后查看。\n字符串连接方法总结假设’str1’，’str2’为两个字符串。\n‘+’ 连接a = str1b = str2print(a+b)&gt;&gt;&gt;str1str2\n\n模式串”%s”方法print（&#x27;%s%s&#x27; %(str1,str2)）&gt;&gt;&gt;str1str2\nformat 方法print(&quot;&#123;&#125;&#123;&#125;&quot;.format(str1，str2))print(&quot;&#123;0&#125;&#123;1&#125;&quot;.format(str1，str2))print(&quot;&#123;c&#125;&#123;d&#125;&quot;.format(c=str1，d=str2))&gt;&gt;&gt;str1str2\n‘f-string’方法print(f&#x27;&#123;str1&#125;&#123;str2&#125;&#x27;) &gt;&gt;&gt;str1str2\njoin方法\n列表print(&#x27;&#x27;.join([str1,str2])) &gt;&gt;&gt;str1str2\n字典：只有键和值均为字符串时才可使用。a=&#123;&#x27;20&#x27;:&#x27;20&#x27;,&#x27;520&#x27;:&#x27;1314&#x27;&#125;print(&#x27;&#x27;.join(a))print(&#x27;&#x27;.join(a.value（））) &gt;&gt;&gt; &#x27;20520&gt;&gt;&gt; &#x27;201314&#x27;\n通过() 多行拼接s = (    &#x27;Hello&#x27;    &#x27; &#x27;    &#x27;World&#x27;    &#x27;!&#x27;)print(s)&gt;&gt;&gt; Hello World! \n通过string模块中的Template对象拼接\n实现原理：通过Template初始化一个字符串。这些字符串中包含了一个个key。通过调用substitute或safe_subsititute，将key值与方法中传递过来的参数对应上，从而实现在指定的位置导入字符串。from string import Templates = Template(&#x27;$&#123;s1&#125; $&#123;s2&#125;!&#x27;)print(s.safe_substitute(s1=&#x27;Hello&#x27;,s2=&#x27;World&#x27;))&gt;&gt;&gt; Hello World\n空格自动连接&gt;&gt;&gt; &quot;Hello&quot; &quot;Nasus&quot;&#x27;HelloNasus&#x27;\n\n","categories":["python"],"tags":["Skill","python"]},{"title":"python学习笔记（一）","url":"/2021/03/15/python-study-note/","content":"本科学习python课程笔记，之前使用的有道云笔记记载，现在将它搬运到博客中。\n第一章是一些基本概念，所以从第二章开始记的。所以，一起加油咯！\n\n第二章主要是turtle库的使用，然后简单介绍了python中的字符串的使用，第三章会详细讲字符串。\n字符串简单介绍字符串的两种序号表达\n假设字符串长度为L：\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n\n\n\n字符串截取范围\nTempStr[0:-1]    从0到-1，但不包括-1\n口诀：前取后不取\n\nturtle库介绍&emsp; &emsp; 实际上我们使用turtle库来绘制图形就是：在操纵“小海龟”在我们所定义的画布（canvas）（或者叫做窗体也可以）上进行爬行，它行动留下的痕迹就是我们所要绘制图形的轮廓。&emsp; &emsp; 在了解绘制原理后我们就对于这个必不可少的画布进行了解和学习。\n画布坐标轴&emsp; &emsp; 一般情况下，当你创建了一个画布它就会对应的生成坐标轴，一方面是为了方便我们绘制图形；另一方面也是为了避免造成歧义导致出错。&emsp; &emsp; 下图是对应坐标系的规定：\n\n\n\n画布（窗体）的创建\nturtle.screensize(canvwidth=None,canvheight=None,bg=None)\n参数：画布宽、高、背景色\n\n\nturtle.setup(width, height, startx, starty)\n参数：窗体宽、高、窗体左上角顶点的横纵坐标\n输入宽和高为整数时,表示像素;为小数时,表示占据电脑屏幕的比例\n\n\n\n画笔&emsp; &emsp;默认情况下，我们的“画笔”是一个位于坐标原点面朝正向的小海龟，我们通过控制小海龟来完成图形的绘制。\n画笔的属性\nturtle.pensize/width(width)\n用于设置画笔宽度\n\n\nturtle.pencolor()\n用于设置画笔颜色\n\n\nturtle.speed(x)\n用于设置画笔速度，0≤x≤10\n\n\n\n画笔移动状态\nturtle.forward/backward(d)\n向前/向后移动距离为d\n\n\nturtle.right/left(r)\n向左/右转动度数\n\n\nturtle.down/up()\n画笔落下/抬起\n\n\nturtle.fillcolor()\n给绘制的图形填充颜色\n\n\nturtle.circle(r,angle)\n绘制圆，半径正负均可，angle为角度\n\n\n\n\nturtle.done()\n结束程序\n\n\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"python学习笔记（二）","url":"/2021/03/15/python-study-notes-2/","content":"第三章这一章主要是对基本数据类型的学习，包括数字和字符串类型以及对应的操作。\n数字类型\n类型：整数、浮点数、复数\n\n浮点数\n浮点数间运算存在不确定尾数，如下图所示：\n\n\n原因：浮点数是小数的一种二进制表示方法，由于浮点数存在精度限制，在使用浮点数做运算时就可能会产生不确定尾数。\n解决方法：round(x,d)对x四舍五入，d是小数截取位数。\n\n\n科学计数法\n\n\n复数\n实、虚部获取方法：z为一复数\n实部：z.real\n虚部：z.imag\n\n\n\n数字类型关系\n不同类型间可进行混合运算，生成结果为”最宽”类型\n整数 &gt; 浮点数 &gt; 复数\n\n数值运算函数常用函数abs(x)\n对于x取绝对值\n\nsqrt(x)\nx的平方根\n\npow(x,y)\nx的y次幂\n\nround(x,[d])\n对于数x，四舍五入保留d位\n\nmax()/min()\n返回给定参数的最大值\n参数可以为：数字、字符串、列表、元组\n不同参数返回结果请参考这篇文章：max不同参数比较\n\nint(x)\n将x变成整数，直接舍弃小数部分；\n参数：数字，字符\n\nfloat(x)\n将x变成浮点数，增加小数部分\n参数：数字，字符\n\n字符串字符串表示方法\n一对单、双或三引号构成\n多行字符串表示方法：\n三引号\n小括号\n\n\n单、双、三引号的使用：  &#x27;这里有个&quot;双引号&quot;哦&#x27; &quot;这里有个&#x27;单引号&#x27;嘎&quot;&#x27;&#x27;&#x27; 这里既有&#x27;单引号&#x27;嘎，又有&quot;双引号&quot;哦  &#x27;&#x27;&#x27;\n\n字符串排序\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n字符串字符的获取\n假设变量name为一字符串，其中N、M均为索引号：\n获取单个字符：name[N];\n获取一段字符串：name[N:M];\n根据步长K切片：name[N:M:K];\n\n\n\n字符串的操作符、处理函数和方法字符串的操作符\nx+y\n连接两个字符串x和y\n字符串连接方法\n\n\nx*n\n复制n次字符串x\n\n\nx in s\n判断x是否是s的子串，，是返回true，否返回false\n\n\n\n字符串常用处理函数和方法\nlen(x)：返回字符串长度\nstr(x)：任意类型x对应的字符串形式\nstr.lower()/upper()\n返回新的字符串，全部字符小写/大写\n\n\nstr.split(sep)\n返回的是一个列表，将源字符串按照sep进行分割\n\n\nstr.count(sub)\n返回字串sub在str中出现的次数\n\n\nstr.replace(old,new)\n返回新的字符串，将str中所有old子串替换为new\n\n\nstr.center(width[,fillchart])\n字符串str根据宽度width居中，fillchart为剩余区域的填充字符\n\n\nstr.join(item)\n在item除最后一个元素外增加一个str\n多用于字符串分割\n\n\n\n字符串类型格式化\n&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)\n槽：\n槽内部对格式化的配置方式\n\n&gt;&gt;&gt; &quot;&#123;0:=^20&#125;.format(&quot;python&quot;)&quot;&#x27;=======PYTHON======&#x27;\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"Python学习笔记（三）","url":"/2021/03/22/python-study-notes-3/","content":"程序控制结构是每一种程序设计语言都会涉及到的一块，这边文章就来讲讲python中的程序设计结构。\n条件语句用于条件组合的三个保留字设x，y为两个条件：\n\n\n\n操作符\n描述\n\n\n\nx and y\n逻辑与\n\n\nx or y\n逻辑或\n\n\nnot x\n逻辑非\n\n\n单分支结构\n单分支结构的定义想必大家也比较清楚了。条件语句中单分支结构写法如下：if 判断条件:    执行语句\n当条件符合时，执行相应的语句；不符合时则跳过。*\n\n二分支结构\n二分支增添了else这个保留字，和if一起使用，及满足判断条件执行if中的内容，不满足就执行else中内容：\nif 判断条件:    执行语句else：    执行语句\n多分支结构\n多分支结构在二分支的结构上引入了elif这个保留字，实际上等价于C语言中的else if：\nif 判断条件:    执行语句elif 判断条件:    执行语句......else:    执行语句\n\n循环语句for循环\npython中的for循环需要和保留字in进行搭配使用，即：for 元素 in 迭代对象:    执行语句\n这里我们要注意的是for语句是从可迭代的对象中依次取出每一个元素，然后再进行操作。\n\n\n和range()函数一起使用：\nrange()用于生成一个可迭代的对象\nrange(start, stop[, step])for i in range(3):    print(i)012----------------------------for i in range(1,3):    print(i)12----------------------------for i in range(1,5,2):    print(i)13\n\n\n列表，元组，集合，字符串#遍历列表a = [1,2,3]for i in a:    print(i)123----------------------------#遍历元组b = (&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;)for i in b:    print(i)helloworld!----------------------------#遍历集合c = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;&#125;for i in c:    print(i)helloworld!----------------------------#遍历字符串d = &quot;python&quot;for i in d:    print(i)python\n字典e = &#123;&#x27;name&#x27;:&#x27;sun&#x27;,&#x27;habit&#x27;:&#x27;sunshine&#x27;&#125;#遍历键值对for i,j in e.items():    print(i,j)name sunhabit sunshine----------------------------#遍历键for i in e.keys():    print(i)namehabit----------------------------#遍历值for i in e.values():    print(i)sunsunshine\n文件\n\n\nfi是一个文件标识符，遍历其每行，产生循环\nfor line in fi:    &lt;语句块&gt;\nwhile循环\n使用方法：\n\n当条件判断为True时，执行语句块；\n当条件判断为False时，循环终止。while &lt;条件&gt;：    &lt;语句块&gt;\n\n\n与else同用：\n\n当while语句条件为true时，执行语句块内容，为false时执行else语句中的内容。while &lt;条件&gt;:    &lt;语句块&gt;else:    &lt;语句块&gt;\n\n\n\n循环保留字：continue和breakcontinue\n被用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环\n\nbreak\n可以跳出 for 和 while 的循环体\nbreak仅跳出当前最内层循环\n示例：for i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        continue    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)PYTHON正常退出\nfor i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        break    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python学习笔记（四）","url":"/2021/03/27/python-study-notes-4/","content":"函数的使用函数定义在Python中我们时常会使用函数来提高代码的效率和复用性，函数的定义如下：\ndef &lt;函数名&gt;(&lt;参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n\n这里def保留字用于声明函数，必须填写。\n\n参数设置\n参数设置主要有四类：必选参数、默认参数、可选参数、关键字参数\n\ndef &lt;函数名&gt;(&lt;必选参数&gt;,&lt;默认参数&gt;&lt;可选参数&gt;&lt;关键字参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n下面以计算n!这个函数为例子来介绍这些参数：\n必选参数传递\n当函数只有一个参数时默认该参数为必选参数\n\n默认参数传递\n优势：减低函数的难度\ntips：默认参数必须指向不变对象\n下面例子当中的参数m就是可选参数，def fact(n,m=1):    s = 1    for i in range(1,n+1):        s *= i    return s//m\n\n可变参数传递\n传入参数的个数是可变的。\n在参数前面加上*就是可变参数。\n在函数内部，参数numbers接收得到的是一个tuple，调用该函数时，可以传入任意个参数，包括0个参数def num(*fail):    total = 0    for i in fail:        total += i    return total\n这里fail可以接受多个参数的传递，如下所示：print(num(1,2))3print(num(4,5,6))15\n\n关键字参数传递\n使用**表示关键字参数def action(time,person,**job):    print(&quot;At&quot;,time,person,&quot;wants to&quot;,job)action(&#x27;7:00&#x27;,&#x27;Mom&#x27;,job = &#x27;clean house&#x27;)At 7:00 Mom wants to &#123;&#x27;job&#x27;: &#x27;clean house&#x27;&#125;\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"大数据分析实验（一）","url":"/2021/04/01/Big-data-analysis-experiment-1/","content":"Python 快速开发实验目的和要求\n熟悉 Python 开发环境；\n掌握项目和文件的建立；\n掌握 Python 的基本语法；\n\n实验内容和分析题目一：自定义函数，设置固定次数的登陆题目内容\n由键盘输入密码；\n若密码正确则屏幕显示：“Login success!”\n若密码错误则显示：“Wrong password or invalid input”，并显示剩余输入机会次数；\n共 3 次机会，用完则屏幕显示：“Your account has been suspended”，并退出程序。\n\n解题思路① 首先创建一个文件模拟数据库用于存储用户的账户和密码② 通过读取用户的输入来和文件中的账户密码进行比较③ 如果存在则显示登陆成功，否则显示登陆失败④ 定义一个变量用于存储用户失败次数，当失败次数大于3后，显示账户已被锁定然后结束程序。\n实验设计① 定义一个函数其参数为用户输入的用户名和密码，该函数将数据库文件打开然后按照存储形式进行比较，如果存在就返回True否则返回False② 主函数定义变量frequency用于标记用户登陆失败次数③ 利用while语句实现失败重新登陆这一过程；当匹配成功跳出循环，当超过三次也跳出循环结束程序。\n考察知识\n函数定义\n文件操作\nwhile语句\n\n实验代码#定义账号密码文件#读取文件，验证用户输入的账号密码是否在文件内#存在返回true，不存在返回falsedef Login_authentication(user, pwd):    f = open(&quot;information.txt&quot;, mode=&quot;r&quot;, encoding=&quot;UTF-8&quot;)    for line in f:        #按照你在文件中对字符串的存储方式来进行字符串比较        if line.strip() == user + &quot;-&quot; + pwd:            f.close()            return True    else:        f.close()        return False#存储错误次数frequency = 0while frequency &lt; 3:    #读取用户输入调用验证函数    user_name = input(&quot;Please enter user name：&quot;)    user_password = input(&quot;Please enter user password:&quot;)    ret = Login_authentication(user_name,user_password)    if ret:        print(&quot;Login success!&quot;)        break    else:        frequency += 1        if frequency == 3:            print(&quot;Your account has been suspended&quot;)        else:            print(&quot;Wrong password or invalid input,remaining times:&#123;&#125;&quot;.format(3-frequency))            print(end=&quot;\\n&quot;)\n\n实验结果\n运行结果：\n数据库文件：\n\n题目二：自定义函数, 将敏感词过滤后的文本写入指定位置的 txt题目内容\n自定义函数 texcreat(name,text),将 text 写入“name.txt”文件中\n自定义函数 Repalce,将某些敏感词(比如“暴力”)替换成“**”\n自定义函数将敏感词过滤后的文本写入指定 txt 文档中。\n\n解题思路① 创建一个文件用于存储定义敏感词；② 将用户输入的一句话作为参数传到敏感词过滤函数当中；③ 遍历该函数通过敏感词读取函数返回的由敏感词组成的列表比较该句话中是否存在敏感词，如果存在则将对应敏感词的字符长度存储下来然后用*来替代；④ 最后再将过滤完成的句子存放到以用户输入的文件名而创建的文件当中。\n实验设计① 创建一个存放敏感词的文件sensitive_word，输入一些敏感词存入到里面；② 定义一个函数read_sensitive_word函数用于读取文件中的敏感词然后将其存放在列表中，将存储敏感词的列表当作值进行返回；③ 创建一个函数texcreat用于接收用户输入的文件名然后创建这个文件，并将过滤敏感词后的句子存到该文件中；④ 定义一个函数Replace用于过滤敏感词；⑤ 主函数通过接受用户输入，先后调用过滤函数、读取敏感词函数、创建文件函数，然后结束程序。\n考察知识\n函数\n文件操作\n字符串操作\n\n实验代码#读取敏感词语文件def read_sensitive_word():    with open(&#x27;sensitive_word.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file_to_read:        lines = list()        for line in file_to_read.readlines():            if line is not None:                #去除字符串前后的空格，然后将字符串写入列表中                lines.append(line.strip(&#x27;\\n&#x27;))    return lines#创建文件，将过滤后的内容写入def texcreat(name,text):    file = open(name+&#x27;.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)    file.write(text)    file.close()#过滤敏感词def Replace(word):    sensitive_word = read_sensitive_word()    for line in sensitive_word:        if line in word:            #获取对应敏感词长度            word_length = len(line)            #将敏感词进行替换            word = word.replace(line, &#x27;*&#x27; * word_length)    return wordname = input(&quot;请输入文件名：&quot;)sentence = input(&quot;请输入你想说的话：&quot;)texcreat(name,Replace(sentence))\n\n实验结果\n运行结果：\n敏感词文件：\n\n题目三：电子抽奖器模拟题目内容&emsp;&emsp;商店街上新开了一家超市，经营各种生活用品、食品、电器等。经营者是一对年轻夫妇， 为了纪念开业，他们举行了为期一个周的抽奖活动，并到处广告宣传，说这次抽奖平均 100 人就能有 1 人获得一等奖。首次宣传，促销期间门庭若市。 但最近商业街一些老店主跑来告状，说那家店在抽奖促销期间每天客流明显超过 100 人，然而一周过去了，抽中开业纪念大奖的只有 5 个人。请你模拟一下电子抽奖器，分析一下一周 5 个人中奖是否正常？\n解题思路① 利用random函数来随机生成数用于模拟中奖情况；② 循环多次来代替随机抽样，最后以数值型呈现出最终概率。\n实验设计① 定义一个“抽奖函数”利用random库中的randint方法在0-9之间随机生成一个数，当数小于1时为真，大于1时为假，用于实现中奖概率为1%的条件；② 在主函数中利用for循环循环多次实现模拟情况然后每次循环都调用“抽奖函数”，以其返回值作为判断依据然后统计最终的中奖次数。\n考察知识\n函数\nrandom库\n\n实验代码import random# 判断中奖函数def lottery():    flag = random.randint(0, 9)    if flag &lt; 1:        return True    else:        return Falseif __name__ == &#x27;__main__&#x27;:    # 中奖次数    a = 0    # 没有中奖次数    b = 0    for i in range(1000000):        if (lottery()):            a += 1        else:            b += 1print(&#x27;共计中奖：&#x27;, a, &#x27;，未中奖：&#x27;, b)\n\n实验结果\n运行结果：\n\n题目四：小说《Walden》单词词频统计题目内容&emsp;&emsp;Walden 中文译名《瓦尔登湖》，是美国作家梭罗独居瓦尔登湖畔的记录，描绘了他两年多时间里的所见、所闻和所思。该书崇尚简朴生活，热爱大自然的风光，内容丰厚，意义深远，语言生动。请用 Python 统计小说 Walden 中各单词出现的频次，并按频次由高到低排序。\n解题思路① 读取文件；② 为了避免因为大小写情况导致统计出错，先将所有大写字母转为小写字母；③ 截取字符串，然后将单词和出现次数以键值对的形式存储在字典中然后输出。\n考察知识\n字符串\n文件操作\n字典\n\n实验代码import re#读取文件file = open(&#x27;Walden.txt&#x27;,&#x27;r&#x27;)text = file.read()file.close()#将所有英文字母变成小写text = text.lower()#使用正则表达式用空格替换标点符号text = re.sub(&#x27;[,.?:;&quot;\\&#x27;]&#x27;,&#x27;&#x27;,text)#以空格为分隔符截取字符串words = text.split(&quot; &quot;)#创建统计单词的字典word_sq = &#123;&#125;#统计单词出现个数存入字典中for i in words:    if i not in word_sq.keys():        word_sq[i] = 1    else:        word_sq[i] += 1#按照字典的值进行排序res = sorted(word_sq.items(),key=lambda x:x[1], reverse=True)print(&quot;单词 出现次数&quot;)for i in res:    print(i[0],i[1])\n\n实验结果\n运行结果：\n\n","categories":["experiment"],"tags":["big data analysis experiment","experiment"]},{"title":"Python学习笔记（五）","url":"/2021/04/03/python-study-notes-5/","content":"组合数据类型集合基本内容\n定义：包含0个或多个数据项的无序组合\n特点：\n元素之间无序，每个元素唯一，不存在相同元素\n元素不可更改，不能是可变数据类型\n用大括号 {} 表示，元素间用逗号分隔\n\n\n创建方式：建立集合类型用 {} 或 set()\ntips：空集合必须用set()创建&gt;&gt;&gt; A = &#123;&quot;python&quot;, 123, (&quot;python&quot;,123)&#125;&#123;123, &#x27;python&#x27;, (&#x27;python&#x27;, 123)&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; C = &#123;&quot;python&quot;, 123, &quot;python&quot;,123&#125;&#123;&#x27;python&#x27;, 123&#125;\n\n集合间操作\n\n\n操作符\n描述\n\n\n\nS\nT\n\n\nS - T\n返回一个新集合，包括在集合S但不在T中的元素\n\n\nS &amp; T\n返回一个新集合，包括同时在集合S和T中的元素\n\n\nS ^ T\n返回一个新集合，包括集合S和T中的非相同元素\n\n\nS &lt;= T 或 S &lt; T\n返回True/False，判断S和T的子集关系\n\n\ns &gt;= T 或 S &gt; T\n返回True/False，判断S和T的包含关系\n\n\nS -= T\n更新集合S，包括在集合S但不在T中的元素\n\n\nS &amp;= T\n更新集合S，包括同时在集合S和T中的元素\n\n\nS ^= T\n更新集合S，包括集合S和T中的非相同元素\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)#并运算&gt;&gt;&gt; A|B&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;y&#x27;, &#x27;3&#x27;, 123&#125;#交运算&gt;&gt;&gt; A&amp;B&#123;&#x27;p&#x27;, &#x27;y&#x27;&#125;#非相同元素&gt;&gt;&gt; A^B&#123;&#x27;2&#x27;, 123, &#x27;3&#x27;, &#x27;1&#x27;&#125;#差运算&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;&#x27;3&#x27;, &#x27;1&#x27;, &#x27;2&#x27;&#125;\n\n集合处理方法\n\n\n操作函数\n描述\n\n\n\nS.add(x)\n如果x不在集合S中，将x增加到S\n\n\nS.discard(x)\n移除S中元素x，如果x不在集合S中，不报错\n\n\nS.remove(x)\n移除S中元素x，如果x不在集合S中，产生KeyError异常\n\n\nS.clear()\n移除S中所有元素\n\n\nS.pop()\n随机返回S的一个元素，更新S，若S为空产生KeyError异常\n\n\nS.copy()\n返回集合S的一个副本\n\n\nlen(S)\n返回集合S的元素个数\n\n\nx in S\n判断S中元素x，x在集合S中，返回True，否则返回False\n\n\nx not in S\n判断S中元素x，x不在集合S中，返回False，否则返回True\n\n\nset(x)\n将其他类型变量x转变为集合类型\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; for item in A:        print(item, end=&quot;&quot;)p123y&gt;&gt;&gt; A&#123;&#x27;p&#x27;, 123, &#x27;y&#x27;&#125;&gt;&gt;&gt; try:        while True:            print(A.pop(), end=&quot;&quot;))    except:        passp123y&gt;&gt;&gt; Aset()\n\n应用场景\n包含关系比较：&gt;&gt;&gt; &quot;p&quot; in &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;True&gt;&gt;&gt; &#123;&quot;p&quot;, &quot;y&quot;&#125; &gt;= &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;False\n数据去重：&gt;&gt;&gt; ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, 123]&gt;&gt;&gt; s = set(ls)&#123;&#x27;p&#x27;, &#x27;y&#x27;, 123&#125;&gt;&gt;&gt; lt = list(s) [&#x27;p&#x27;, &#x27;y&#x27;, 123]\n\n总结\n集合使用{}和set()函数创建\n集合间操作：交(&amp;)、并(|)、差(-)、补(^)、比较(&gt;=&lt;)\n集合类型方法：.add()、.discard()、.pop()等\n集合类型主要应用于：包含关系比较、数据去重\n\n序列类型序列类型及操作序列类型定义\n序列是具有先后关系的一组元素。\ntips：\n序列是一维元素向量，元素类型可以不同\n类似数学元素序列： s0, s1,    … ,    sn-1\n元素间由序号引导，通过下标访问序列的特定元素\n\n\n序列是一个基类类型包括：\n字符串类型\n元组类型\n列表类型\n\n\n\n操作符\n\n\n操作符及应用\n描述\n\n\n\nx in s\n如果x是序列s的元素，返回True，否则返回False\n\n\nx not in s\n如果x是序列s的元素，返回False，否则返回True\n\n\ns + t\n连接两个序列s和t\n\n\ns * n 或 n * s\n将序列s复制n次\n\n\ns[i]\n索引，返回s中的第i个元素，i是序列的序号\n\n\ns[i: j] 或 s[i: j: k]\n切片，返回序列s中第i到j以k为步长的元素子序列\n\n\n函数和方法\n\n\n函数和方法\n描述\n\n\n\nlen(s)\n返回序列s的长度\n\n\nmin(s)\n返回序列s的最小元素，s中元素需要可比较\n\n\nmax(s)\n返回序列s的最大元素，s中元素需要可比较\n\n\ns.index(x) 或 s.index(x, i, j)\n返回序列s从i开始到j位置中第一次出现元素x的位置\n\n\ns.count(x)\n返回序列s中出现x的总次数\n\n\n元组类型定义\n元组是序列类型的一种扩展\n元组是一种序列类型，一旦创建就不能被修改\n使用小括号 () 或 tuple() 创建，元素间用逗号 , 分隔\n可以使用或不使用小括号\n\n&gt;&gt;&gt; creature = &quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, &quot;human&quot;&gt;&gt;&gt; creature(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;)&gt;&gt;&gt; color = (0x001100,\t&quot;blue&quot;, creature)&gt;&gt;&gt; color(4352, &#x27;blue&#x27;, (&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;))\n\n操作\n元组继承了序列类型的全部通用操作\n元组因为创建后不能修改，因此没有特殊操作\n使用或不使用小括号\n\n列表类型定义\n列表是一种序列类型，创建后可以随意被修改\n使用方括号 [] 或list() 创建，元素间用逗号 , 分隔\n列表中各元素类型可以不同，无长度限制\n\n操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nls[i] = x\n替换列表ls第i元素为x\n\n\nls[i: j: k] = lt\n用列表lt替换ls切片后所对应元素子列表\n\n\ndel ls[i]\n删除列表ls中第i元素\n\n\ndel ls[i: j: k]\n删除列表ls中第i到第j以k为步长的元素\n\n\nls += lt\n更新列表ls，将列表lt元素增加到列表ls中\n\n\nls *= n\n更新列表ls，其元素重复n次\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls[1:2] = [1, 2, 3, 4][&#x27;cat&#x27;, 1, 2, 3, 4, &#x27;tiger&#x27;, 1024]&gt;&gt;&gt; del ls[::3] [1, 2, 4, &#x27;tiger&#x27;]&gt;&gt;&gt; ls*2[1, 2, 4, &#x27;tiger&#x27;, 1, 2, 4, &#x27;tiger&#x27;]\n\n\n\n\n函数或方法\n描述\n\n\n\nls.append(x)\n在列表ls最后增加一个元素x\n\n\nls.clear()\n删除列表ls中所有元素\n\n\nls.copy()\n生成一个新列表，赋值ls中所有元素\n\n\nls.insert(i,x)\n在列表ls的第i位置增加元素x\n\n\nls.pop(i)\n将列表ls中第i位置元素取出并删除该元素\n\n\nls.remove(x)\n将列表ls中出现的第一个元素x删除\n\n\nls.reverse()\n将列表ls中的元素反转\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls.append(1234)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024, 1234]&gt;&gt;&gt; ls.insert(3, &quot;human&quot;)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;, 1024, 1234]&gt;&gt;&gt; ls.reverse()[1234, 1024, &#x27;human&#x27;, &#x27;tiger&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;]\n\n应用场景\n元组用于元素不改变的应用场景，更多用于固定搭配场景\n列表更加灵活，它是最常用的序列类型\n最主要作用：表示一组有序数据，进而操作它们\n元素遍历:for item in ls :    &lt;语句块&gt;\n数据保护：如果不希望数据被程序所改变，转换成元组类型&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; lt = tuple(ls)&gt;&gt;&gt; lt(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024)\n\n小结\n序列是基类类型，扩展类型包括：字符串、元组和列表\n元组用()和tuple()创建，列表用[]创建\n元组操作与序列操作基本相同\n列表操作在序列操作基础上，增加了更多的灵活性\n\n字典类型字典类型定义\n字典类型是“映射的体现”\n键值对：键是数据索引的扩展\n字典是键值对的集合，键值对之间无序\n采用大括号{}和dict()创建，键值对用冒号表示\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d&#123;&#x27;中国&#x27;: &#x27;北京&#x27;, &#x27;美国&#x27;: &#x27;华盛顿&#x27;, &#x27;法国&#x27;: &#x27;巴黎&#x27;&#125;&gt;&gt;&gt; d[&quot;中国&quot;]&#x27;北京&#x27;&gt;&gt;&gt; de = &#123;&#125; &gt;&gt;&gt; type(de)&lt;class &#x27;dict&#x27;&gt;\n\n字典类型操作方法\n\n\n函数或方法\n描述\n\n\n\ndel d[k]\n删除字典d中键k对应的数据值\n\n\nk in d\n判断键k是否在字典d中，如果在返回True，否则False\n\n\nd.keys()\n返回字典d中所有的键信息\n\n\nd.values()\n返回字典d中所有的值信息\n\n\nd.items()\n返回字典d中所有的键值对信息，以元组形式返回\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; &quot;中国&quot; in dTrue&gt;&gt;&gt; d.keys()dict_keys([&#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;法国&#x27;])&gt;&gt;&gt; d.values()dict_values([&#x27;北京&#x27;, &#x27;华盛顿&#x27;, &#x27;巴黎&#x27;])\n\n字典类型操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nd.get(k, )\n键k存在，则返回相应值，不在则返回值\n\n\nd.pop(k, )\n键k存在，则取出相应值，不在则返回值\n\n\nd.popitem()\n随机从字典d中取出一个键值对，以元组形式返回\n\n\nd.clear()\n删除所有的键值对\n\n\nlen(d)\n返回字典d中元素的个数\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d.get(&quot;中国&quot;,&quot;伊斯兰堡&quot;)&#x27;北京&#x27;&gt;&gt;&gt; d.get(&quot;巴基斯坦&quot;,&quot;伊斯兰堡&quot;)&#x27;伊斯兰堡&#x27;&gt;&gt;&gt; d.popitem()(&#x27;美国&#x27;, &#x27;华盛顿&#x27;)\n\n小结\n映射关系采用键值对表达\n字典类型使用{}和dict()创建，键值对之间用 : 分隔\nd[key] 方式既可以索引，也可以赋值\n字典类型有一批操作方法和函数，例如.get()\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 学习笔记（六）","url":"/2021/04/05/python-study-notes-6/","content":"文件操作文件概述定义和分类\n定义：文件是一个存储在辅助存储器上的数据序列，可以包含任何数据内容。\n概念上:文件是数据的集合和抽象。\n优点：组织和表达数据更有效、更灵活。\n分类：文本文件和二进制文件。\n\n文本文件和二进制文件\n\n\n比较项\n文本文件\n二进制文件\n\n\n\n定义\n由文本字符为内容的文件\n直接由比特0和1组成\n\n\n字符编码\n是\n否\n\n\n读取方式\n文件经编码形成字符串，打印出含有意义的字符\n文件被解析为字节（比特）流\n\n\n表示形式\n一个字符由2个字节表示\n单一字节表示\n\n\ntextFile = open(&quot;7.1.txt&quot;,&quot;rt&quot;) #t表示文本文件方式print(textFile.readline())textFile.close()binFile = open(&quot;7-1.txt&quot;,&quot;rb&quot;)\t#r表示二进制文件方式print(binFile.readline())binFile.close()\n&gt;&gt;&gt;中国是个伟大的国家！ b&#x27;\\xd6\\xd0\\xb9\\xfa\\xca\\xc7\\xb8\\xf6\\xce\\xb0\\xb4\\xf3\\xb5\\xc4\\xb9\\xfa\\xbc\\xd2\\xa3\\xa1&#x27;\n\n文件操作文件打开和关闭\n文件打开函数: open()\n表示方法：\n&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)\n文件名可以是文件的实际名字，也可以是包含完整路径的名字。\n\n\n打开模式举例：\n\n\n\n\n打开模式\n含义\n\n\n\n‘r’\n只读模式，如果文件不存在，返回异常FileNotFoundError，默认值\n\n\n‘w’\n覆盖写模式，文件不存在则创建，存在则完全覆盖源文件\n\n\n‘x’\n创建写模式，文件不存在则创建，存在则返回异常FileExistsError\n\n\n‘a’\n追加写模式，文件不存在则创建，存在则在原文件最后追加内容\n\n\n‘b’\n二进制文件模式\n\n\n‘t’\n文本文件模式，默认值\n\n\n‘+’\n与r/w/x/a一同使用，在原功能基础上增加同时读写功能\n\n\n文件读写定义a为一文件：\n\n文件读取：\n\n\n\n\n方法\n含义\n\n\n\na.readall()\n读入整个文件内容，返回一个字符串或字节流*\n\n\na.read(size=-1)\n从文件中读入整个文件内容，如果给出参数，读入前size长度的字符串或字节流\n\n\na.readline(size = -1)\n从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流\n\n\na.readlines(hint=-1)\n从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行\n\n\n\n文件写入：\n\n\n\n\n方法\n含义\n\n\n\na.write(s)\n向文件写入一个字符串或字节流\n\n\na.writelines(lines)\n将一个元素为字符串的列表写入文件\n\n\na.seek(offset)\n改变当前文件操作指针的位置，offset的值： 0：文件开头； 1: 当前位置； 2: 文件结尾\n\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 实验一 Python运行环境搭建及使用","url":"/2021/04/05/python-experiment-1/","content":"实验目的\n熟悉 Python 开发环境的使用\n熟悉 Python 应用程序的创建与运行\n掌握 Python 输入与输出实验内容练习一题目分别用交互模式和批量模式完成以下代码的练习。str1=input(&quot;请输入一个人的名字：&quot;)str2=input(&quot;请输入一个国家的名字：&quot;)print(&quot;世界这么大，&#123;&#125;想去&#123;&#125;看看&quot;.format(str1,str2))\n练习二题目整数序列求和：用户输入一个正整数 N,计算从 1 到 N(包含 1 和 N)相加之后的结果。代码N = input(&quot;请输入一个正整数N：&quot;)sum = 0for i in range (int(N)):    sum += i + 1print(&quot;1到N相加后的结果为：&quot;,sum)\n练习三题目健康食谱输出：列出 5 种不同的食材，输出它们可能组成的所有菜式名称。代码array = [&#x27;土豆&#x27;,&#x27;豇豆&#x27;,&#x27;辣椒&#x27;,&#x27;五花肉&#x27;,&#x27;豆腐&#x27;]for i in range(0,5):    for j in range(0,5):        if not(i==j):            print(&quot;&#123;&#125;&#123;&#125;&quot;.format(array[i],array[j]))\n练习四题目太阳花的绘制：使用 turtle 库绘制一个太阳花的图形，如下图所示。￼代码from turtle import *color(&#x27;red&#x27;,&#x27;yellow&#x27;)begin_fill()while True:    forward(200)    left(170)    if abs(pos())&lt;1:        breakend_fill()done()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十 Tkinter的使用（1）","url":"/2021/04/05/python-experiment-10/","content":"实验目的\n掌握 tkinter 的使用\n熟悉可视化界面的设计方法实验内容题目完成以下代码，熟悉 tkinter 各个部件的使用代码#(1) 创建主窗口及 Label 部件（标签）创建使用import tkinter as tk# SY11-1window = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)l = tk.Label(window,text =&#x27;你好！欢迎使用Python tkinter!&#x27;,bg = &#x27;AliceBlue&#x27;,font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()window.mainloop()#（2）Button 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)var = tk.StringVar()l = tk.Label(window,textvariable = var,bg = &#x27;AliceBlue&#x27;,    font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()on_hit = Falsedef touch():    global on_hit    if on_hit == False:        on_hit = True        var.set(&#x27;你点击了确认按钮&#x27;)    else:        on_hit = False        var.set(&#x27;&#x27;)b = tk.Button(window,text=&#x27;确认&#x27;,font=(&#x27;Arial&#x27;,12),width = 10,              height=1,command = touch)b.pack()window.mainloop()#（3）Entry 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-3&#x27;)window.geometry(&#x27;500x300&#x27;)e1 = tk.Entry(window,show=&#x27;*&#x27;,font=(&#x27;Arial&#x27;,14))e2 = tk.Entry(window,show=None,font=(&#x27;Arial&#x27;,14))e1.pack()e2.pack()window.mainloop()#（4）Text 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-4&#x27;)window.geometry(&#x27;500x300&#x27;)e = tk.Entry(window,show = None)e.pack()def insert_point():    var = e.get()    t.insert(&#x27;insert&#x27;,var)def insert_end():    var = e.get()    t.insert(&#x27;end&#x27;,var)b1 = tk.Button(window,text=&#x27;insert point&#x27;,width = 10,               height = 2,command = insert_point)b1.pack()b2 = tk.Button(window,text=&#x27;insert end&#x27;,width = 10,               height = 2,command = insert_end)b2.pack()t = tk.Text(window,height = 3)t.pack()window.mainloop()#（5）Canvas 窗口部件import tkinter as tk # 使用 Tkinter 前需要先导入window = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)canvas = tk.Canvas(window, bg=&#x27;AliceBlue&#x27;, height=200, width=500)image_file = tk.PhotoImage(file=&#x27;123.gif&#x27;)image = canvas.create_image(250, 0, anchor=&#x27;n&#x27;,image=image_file)x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0-50, y0-50, x1-50, y1-50)oval = canvas.create_oval(x0+120, y0+50, x1+120, y1+50, fill=&#x27;yellow&#x27;)arc = canvas.create_arc(x0, y0+50, x1, y1+50, start=0, extent=180)rect = canvas.create_rectangle(330, 30, 330+20, 30+20)canvas.pack()def moveit():    canvas.move(rect, 2, 2)b = tk.Button(window, text=&#x27;move item&#x27;,command=moveit).pack()window.mainloop()#（6）messageBox 窗口部件import tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)def hit_me(): tkinter.messagebox.showinfo(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;) # tkinter.messagebox.showwarning(title=&#x27;Hi&#x27;, message=&#x27;有警告！&#x27;) # 提出 # tkinter.messagebox.showerror(title=&#x27;Hi&#x27;, message=&#x27;出错了！&#x27;) # 提出错 # print(tkinter.messagebox.askquestion(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # 询问选择对话窗 return &#x27;yes&#x27;, &#x27;no&#x27; # print(tkinter.messagebox.askyesno(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27; # print(tkinter.messagebox.askokcancel(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27;tk.Button(window, text=&#x27;hit me&#x27;, bg=&#x27;green&#x27;, font=(&#x27;Arial&#x27;, 14), command=hit_me).pack()window.mainloop()#（7）窗口部件三种放置方式 pack/grid/place#7-1import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)for i in range(3):    for j in range(3):        tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10,ipadx=10, ipady=10)window.mainloop()#7-2import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;top&#x27;) # 上tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;bottom&#x27;) # 下tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;left&#x27;) # 左tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;right&#x27;) # 右window.mainloop()#7-3import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;Pl&#x27;, font=(&#x27;Arial&#x27;, 20), ).place(x=50, y=100, anchor=&#x27;nw&#x27;)window.mainloop()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十二 数据分析与可视化（1）","url":"/2021/04/05/python-experiment-12/","content":"实验目的1、 熟悉 numpy 库常用方法的使用2、 熟悉 pandas 库的基本使用3、 能够利用 matplotlib 库进行简单的图形绘制\n实验内容题目根据某商品近 5 年的销售流水，做数据分析和可视化。模拟产生数据代码如下：￼\n（1）编写程序生成某商品(2014-01-01 到 2018-12-31)的销售流水，模拟数据文件名为 data.csv，数据格式如下：（说明：日期是连续的，销量是随机数，单价范围为[101，105]的随机值）￼\n代码import randomimport datetimeimport csvfn = &#x27;data.csv&#x27;with open(fn,&#x27;w&#x27;) as fp:    wr = csv.writer(fp)    wr.writerow([&#x27;日期&#x27;,&#x27;销量&#x27;,&#x27;单价&#x27;])    startDate = datetime.date(2014,1,1)    for i in range(1825):        amount = 300+i*5+random.randrange(100)        price = 100+random.randint(1,5)        wr.writerow([str(startDate),amount,price])        startDate = startDate+datetime.timedelta(days=1)\n（2）使用 pandas 读取文件 data.csv 中的数据，创建 DataFrame 对象，并删除其中所有缺失值；代码import pandas as pddf = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()\n（3）使用 matplotlib 生成折线图，反映每月的销量情况，并把图形保存为本地文件 one.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:7])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot()plt.savefig(&#x27;one.jpg&#x27;)plt.show()\n结果￼\n（4）按年进行统计，使用 matplotlib 绘制柱状图显示每年的营业额，并把图形保存为本地文件 two.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;two.jpg&#x27;)plt.show()\n结果￼\n（5）按年进行统计，使用 matplotlib 绘制柱状图显示每年销售量最大的月份及销售额，并把图形保存为本地文件 three.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).max()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;three.jpg&#x27;)plt.show()\n结果￼\n（6）按年度统计该商品的营业额数据，使用 matplotlib 生成饼状图显示每年都的营业额分布情况，并把图形保存为本地文件 four.jpg。代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.pie(subplots=True)plt.savefig(&#x27;four.jpg&#x27;)plt.show()\n结果￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十一 Tkinter的使用（2）","url":"/2021/04/05/python-experiment-11/","content":"实验目的掌握界面程序的设计\n实验内容练习一题目：用户登陆界面程序编写一个用户登录界面，用户可以登录账户信息，如果账户已经存在，可以直接登录，登录名或者登录密码输入错误会提示，如果账户不存在，提示用户注册，点击注册进去注册页面，输入注册信息，确定后便可以返回登录界面进行登录。\n代码import pickleimport tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;登 录&#x27;)window.geometry(&#x27;500x400&#x27;)l1 = tk.Label(window,text=&#x27;用户名：&#x27;,font= 12).place(x=100,y=82)l2 = tk.Label(window,text=&#x27;密  码：&#x27;,font= 12).place(x=100,y=152)var_user_name = tk.StringVar()entry_user_name = tk.Entry(window,textvariable=var_user_name,font= 18,width=30,bd =5)entry_user_name.place(x=180,y=80)var_user_password = tk.StringVar()entry_user_password = tk.Entry(window,textvariable=var_user_password,show=&#x27;*&#x27;,font= 18,width=30,bd =5)entry_user_password.place(x=180,y=150)def user_login_in():    user_name = var_user_name.get()    user_password = var_user_password.get()    try:        with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:            user_info = pickle.load(user_file)    except FileNotFoundError:        with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:            user_info = &#123;&#x27;admin&#x27;:&#x27;admin&#x27;&#125;            pickle.dump(user_info,user_file)    if user_name ==&#x27; &#x27; or user_password == &#x27; &#x27;:        tk.messagebox.showerror(message=&#x27;用户名或密码不能为空！&#x27;)    elif user_name in user_info:        if user_password == user_info[user_name]:            tk.messagebox.showinfo(title=&#x27;welcome&#x27;,message=&#x27;欢迎您：&#x27;+user_name)        else:            tk.messagebox.showerror(message=&#x27;密码错误！&#x27;)    else:        is_signup = tk.messagebox.askyesno(&#x27;欢迎&#x27;,&#x27;您还没有注册，是否现在注册&#x27;)        if is_signup:            user_sign_up()def user_sign_up():    def registration():        input_name = new_name.get()        input_password = new_password.get()        input_password_confirm =new_password_confirm.get()        try:            with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:                exist_user_info = pickle.load((user_file))        except FileNotFoundError:            exist_user_info = &#123;&#125;        if input_name in exist_user_info:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名已存在！&#x27;)        elif input_password ==&#x27;&#x27; or input_name ==&#x27;&#x27;:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名或密码不能为空！&#x27;)        elif input_password != input_password_confirm:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;密码前后不一致！&#x27;)        else:            exist_user_info[input_name] = input_password            with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:                pickle.dump(exist_user_info,user_file)            tk.messagebox.showinfo(&#x27;欢迎&#x27;,&#x27;注册成功！&#x27;)            window_sign_up.destroy()    window_sign_up = tk.Toplevel(window)    window_sign_up.geometry(&#x27;350x200&#x27;)    window_sign_up.title(&#x27;注册&#x27;)    new_name = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;用户名：&#x27;).place(x=10,y=10)    tk.Entry(window_sign_up,textvariable=new_name).place(x=150,y=10)    new_password = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请输入密码：&#x27;).place(x=10,y=50)    tk.Entry(window_sign_up,textvariable=new_password,show=&#x27;*&#x27;).place(x=150,y=50)    new_password_confirm = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请再次确认密码：&#x27;).place(x=10,y=90)    tk.Entry(window_sign_up,textvariable=new_password_confirm,show=&#x27;*&#x27;).place(x=150,y=90)    bt_confirm_sign_up = tk.Button(window_sign_up,text=&#x27;确认注册&#x27;,command=registration)    bt_confirm_sign_up.place(x=150,y=130)def user_sign_out():    window.destroy()bt_login = tk.Button(window,text=&#x27;登    录&#x27;,width=30,font= 18,bg=&#x27;DarkTurquoise&#x27;,activebackground=&#x27;Turquoise&#x27;,command=user_login_in)bt_login.place(x=150,y=210)bt_register = tk.Button(window,text=&#x27;注册&#x27;,width=25,command= user_sign_up)bt_register.place(x=150,y=270)bt_exit = tk.Button(window,text=&#x27;退出&#x27;,width=5,command = user_sign_out)bt_exit.place(x=350,y=270)window.mainloop()\n练习二题目：tkinter 版猜数游戏使用 Python 标准库 tkinter 编写 GUI 版本的猜数游戏。 每次猜数之前要启动游戏并设置猜数范围和最大猜测次数等参数， 退出游戏时显示战绩（共玩几次， 猜对几次） 信息。\n代码import tkinter as tkimport randomnumber = random.randint(0,1024)running = Truenum = 0num_max = 1024num_min = 0def eBtnClose(event):    root.destory()def eBtnGuess(evnet):    global num_max    global num_min    global num    global running    if running:        val_a = int(entry_a.get())        if val_a ==number:            labelqval(&quot;恭喜你答对啦！&quot;)            num +=1            running =False            numGuess()        elif val_a &lt;number:            if val_a &gt;num_min:                num_min = val_a                num +=1                label_tip_min.config(label_tip_min,text=num_min)            labelqval(&quot;小了哦&quot;)        else:            if val_a &lt; num_max:                num_max = val_a                num +=1                label_tip_max.config(label_tip_max,text=num_max)            labelqval(&quot;大了哦&quot;)    else:        labelqval(&#x27;你已经答对了&#x27;)def numGuess():    if num ==1:        labelqval(&#x27;居然一次就答对了&#x27;)    elif num&lt;10:        labelqval(&#x27;十次以内就答对了，继续加油！尝试次数为：&#x27;+str(num))    elif num&lt;50:        labelqval(&#x27;很不错！尝试次数为：&#x27;+str(num))def labelqval(vText):    label_val_q.config(label_val_q,text=vText)root = tk.Tk(className=&quot;猜数游戏&quot;)root.geometry(&quot;400x50&quot;)line_a_tip = tk.Frame(root)label_tip_max = tk.Label(line_a_tip,text=num_max)label_tip_min = tk.Label(line_a_tip,text=num_min)label_tip_max.pack(side=&quot;top&quot;,fill=&quot;x&quot;)label_tip_min.pack(side=&quot;bottom&quot;,fill=&quot;x&quot;)line_a_tip.pack(side=&quot;left&quot;,fill=&quot;y&quot;)line_question = tk.Frame(root)label_val_q = tk.Label(line_question,width=&quot;80&quot;)label_val_q.pack(side=&quot;left&quot;)line_question.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_input = tk.Frame(root)entry_a =tk.Entry(line_input,width=&quot;40&quot;)btnGuess = tk.Button(line_input,text = &quot;猜&quot;)entry_a.pack(side=&quot;left&quot;)entry_a.bind(&#x27;&lt;Return&gt;&#x27;,eBtnGuess)btnGuess.bind((&#x27;&lt;Button-1&gt;&#x27;),eBtnGuess)btnGuess.pack(side=&quot;left&quot;)line_input.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_btn = tk.Frame(root)btnClose = tk.Button(line_btn,text=&quot;关闭&quot;)btnClose.bind(&#x27;&lt;Button-1&gt;&#x27;,eBtnClose)btnClose.pack(side=&quot;left&quot;)line_btn.pack(side=&quot;top&quot;)labelqval(&quot;请输入0到1024之间任意整数：&quot;)entry_a.focus_set()root.mainloop()\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十三 数据分析与可视化（2）","url":"/2021/04/05/python-experiment-13/","content":"实验目的1、 掌握第三方库 TuShare 的数据获取方法2、 能够利用 pandas 库进行简单的数据分析3、 能够利用 matplotlib 库进行数据可视化4、 综合应用上述第三方库解决问题的能力\n实验内容一、读取 stock_hist_data.csv 中招商银行（股票代码 600036）2018 年下半年的股票数据并完成如下数据处理和分析任务：(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。(2) 输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；(3) 列出成交量（volume）在 1000000 以上的记录；(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。data_frame = pd.DataFrame(pd.read_csv(&#x27;stock_hist_data.csv&#x27;).iloc[:,:6])data_frame = data_frame.sort_values(&#x27;date&#x27;,ascending=True)data_frame.close.plot()plt.title(&quot;收盘价(close)的走势图&quot;)plt.savefig(&#x27;收盘价(close)的走势图.jpg&#x27;)plt.show()#（2）输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；data_volume_max_index = data_frame.volume.idxmax()data_volume_max = data_frame.loc[data_volume_max_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].values# print(data_volume_max_index)data_volume_min_index = data_frame.volume.idxmin()data_volume_min = data_frame.loc[data_volume_min_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].valuesprint(&quot;半年成交量中&#123;&#125;这一天最高，为&#123;&#125;。\\n&quot;.format(data_volume_max[0],data_volume_max[1]))print(&quot;半年成交量中&#123;&#125;这一天最低，为&#123;&#125;。\\n&quot;.format(data_volume_min[0],data_volume_min[1]))#(3) 列出成交量（volume）在 1000000 以上的记录；data_volume_more_than_1000000 = data_frame[data_frame.volume &gt; 1000000]print(&quot;成交量在1000000以上的记录为：\\n&quot;,data_volume_more_than_1000000)#(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；data_frame_count = data_frame[data_frame.close &gt; data_frame.open][&#x27;date&#x27;].count()print(&quot;收盘价高于开盘价的天数共有：&#123;&#125;天\\n&quot;.format(data_frame_count))#(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。data_frame_5 = data_frame.loc[:,[&#x27;date&#x27;,&#x27;close&#x27;]]data_frame_5[&#x27;date&#x27;] = data_frame_5[&#x27;date&#x27;].apply(lambda x:x[:7])data_frame_5_close_average = data_frame_5.groupby(&#x27;date&#x27;).mean()# print(data_frame_5_close_average)data_frame_5_close_average.plot.bar()plt.title(&quot;每月收盘价(close)的平均值&quot;)plt.savefig(&#x27;average.jpg&#x27;)plt.show()\n结果（1）（5）\n二、读取“2018 世界杯球队数据.csv”，实现如下功能：(1) 输出净胜球大于 0 的球队；(2) 输出被罚红牌的球队；(3) 输出进球成功率超过 10%的球队以及进球数和射门数；(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；(5) 按照进球数降序输出所有球队及进球信息；(6) 按照所属区进行分组，按升序统计输出每个区的进球数；(7) 按照所属区进行分组，绘制每个区进球数的条形图；(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 输出净胜球大于 0 的球队；data_frame = pd.DataFrame(pd.read_csv(&#x27;2018世界杯球队数据.csv&#x27;,encoding=&#x27;gbk&#x27;))data_frame_1 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;失球&#x27;]]data_frame_1_win_goal = data_frame_1[&#x27;进球&#x27;] - data_frame_1[&#x27;失球&#x27;]data_frame_1[&#x27;净胜球&#x27;] = data_frame_1_win_goaldata_frame_1 = data_frame_1[data_frame_1.净胜球 &gt;0]data_frame_1_final = data_frame_1.loc[:,[&#x27;球队&#x27;,&#x27;净胜球&#x27;]]data_frame_1_name = data_frame_1_final[&#x27;球队&#x27;].valuesprint(&#x27;净胜球大于0的球队有：&#x27;,end=&#x27;&#x27;)for i in data_frame_1_name:    print(i,end=&#x27; &#x27;)#(2) 输出被罚红牌的球队；data_frame_2 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;红牌&#x27;]]data_frame_2 = data_frame_2[data_frame_2.红牌 &gt; 0].valuesprint(&#x27;被罚红牌的队伍有:&#x27;)for i in data_frame_2:    print(i[0],end=&#x27; &#x27;)#（3）输出进球成功率超过 10%的球队以及进球数和射门数；data_frame_3 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;射门&#x27;]]data_frame_3_goalrate = data_frame_3[&#x27;进球&#x27;] / data_frame_3[&#x27;射门&#x27;]*100data_frame_3[&#x27;进球率&#x27;] = data_frame_3_goalratedata_frame_3 = data_frame_3[data_frame_3.进球率 &gt; 10]data_frame_3.drop(labels=&#x27;进球率&#x27;,axis=1,inplace=True)print(data_frame_3)#(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；data_frame_4 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;黄牌&#x27;]]data_frame_4_TotalGoalAverage = data_frame_4[&#x27;进球&#x27;].mean()# print(data_frame_4_TotalGoalAverage)data_frame_4 = data_frame_4[(data_frame_4.进球 &gt; data_frame_4_TotalGoalAverage) &amp; (data_frame_4.黄牌 &lt; 5)]print(data_frame_4)#(5) 按照进球数降序输出所有球队及进球信息；data_frame_5 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_5.sort_values(by=&#x27;进球&#x27;,ascending=False,inplace=True)print(data_frame_5)#(6) 按照所属区进行分组，按升序统计输出每个区的进球数；data_frame_6 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_6_final = data_frame_6.groupby(&#x27;所属洲&#x27;).sum()data_frame_6_final.sort_values(by=&#x27;进球&#x27;,inplace=True)print(data_frame_6_final)#(7) 按照所属区进行分组，绘制每个区进球数的条形图；data_frame_7 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_7_final = data_frame_7.groupby(&#x27;所属洲&#x27;).sum()data_frame_7_final.plot.bar()plt.title(&#x27;各大洲进球数&#x27;)plt.show()#(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。data_frame_8 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;抢断&#x27;,&#x27;射门&#x27;]]data_frame_8 = data_frame_8[data_frame_8.所属洲 == &#x27;欧洲&#x27;]data_frame_8_bar = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_8_pie = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;抢断&#x27;]]data_frame_8_plot = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;射门&#x27;]]# print(data_frame_8_bar)plt.subplot(221)plt.title(&#x27;欧洲球队抢断数&#x27;)plt.scatter(data_frame_8_pie[&#x27;抢断&#x27;],data_frame_8_pie[&#x27;球队&#x27;])plt.subplot(222)plt.title(&#x27;欧洲球队射门次数占比&#x27;)plt.pie(data_frame_8_plot[&#x27;射门&#x27;],labels=data_frame_8_plot[&#x27;球队&#x27;])plt.subplot(212)plt.title(&#x27;欧洲球队进球数&#x27;)plt.bar(data_frame_8_bar[&#x27;球队&#x27;],data_frame_8_bar[&#x27;进球&#x27;])plt.show()\n结果（6）（7）￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十四 网络爬虫基础（1）","url":"/2021/04/05/python-experiment-14/","content":"实验目的1、网络爬虫的基本原理与规范。2、掌握使用 Requests 库获取静态网页信息。3、掌握使用 BeautifulSoup4 库解析网页信息。4、掌握正则表达式的基本用法。\n实验内容题目 中国大学排名定向爬虫(1) 查看 https://www.shanghairanking.cn/rankings/bcur/2020 网页中关于各大学排名的信息组织(F12 快捷键查阅 html 代码)(2)使用 requests、beautifulsoup4 或 re 库抓取并解析排名，输出各大学的排名信息，如下图所示。￼\n代码import requestsfrom bs4 import BeautifulSoupimport  bs4def getHTMLText(url):    try:        r = requests.get(url,timeout=30)        r.raise_for_status()        r.encoding = &#x27;utf-8&#x27;        return r.text    except:        return &quot;&quot;def fillUniviList(ulist,html):    soup = BeautifulSoup(html,&quot;html.parser&quot;)    for tr in soup.find(&#x27;tbody&#x27;).children:        if isinstance(tr,bs4.element.Tag):            tds = tr(&#x27;td&#x27;)            ulist.append([tds[0].text,tds[1].text,tds[4].text])def printUnivList(ulist,num):    tplt = &quot;&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;&quot;    print(tplt.format(&quot;排名&quot;,&quot;学校排名&quot;,&quot;总分&quot;,chr(12288)))    for i in range(num):        u = ulist[i]        print(tplt.format(u[0].strip(),u[1].strip(),u[2].strip(),chr(12288)))def main():    uinfo = []    url = &#x27;https://www.shanghairanking.cn/rankings/bcur/2020&#x27;    html = getHTMLText(url)    fillUniviList(uinfo,html)    printUnivList(uinfo,20)main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验二 字符串及基本数据类型操作","url":"/2021/04/05/python-experiment-2/","content":"实验目的1．掌握字符串编码、索引方式2．掌握字符串的操作3．掌握字符串格式化4．掌握基本数据类型的运算操作\n实验内容练习一题目完成以下代码练习，熟悉字符串的相关使用。\n略\n练习二题目输出由任意字符串堆积的 10 行等腰三角形。其中，str.center()方法用于字符串两边填充：str.rjust(width[,fillchar])方法用于字符串右填充。\n代码width = 2*10-1for i in range(1,11):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width,&#x27; &#x27;))\n运行结果￼\n练习三题目能力值的计算：一年 365 天，以第 1 天的能力值为基数，记为 1.0，当每天好好学习时能力值相比前一天提高 1‰，当没有学习时由于遗忘等原因能力值相比前一天下降 1‰，完成下列能力值的计算：(1) 每天努力和每天放任，一年下来的能力值分别多少？(2) 一周 5 个工作日，如果每个工作日都好好学习，在周末放任一下，计算 1 年后的能力值。\n代码#（1）dayfactor = 0.0001dayup = pow(1+dayfactor,365)daydown = pow(1-dayfactor,365)print(&quot;每天努力：&#123;:.3f&#125;,每天放任：&#123;:.3f&#125;&quot;.format(dayup,daydown))#（2）dayfactor = 0.0001dayup = 1.0for i in range(365):    if i%7 in [6,0]:        dayup = dayup*(1-dayfactor)    else:        dayup = dayup*(1+dayfactor)print(&quot;1年后的能力值&#123;:.2f&#125;&quot;.format(dayup))\n练习四题目凯撒密码：设想在某些情况下给朋友传递字条信息，但又不希望传递中途被第三方看懂这些信息，因此需要对字条信息进行加密处理。凯撒密码采用了替换算法对信息中的每一个英文字符循环替换为该字符后面第三个字符，对应关系如下：原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C其它字符保持不变。编程实现：程序接收用户输入待加密的信息，输出加密后的密文。\n代码enter_code = input(&quot;请输入一段信息：&quot;)encode = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;output_code = &quot;&quot;for c in enter_code:    if c in enter_code:        index = encode.index(c)        index += 3        index %= len(encode)        output_code += encode[index]    else:        output_code += cprint(&quot;加密后的密文为：&quot;,output_code)\n练习五题目文本进度条：参考教材，使用字符串完成进度条的设计。要求：(1) 显示当前进度的百分比；(2) 动态刷新显示当前的进度。\n代码import timescale = 50print(&quot;执行开始&quot;.center(scale//2,&#x27;-&#x27;))t = time.clock()for i in range(scale+1):    a = &#x27;*&#x27; * i    b = &#x27;.&#x27; * (scale-i)    c = (i/scale) * 100    t -= time.clock()    print(&quot;\\r&#123;:^.3f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,-t),end=&#x27;&#x27;)    time.sleep(0.05)print(&quot;\\n&quot;+&quot;执行结束&quot;.center(scale//2,&#x27;-&#x27;))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验三 程序的控制结构（分支）","url":"/2021/04/05/python-experiment-3/","content":"实验目的1、掌握程序的单分支结构2、掌握程序的双分支结构3、掌握程序的多分支结构4、掌握 if 的嵌套\n实验内容练习一题目：身体质量指数 BMIBMI 值可以“客观的”衡量个人的肥胖程度或者说健康程度。世界卫生组织（WHO）根据对全球人口体重的统计认为，BMI 值低于 18.5 kg/m2 时属于“过轻”，表明个体可能营养不良或者饮食无法保障；BMI 值高于 25 kg/m2 时属于“过重”。根据下表所示指标编程测试自己的身体指数状况。￼\n代码height ,weight = eval(input(&quot;请输入身高（米）和体重（公斤）[逗号隔开]：&quot;))bmi = weight / pow(height,2)print(&quot;BMI 指数为：&#123;:.2f&#125;&quot;.format(bmi))who,dom=&quot;&quot;,&quot;&quot;if bmi &lt; 18.5:\twho,dom = &quot;偏瘦&quot;,&quot;偏瘦&quot;elif 18.5&lt;= bmi &lt; 24:\twho, dom = &quot;正常&quot;, &quot;正常&quot;elif 24&lt;= bmi &lt; 25:\twho, dom = &quot;正常&quot;, &quot;偏胖&quot;elif 25&lt;= bmi &lt; 28:\twho, dom = &quot;偏胖&quot;, &quot;偏胖&quot;elif 28&lt;= bmi &lt; 30:\twho, dom = &quot;偏胖&quot;, &quot;肥胖&quot;else:\twho, dom = &quot;肥胖&quot;, &quot;肥胖&quot;print(&quot;BMI 指标为：国际&#x27;&#123;0&#125;&#x27;，国内&#x27;&#123;1&#125;&#x27;&quot;.format(who,dom))\n练习二题目：学生成绩等级判断编程实现输入学生成绩 score，得出其等级状况 grade,其对应关系如下：100&gt;=Score&gt;=85 grade=”A”70&lt;=Score&lt;85 grade=”B”60&lt;=Score&lt;70 grade=”C”0&lt;Score&lt;60 grade=”D”Score&gt;100 或 Score&lt;0 给出出错提示\n代码score = input(&quot;请输入你的成绩：&quot;)try:\tscore = eval(score)\tif score &lt; 0 or score &gt; 100: 5. print(&quot;成绩输入有误，请重新输入&quot;)\telse:\t\tif 0 &lt;= score &lt; 60:\t\t\tgrade = &quot;D&quot;\t\telif 60 &lt;= score &lt; 70:\t\t\tgrade = &quot;C&quot;\t\telif 70 &lt;= score &lt; 85:\t\t\tgrade = &quot;B&quot;\t\telif 85 &lt;= score &lt;= 100:\t\t\tgrade = &quot;A&quot; 15. print(&quot;你的成绩属于&#123;&#125;级别&quot;.format(grade))except NameError:\tprint(&quot;输入错误，请输入一个整数！&quot;)\n练习三题目：猜数游戏在程序中预设一个 0-9 之间的整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\t    print(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\t    exit()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验四 程序的控制结构（循环）","url":"/2021/04/05/python-experiment-4/","content":"实验目的1、掌握程序的几种循环结构及扩展用法2、掌握 break 和 continue 的用法3、掌握 random 库的用法4、了解程序的异常处理及用法\n实验内容练习一题目：统计不同字符个数用户从键盘输入一行字符，编写一个程序，统计并输出其中英文字符、数字、空格和其它字符的个数。\n代码charts = input(&quot;请输入一行字符：&quot;)english = num = space = other = 0for i in charts:\tif &#x27;0&#x27;&lt;= i &lt;= &#x27;9&#x27;:\t\tnum += 1\telif (&#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;) or (&#x27;A&#x27; &lt;= i &lt;=&#x27;Z&#x27;):\t\tenglish += 1\telif i == &#x27; &#x27;:\t\tspace += 1\telse:\t\tother += 1print(&quot;在你输入的字符串中：英文字符有&#123;&#125;个，数字有&#123;&#125;个，空格有&#123;&#125;个，其他字符有&#123;&#125;个&quot;.format(english,num,space,other))\n练习二题目：猜数游戏续在上一次猜游戏实验题目的基础上，完善程序，实现如下的功能：系统自动生成 1-100 以内的随机整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。如果用户输入的不是整数，而是小数，则提示用户“输入错误，必须输入整数！”，并让用户重新输入。如果用户输入的不是数字，则给出出错提示“输入格式错误，结束程序！”\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\tprint(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\texit()\n练习三题目：最大公约数计算从键盘接收两个整数，编写程序求出这两个整数的最大公约数和最小公倍数（提示：用辗转相除法求最大公约数，用两数乘积除以最大公约数求得最小公倍数）\n代码num1,num2 = eval(input(&quot;请输入两个整数(逗号隔开输入)：&quot;))greatest_common_divisor = 0least_common_multiple = 0def Calculation(a,b):\tif b == 0:\t\treturn a\t\treturn Calculation(b,a%b)if num1 &lt; num2:\ttemp = num1\tnum1 = num2\tnum2 = tempgreatest_common_divisor = Calculation(num1,num2)least_common_multiple = num2 * num1 / greatest_common_divisorprint(&quot; 两 数 的 最 大 公 约 数 为 &#123;&#125; ， 最 小 公 倍 数 为&#123;:.0f&#125;&quot;.format(greatest_common_divisor,least_common_multiple))\n练习四题目请编写程序实现如下数字金字塔的显示：￼\n代码s = &#x27;&#x27;for i in range(1,10):\ts = s + str(i)\tleft_part = s[::-1]\tright_part = s[1:]\tstrs = left_part + right_part\tprint(strs.center(17,&quot; &quot;))\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验五 组合数据类型","url":"/2021/04/05/python-experiment-5/","content":"实验目的1、理解组合数据类型的概念2、掌握列表、字典与集合的定义和使用方法3、熟练 random 模块的应用\n实验内容练习一题目编写程序，在 26 个字母大小写和 10 个数字组成的列表中随机生成 10个 8 位密码。\n代码#设置的密码没有重复的元素import randomList =[]#存入字母和数字for i in range(26):\tList.append(chr(ord(&#x27;A&#x27;)+i))\tList.append(chr(ord(&#x27;a&#x27;)+i))for i in range(10):\tList.append(str(i))#随机生成 10 个 8 位数的密码for i in range(10):\tpassword_List = random.sample(List,8) #生成结果仍为列表\tpassword = &quot;&quot;.join(password_List) #将列表转化成字符串\tprint(password)\n练习二题目通过键盘输入系列整数值，输入 0 则表示输入结束，将这些值（不含 0）建立为一个列表，并按从大到小的顺序输出该列表各元素。\n代码List = []num = eval(input(&quot;请输入一个整数：&quot;))while num != 0:\tList.append(num)\tnum = eval(input(&quot;请输入一个整数：&quot;))List.sort(reverse = True)for i in range(len(List)):\tprint(List[i])\n练习三题目输入一个大于 2 的自然数， 输出小于该数字的所有素数组成的集合。\n代码import mathdef isprime(n):\tfor i in range(2,n):\t\tif n % i ==0:\t\t\treturn False\t\telse:\t\t\treturn Truenum_input = eval(input(&quot;请输入一个大于 2 的自然数：&quot;))num = math.ceil(num_input)prime_set = set()for i in range(2,num):\tif isprime(i):\t\tprime_set.add(i)\tprint(&quot;小于&#123;&#125;的所有素数集合是：&#123;&#125;&quot;.format(num_input,prime_set))\n练习四题目使用字典来创建程序，提示用户输入电话号码，并用英文单词形式显示数字。例如：输入 138 则显示“one three eight”。\n代码num = [i for i in range(10)]word = [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;]phone_list = dict(zip(num,word))phone_num = input(&quot;请输入电话号码：&quot;)result=&quot;&quot;#print(phone_num)for i in phone_num:\tphone_i = eval(i)\tfor key in phone_list:\t\tif phone_i == key:\t\t\tresult += phone_list[key] + &quot; &quot;print(result)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验六","url":"/2021/04/05/python-experiment-6/","content":"实验目的1、 培养分析问题并对进行建模的能力。2、 熟练使用组合数据类型解决实际问题。3、 熟练运用选择结构和循环结构解决实际问题。\n实验内容练习一题目统计《三国演义》中人物出场次数最多的前 20 人。\n代码import jieba as jietext = (open(&#x27;三国演义.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)).read()words = jie.lcut(text)nowords =&#123;&quot;这个&quot;,&quot;引兵&quot;,&quot;次日&quot;,&quot;人马&quot;,&quot;不知&quot;,&quot;汉中&quot;,&quot;众将&quot;,&quot;只见&quot;,&quot;大喜&quot;,&quot;天下&quot;,&quot;东吴&quot;,&quot;于是&quot;,&quot;今日&quot;,&quot;不敢&quot;,&quot;魏兵&quot;,&quot;陛下&quot;,&quot;太守&quot;,&quot;天子&quot;,&quot;一面&quot;,&quot;原来&quot;,&quot;令人&quot;,&quot;江东&quot;,&quot;喊声&quot;,&quot;下马&quot;,&quot;何不&quot;,&quot;大军&quot;,&quot;忽报&quot;,&quot;先生&quot;,&quot;百姓&quot;,&quot;然后&quot;,&quot;何故&quot;,&quot;先锋&quot;,&quot;不如&quot;,&quot;赶来&quot;,&quot;此人&quot;,&quot;夫人&quot;,&quot;先主&quot;,&quot;后人&quot;,&quot;背后&quot;,&quot;城中&quot;,&quot;蜀兵&quot;,&quot;上马&quot;,&quot;大叫&quot;,&quot;都督&quot;,&quot;一人&quot;,&quot;如何&quot;,&quot;商议&quot;,&quot;却说&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;,&quot;将军&quot;,&quot;二人&quot;,&quot;后主&quot;,&quot;荆州&quot;,&quot;如何&quot;,&quot;主公&quot;,&quot;军马&quot;,&quot;军士&quot;,&quot;左右&quot;,&quot;正是&quot;,&quot;徐州&quot;,&quot;忽然&quot;,&quot;因此&quot;,&quot;成都&quot;,&quot;未知&quot;,&quot;不见&quot;,&quot;大败&quot;,&quot;大事&quot;,&quot;之后&quot;,&quot;一军&quot;,&quot;起兵&quot;,&quot;引军&quot;,&quot;军中&quot;,&quot;接应&quot;,&quot;进兵&quot;,&quot;大惊&quot;,&quot;可以&quot;,&quot;大怒&quot;,&quot;不得&quot;,&quot;以为&quot;,&quot;心中&quot;,&quot;一声&quot;,&quot;下文&quot;,&quot;曹兵&quot;,&quot;追赶&quot;&#125;counts =&#123;&#125;for word in words:\tif len(word) == 1:\t\tcontinue\telif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:\t\trword = &quot;孔明&quot;\telif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:\t\trword = &quot;刘备&quot;\telif word == &quot;孟德&quot; or word == &quot;丞相&quot;:\t\trword = &quot;曹操&quot;\telif word == &quot;关公&quot; or word == &quot;云长&quot;:\t\trword = &quot;关羽&quot;\telse:\t\trword = word\tcounts[rword] = counts.get(rword,0) + 1for word in nowords:\tdel(counts[word])items = list(counts.items())items.sort(key=lambda x:x[1],reverse = True)for i in range(20):\tword,count = items[i]\tprint(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))\n练习二题目编写程序，模拟抓狐狸小游戏。假设一共有一排 5 个洞口，小狐狸最开始的时候在其中一个洞口，然后玩家随机打开一个洞口，如果里面有狐狸就抓到了。如果洞口里没有狐狸就第二天再来抓， 但是第二天狐狸会在玩家来抓之前跳到隔壁洞口里。\n代码import random as ranflag =ran.randint(0,4)tiao = [-1,1]while True:\ttry:\t\tinp = eval(input(&quot;请输入 0-4 中任意一个数：&quot;))\texcept:\t\tprint(&quot;输入格式有误，请重新输入！&quot;)\t\tcontinue\tif inp &lt;0 or inp &gt;4:\t\tprint(&quot;输入范围有误！&quot;)\t\tcontinue\tif inp == flag:\t\tprint(&quot;找到了，游戏结束！&quot;)\t\tbreak\telse:\t\tflag += tiao[ran.randint(0,1)]\t\tflag %= 5\t\tprint(flag)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验七 阶段测试","url":"/2021/04/05/python-experiment-7/","content":"题目一打印输出如下字符图案。￼\n代码width_top = 2*6-1;width_di = 2*5-1;for i in range(1,7):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width_top,&#x27; &#x27;))for i in range(5,-1,-1):    str = &#x27;*&#x27; * (2 * i - 1)    print(str.center(width_top,&#x27; &#x27;))\n题目二输入一个年份，判断并输出该年份是否为闰年。。\n代码date = eval(input(&quot;请输入一个年份：&quot;))# print(date)if (date%100!=0 and date%4==0) or (date%400==0):    print(&quot;&#123;&#125;年是闰年&quot;.format(date))else:    print(&quot;&#123;&#125;年不是闰年&quot;.format(date))\n题目三编写一个程序，输入任意一行字符，并将其中的小写字母转换为大写字母，然后打印输出，注意：非小写字母不转换。\n代码str = input(&quot;请输入一行字符：&quot;)for i in str:    if 97&lt;=ord(i)&lt;=122:        i = chr(ord(i)-32)    print(i,end=&#x27;&#x27;)\n题目四使用turtle库画一个心形，例如：￼\n代码from turtle import *color(&#x27;red&#x27;,&#x27;pink&#x27;)begin_fill()left(140)fd(135)right(180)circle(60,-180)backward(35)right(100)forward(35)circle(-60,180)fd(135)end_fill()exitonclick()\n题目五编写一个程序来计算输入的一行字符串中的单词频率（单词不区分大小写），并按字母顺序对键进行排序，然后输出所有单词及其出现的次数。 提示：对一个字典counts内的单词按字母顺序排序，代码可以为：sorted_words = sorted(counts.keys())\n例如，输入：\nNew to Python or choosing between Python 2 and Python 3? Read Python 2 or Python 3.\n则输出为：￼\n代码str = input(&quot;请输入一行字符串：&quot;)word_dic=&#123;&#125;word =&quot;&quot;for i in str:    if 48&lt;=ord(i)&lt;=57 or 97&lt;=ord(i)&lt;=122:        word = word+i    elif 65&lt;=ord(i)&lt;=90:        i = chr(ord(i)+32)        word = word+i    else:        if word == &quot;&quot;:            continue        else:            word_value = &#123;word: 1&#125;            if (word in word_dic.keys()):                word_dic[word] += 1                word = &quot;&quot;            else:                word_dic.update(word_value)                word = &quot;&quot;sorted_word = sorted(word_dic.items(),key=lambda d:d[0])# print(sorted_word)for key,value in sorted_word:    print(&quot;&#123;&#125;:&#123;&#125;&quot;.format(key,value))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验八 函数","url":"/2021/04/05/python-experiment-8/","content":"实验目的\n掌握函数的定义与调用过程\n掌握参数的传递方式和传递过程\n理解和使用匿名函数\n理解递归调用的思想和方法\n掌握变量的作用域实验内容练习一题目定义求 n!的函数 fact()和求和函数 sum(),在此基础上编程实现 1！+2！+…m!的计算。代码def fact(num):    result = 1    for i in range(1,num+1):        result *= i    return resultdef sum(num):    result = 0    for i in range(1,num+1):        result = result + fact(i)    return resultnum=eval(input(&quot;请输入一个数m：&quot;))print(&quot;1!+2!+...+&#123;&#125;!=&#123;&#125;&quot;.format(num,sum(num)))\n练习二题目定义匿名函数实现求平方，定义判素数函数 list_prime(),该函数可以实现接受任意个数的判断，并将所有素数作为返回值。在此基础上编程实现随机输入任意个数，从中挑选出所有素数，并计算所有素数平方和。代码def list_prime(num):    sum = 0    for i in range(1,num):        if (num % i==0):            sum +=1;    if sum&gt;=2:        return 0    else:        return pingfang(num)def pingfang(num):    return num*num;str = eval(input(&quot;请随机输入任意个数(以逗号分割)：&quot;))sum = 0for i in str:    sum += list_prime(i)print(&quot;你输入的数组中所有素数的平方和为：&#123;&#125;&quot;.format(sum))\n练习三题目分别定义 numlist()和 charlist()函数，numlist()功能是生成由数字 1-26 构成的列表,charlist()功能是生成由字符 A-Z 构成的列表。在此基础上编写程序实现生成一个字典，具体如下：{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’, 5: ‘e’, 6: ‘f’, 7: ‘g’, 8: ‘h’, 9: ‘i’, 10: ‘j’, 11: ‘k’, 12: ‘l’, 13: ‘m’,14: ‘n’, 15: ‘o’, 16: ‘p’, 17: ‘q’, 18: ‘r’, 19: ‘s’, 20: ‘t’, 21: ‘u’, 22: ‘v’, 23: ‘w’, 24: ‘x’, 25: ‘y’,26: ‘z’}遍历字典，输出所有键值为偶数的元素。代码def numlist():    num= []    for i in range(1,27):        num.append(i)    return numdef charlist():    char = []    for i in range(26):        char.append(chr(ord(&#x27;A&#x27;)+i))    return chardictionary = dict(zip(numlist(),charlist()))# print(dictionary)for key in dictionary:    if key%2 ==0:        print(dictionary[key])\n练习四题目绘制科赫雪花，效果如下：￼代码import turtledef koch(size,n):    if n==0:        turtle.fd(size)    else:        for angle in [0,60,-120,60]:            turtle.left(angle)            koch(size/3,n-1)def main():    turtle.setup(600,600)    turtle.speed(0)    turtle.penup()    turtle.goto(-200,100)    turtle.pendown()    turtle.pensize(2)    level = 5    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()    turtle.exitonclick()main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验九 文件与数据格式化","url":"/2021/04/05/python-experiment-9/","content":"实验目的\n掌握文件的基本操作\n理解一、二维和高维数据的格式化过程\n掌握 csv 和 json 格式的相互转换\n综合应用组合数据类型与 CSV 和 JSON 数据格式编写简单的应用程序实验内容练习一题目将提供的 test.csv 文件，具体内容如下：￼编程读入该文件，转换成 JSON 格式文件，并以文件名 out.json 输出。转换后的结果如下所示：[ {  &quot;同比&quot;: &quot;120.7&quot;,\n  &quot;城市&quot;: &quot;北京&quot;,\n  &quot;定基&quot;: &quot;121.4&quot;,\n  &quot;环比&quot;: &quot;101.5&quot;\n\n  },  {  &quot;同比&quot;: &quot;127.3&quot;,\n  &quot;城市&quot;: &quot;上海&quot;,\n  &quot;定基&quot;: &quot;127.8&quot;,\n  &quot;环比&quot;: &quot;101.2&quot;\n\n  } ….]代码#方法一：import jsonfr = open(&quot;test.csv&quot;,&quot;r&quot;)ls = []for line in fr:    line = line.replace(&quot;\\n&quot;,&quot;&quot;)    ls.append(line.split(&#x27;,&#x27;))fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()#方法二：import jsonwith open(&quot;test.csv&quot;,&quot;r&quot;) as fr:    ls = []    for line in fr:        line = line.replace(&quot;\\n&quot;, &quot;&quot;)        ls.append(line.split(&#x27;,&#x27;))    fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()\n练习二题目编写程序制作英文学习字典，词典基本功能如下：(1) 程序读取源文件路径下的 txt 格式词典文件，若没有就创建一个。 词典文件存储方式为 “英文单词 中文单词”,每行仅有一对中英文释义；(2) 程序有添加功能，输入英文单词，如果没有可以添加中文释义，如果有就显示”已经存在，不能添加”；(3) 程序有查询功能，如果存在，则显示其中文释义，不存在就显示不存在；(4) 程序有正常退出的操作。代码import oskeys = []dic = &#123;&#125;def readdict():    if os.path.exists(&quot;dictionary.txt&quot;):        fr = open(&#x27;dictionary.txt&#x27;,&#x27;r&#x27;)    else:        fr = open(&#x27;dictionary.txt&#x27;,&#x27;w+&#x27;)    for line in fr:        line = line.replace(&quot;\\n&quot;,&quot;&quot;)        v = line.split(&#x27;:&#x27;)        dic[v[0]]= v[1]        keys.append(v[0])    fr.close()def writedict(key,value):    with open(&#x27;dictionary.txt&#x27;,&#x27;a&#x27;)as fw:        fw.write(key+&#x27;:&#x27;+value+&#x27;\\n&#x27;)def mydict():    n = input(&quot;请输入进入相应模块（添加，查询，退出）&quot;)    if n == &quot;添加&quot;:        key = input(&quot;请输入英文单词：&quot;)        if key not in keys:            value =input(&quot;字典中未找到单词&#x27;&#123;&#125;&#x27;的中文释义，请输入该单词的中文意思，添加进字典中！&quot;.format(key))            dic[key] = value            keys.append(key)            writedict(key,value)        else:            print(&quot;单词&#x27;&#123;&#125;&#x27;已存在，不能添加&quot;.format(key))        return 0    elif n == &quot;查询&quot;:        key = input(&quot;请输入英文单词:&quot;)        if key not in keys:            print(&quot;英文单词&#x27;&#123;&#125;&#x27;不在字典内&quot;.format(key))        else:            print(dic[key])        return 0    elif n == &quot;退出&quot;:        return 1    else:        print(&quot;输入有误&quot;)        return 0def main():    readdict()    while True:        n = mydict()        if n == 1:            break        if n == 0:            continuemain()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"数据库实验（一）建立数据库","url":"/2021/04/07/Database-experiment-1/","content":"实验类型设计性实验\n实验目的\n熟悉oracle环境。\n熟练掌握和使用PL-SQL建立数据库基本表。\n使用PL/SQL developer操作数据库。\n熟练掌握SQL 建立关系，及增删改数据。\n\n实验内容\n了解SQL PLUS的使用\n使用PL/SQL developer的图形界面，建立图书管理数据库orcl中的读者关系，要求创建主键约束，用户定义的完整性约束（电话号码、身份证号）。\n在建立的读者关系中输入有效数据。\n删除读者关系。\n在PL/SQL developer用SQL代码建立orcl数据库中各关系。\n用SQL 代码完成数据增、删、改。\n\n实验步骤登录数据库\n以SYSTEM登录数据库\n\n\n输入口令为你创建数据库时设置的密码\n\n\n\n\n注册用户、重新以新用户登录数据库\n\n\n\n图形化界面建表\n图书分类（图书分类号，类名）\n\n\n\n\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n\n\n预约（预约流水号，借书证号，ISBN，日期）\n\n\n\n\n\n建立数据库表：打开tables文件夹。建立以下各关系：\n图书分类（图书分类号，类名）\n\n\n\n\n图书分类号\n类名\n\n\n\n100\n文学\n\n\n200\n科技\n\n\n300\n哲学\n\n\ncreate table 图书分类(  图书分类号 NUMBER primary key,  类名    VARCHAR2(4))insert into 图书分类 (图书分类号,类名) values (100,&#x27;文学&#x27;);insert into 图书分类 values (200,&#x27;科技&#x27;);insert into 图书分类 (图书分类号,类名) values (300,&#x27;哲学&#x27;);\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\nISBN\n书名\n作者\n出版单位\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n33.80\n300\n\n\ncreate table 书目(  isbn  NUMBER primary key  书名    VARCHAR2(14),  作者    VARCHAR2(6),  出版单位  VARCHAR2(14),  单价    NUMBER,  图书分类号 NUMBER,  出版年份  NUMBER,  foreign key(图书分类号) references 图书分类(图书分类号))insert into 书目 values (7040195836,&#x27;数据库系统概论&#x27;,&#x27;王珊&#x27;,&#x27;高等教育出社&#x27;,39.00,&#x27;200&#x27;);insert into 书目 values (9787508040110,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;人民出版社&#x27;,20.00,&#x27;100&#x27;);insert into 书目 values (9787506336239,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;作家出版社&#x27;,34.30,&#x27;100&#x27;);insert into 书目 values (9787010073750,&#x27;心学之路&#x27;,&#x27;王珊&#x27;,&#x27;人民出版社&#x27;,33.80,&#x27;300&#x27;);\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n图书编号\nISBN\n是否借出\n备注\n\n\n\n2001231\n7040195836\n否\n\n\n\n2001232\n7040195836\n是\n\n\n\n1005050\n9787506336239\n否\n\n\n\n1005063\n9787508040110\n是\n\n\n\n3007071\n9787010073750\n是\n\n\n\ncreate table 图书(  图书编号 NUMBER primary key,,  isbn NUMBER,  是否借出 VARCHAR2(2),  备注   VARCHAR2(24),  foreign key(ISBN) references 书目(ISBN))insert into 图书 values (2001231,&#x27;7040195836&#x27;,&#x27;否&#x27;,null);insert into 图书 values (2001232,&#x27;7040195836&#x27;,&#x27;是&#x27;,null);insert into 图书 values (1005050,&#x27;9787506336239&#x27;,&#x27;否&#x27;,null);insert into 图书 values (1005063,&#x27;9787508040110&#x27;,&#x27;是&#x27;,null);insert into 图书 values (3007071,&#x27;9787010073750&#x27;,&#x27;是&#x27;,null);\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n借书证号\n姓名\n单位\n性别\n地址\n联系电话\n身份证编号\n\n\n\n20051001\n王菲\n四川绵阳西科大计算机学院\n女\n…\n…\n..\n\n\n20062001\n张江\n四川绵阳中心医院\n男\n…\n…\n..\n\n\n20061234\n郭敬明\n四川江油305\n男\n..\n..\n..\n\n\n20071235\n李晓明\n四川成都工商银行\n男\n..\n..\n..\n\n\n20081237\n赵鑫\n四川广元广元中学\n女\n..\n..\n..\n\n\ncreate table 读者(  借书证号  VARCHAR2(10) primary key,  姓名    VARCHAR2(10),  单位    VARCHAR2(25),  性别    VARCHAR2(2),  地址    VARCHAR2(16),  联系电话  VARCHAR2(16),  身份证编号 VARCHAR2(16))insert into 读者 values (&#x27;20051001&#x27;,&#x27;王菲&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;女&#x27;,null,null,null);insert into 读者 values (&#x27;20062001&#x27;,&#x27;张江&#x27;,&#x27;四川绵阳中心医院&#x27;,&#x27;男&#x27;,&#x27;绵阳&#x27;,null,null,null);insert into 读者 values (&#x27;20061234&#x27;,&#x27;郭敬明&#x27;,&#x27;四川江油305&#x27;,&#x27;男&#x27;,&#x27;四川&#x27;,null,null,null);insert into 读者 values (&#x27;20071235&#x27;,&#x27;李晓明&#x27;,&#x27;四川成都工商银行&#x27;,&#x27;男&#x27;,&#x27;成都&#x27;,null,null,null);insert into 读者 values (&#x27;20081237&#x27;,&#x27;赵鑫&#x27;,&#x27;四川广元广元中学&#x27;,&#x27;女&#x27;,&#x27;广元&#x27;,null,null,null);\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n借书证号\n图书编号\n借书日期\n归还日期\n罚款分类号\n备注\n\n\n\n20081237\n3007071\n2010/09/19\n2010/09/20\n\n\n\n\n20071235\n1005063\n2010/10/20\n2011/02/20\n1\n\n\n\n20071235\n2001232\n2011/09/01\n\n\n\n\n\n20061234\n1005063\n2011/9/20\n\n\n\n\n\n20051001\n3007071\n2011/9/10\n\n\n\n\n\n20071235\n1005050\n2011/10/20\n2012/02/20\n1\n\n\n\ncreate table 借阅(  借阅流水号 NUMBER primary key,  借书证号  VARCHAR2(16),  图书编号  NUMBER(10),  借书日期  DATE,  归还日期  DATE,  罚款分类号 NUMBER,  备注    VARCHAR2(20),  foreign key(借书证号) references 读者(借书证号)  foreign key(图书编号) references 图书(图书编号)  foreign key(罚款分类号) references 罚款分类(罚款分类号))insert into 借阅 values (1,&#x27;20081237&#x27;,3007071,to_date(&#x27;2010-09-19&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2010-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null);insert into 借阅 values (2,&#x27;20071235&#x27;,1005063,to_date(&#x27;2010-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2011-02-20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);insert into 借阅 values (3,&#x27;20071235&#x27;,2001232,to_date(&#x27;2011-09-01&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (4,&#x27;20061234&#x27;,1005063,to_date(&#x27;2011-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (5,&#x27;20051001&#x27;,3007071,to_date(&#x27;2011-09-10&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (6,&#x27;20071235&#x27;,1005050,to_date(&#x27;2011-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2012/02/20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n罚款分类号\n罚款名称\n罚金\n\n\n\n1\n延期\n10\n\n\n2\n损坏\n20\n\n\n3\n丢失\n50\n\n\ncreate table 罚款分类(  罚款分类号 NUMBER primary key,  罚款名称  VARCHAR2(10),  罚金    NUMBER(3))insert into 罚款分类 values (1,&#x27;延期&#x27;,10);insert into 罚款分类 values (2,&#x27;损坏&#x27;,20);insert into 罚款分类 values (3,&#x27;丢失&#x27;,50);\n\n\n预约 （预约流水号，借书证号，ISBN，预约时间）\n\n\n\n\n预约流水号\n借书证号\nISBN\n预约时间\n\n\n\n1\n20081237\n9787508040110\n2011/09/11\n\n\ncreate table 预约(  预约流水号  NUMBER primary key,  借书证号   VARCHAR2(16),  isbn   NUMBER,  s_date DATE)insert into 预约 values (1,&#x27;20081237&#x27;,&#x27;9787508040110&#x27;,&#x27;2011/09/11&#x27;,&#x27;yyyy/mm/dd&#x27;);\n\n使用SQL语句练习表的创建、删除、修改操作select * from 图书;alter table 图书 add 图书分类号 number;alter table 图书 drop column 图书分类号;update 图书 set 是否借出=&#x27;否&#x27; where 图书分类号=&#x27;2002141&#x27;;\n\n试根据下面的完整性约束要求，用SQL对上面已经建立好的数据库表进行完整性约束定义。读者关系中属性  联系电话  取值为11位数字身份证编号  取值为18位，并且满足身份证编号规则\nalter table 读者 add constraint PhoneNumber check(regexp_like(联系电话,&#x27;1[3|4|5|7|8][0-9]&#123;9&#125;&#x27;));alter table 读者 add constraint IDENTITYNUM check(regexp_like(身份证号,&#x27;[1-9\\d&#123;5&#125;(19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|([1-3]0)|31)\\d&#123;3&#125;[0-9Xx]&#x27;))","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验三、四","url":"/2021/04/28/Database-experiment-3/","content":"实验类型验证型实验\n实验目的\n了解存储过程的概念、优点\n熟练掌握创建存储过程的创建方法\n熟练掌握存储过程的调用方法\n\n实验内容\n建立存储过程\n调用存储过程\n\n实验步骤\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\n\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n修改实验三借书功能的存储过程。该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n该存储过程主体部分只有insert into语句。\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n修改实验三还书功能的存储过程。该存储过程要求：（1）还书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）还书时，还书日期为系统时间。\n\n\n该存储过程主体部分只有一条UPDATE语句。\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\n实验结果实验三\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\ncreate or replace procedure Procedure_借书(vis_借阅流水号 in 借阅.借阅流水号%type,vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)asbegin  insert into 借阅  values(vis_借阅流水号,vis_借书证号,vis_图书编号,sysdate,null,null,null);  update 图书  set 图书.是否借出 = &#x27;是&#x27;  where 图书.图书编号 = vis_图书编号;end;\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\ncreate or replace procedure Procedure_预约(vis_预约流水号 in 预约.预约流水号%type,vis_借书证号 in 预约.借书证号%type,vis_ISBN in 预约.ISBN%type)asvis_数量 number;begin  select count(*) into vis_数量 from 图书  where 图书.ISBN=vis_ISBN  and 图书.是否借出=&#x27;否&#x27;;  if vis_数量= 0 then    insert into 预约 values(vis_预约流水号,vis_借书证号,vis_ISBN,sysdate);    commit;  else    dbms_output.put_line(&#x27;该书目有可借图书，请查找！&#x27;);  end if;end;\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\ncreate or replace procedure Procedure_还书(vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type,vis_罚款分类号 in 借阅.罚款分类号%type)asbegin  update 借阅  set 借阅.归还日期=sysdate,借阅.罚款分类号=vis_罚款分类号  where 借阅.借书证号=vis_借书证号  and 借阅.图书编号=vis_图书编号;  update 图书 set 图书.是否借出=&#x27;否&#x27;  where 图书.图书编号=vis_图书编号;end;\n\n实验四\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n\ncreate sequence SEQ_序列minvalue 1maxvalue 1.0E28start with 1increment by 1cache 20;create or replace trigger TR_借阅流水号自增       before insert on 借阅       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.借阅流水号  from dual;end;\n\n\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n\ncreate or replace trigger TR_预约流水号自增       before insert on 预约       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.预约流水号  from dual;end;\n\n3、 修改实验三借书功能的存储过程，该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n\n该存储过程主体部分只有insert into语句。\n\ncreate or replace procedure Processed_借书   (  vis_借书证号 in 借阅.借书证号%type,  vis_图书编号 in 借阅.图书编号%type  )  as vis_是否借出 图书.是否借出%type;begin  select 是否借出 into vis_是否借出 from 图书 where vis_图书编号 = 图书.图书编号;  if vis_是否借出=&#x27;是&#x27; then   dbms_output.put_line(&#x27;该书已经被借走了！&#x27;);  else     select 图书.是否借出     into vis_是否借出     from 图书     where 图书.图书编号=vis_图书编号;    insert into 借阅(借书证号,图书编号,借书日期)     values(vis_借书证号,vis_图书编号,sysdate);   commit;    end if;   end;\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n\ncreate or replace trigger TR_借书       after insert on 借阅       for each rowbegin  update 图书 set 是否借出 = &#x27;是&#x27; where 图书编号 = :new.图书编号;end;\n\n5、 修改实验三还书功能的存储过程，该存储过程要求：（1）还书时输入借书证号，图书编号，罚款分类号。（即该函数有3个输入参数）（2）还书时，还书日期为系统时间。\n\n该存储过程主体部分只有一条UPDATE语句。\n\ncreate or replace procedure Processed_还书 (vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)as vis_是否借出 图书.是否借出%type;begin  update 借阅 set 借阅.归还日期 = sysdate()  where 借阅.借书证号 = vis_借书证号  and 借阅.图书编号 = vis_图书编号  and 借阅.归还日期 is null;end;\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\ncreate or replace trigger TR_还书after update on 借阅for each row  begin    update 图书 set 是否借出 = &#x27;否&#x27;    where 图书编号 = :new.图书编号;end;","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验（二）数据查询","url":"/2021/04/28/Database-experiment-2/","content":"实验类型验证型实验\n实验目的\n掌握查询语句的一般格式；\n熟练掌握单表查询、连接查询、集合查询、统计查询和嵌套查询。\n\n实验内容\n单表查询\n连接查询\n嵌套查询\n集合查询\n\n实验步骤\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n查询学号“20061234”号借书证借阅未还的图书的信息。\n查询各个出版社的图书最高单价、平均单价。\n要查询借阅了两本和两本以上图书的读者的个人信息。\n查询“王菲”的单位、所借图书的书名和借阅日期。\n查询每类图书的册数和平均单价。\n统计从未借书的读者人数。\n统计参与借书的人数。\n找出所有借书未还的读者的信息及所借图书编号及名称。\n检索书名是以“红”开头的所有图书的书名和作者。\n查询各图书的罚款总数。\n查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空（左外连接）\n查询借阅了所有“文学”类书目的读者的姓名、单位。\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n求总藏书量、藏书总金额，总库存册数、最高价、最低价。\n\n列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\n\n列出年份最久远的书?\n\n目前实际已借出多少册书？\n\n哪一年的图书最多？\n\n哪本借书证未归还的图书最多？\n\n平均每本借书证的借书册数。\n\n哪个单位的读者平均借书册数最多？\n\n最近两年都未被借过的书。注意：Oracle 系统日期时间 sysdate，更多关于oracle日期函数请自行查阅。\n\n今年未借过书的借书证。\n\n\n实验结果实验内容\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n\nselect *from 书目,图书where 书目.ISBN=图书.ISBNand 书名=&#x27;红楼梦&#x27;and 是否借出=&#x27;否&#x27;\n\n\n   查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n\nselect *from 书目where 出版单位=&#x27;高等教育出版社&#x27;order by 单价 desc;\n\n\n   统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n\nselect count(ISBN),ISBNfrom 书目where 书名=&#x27;红楼梦&#x27;group by ISBN;\n\n\n   查询学号“20061234”号借书证借阅未还的图书的信息。\n\nselect 借书证号,书名,书目.ISBN ,出版单位,作者,单价,    图书分类号from 书目,借阅,图书where 书目.ISBN=图书.ISBNand 借阅.图书编号=图书.图书编号 and 是否借出=&#x27;是&#x27;and  归还日期 is NULLand 借书证号=20061234;\n\n\n   查询各个出版社的图书最高单价、平均单价。（同上）\n\nselect 出版单位,max(单价),avg(单价)from 书目group by 出版单位;\n\n\n   要查询借阅了两本和两本以上图书的读者的个人信息。\n\nselect * from 读者 where 借书证号 in(select 借书证号from 借阅group by 借书证号 having count(借书证号)&gt;=2);\n\n\n   查询“王菲”的单位、所借图书的书名和借阅日期。\n\nselect 单位,书名,借书日期from 读者,借阅,书目,图书where  姓名=&#x27;王菲&#x27;and 读者.借书证号=借阅.借书证号and 借阅.图书编号=图书.图书编号and 图书.ISBN=书目.ISBN ;\n\n\n   查询每类图书的册数和平均单价。\n\nselect count(图书分类号),avg(单价)from 书目group by 图书分类号;\n\n\n   统计从未借书的读者人数。\n\nselect count(姓名)from 读者where not exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   统计参与借书的人数。\n\nselect count(姓名)from 读者where exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   找出所有借书未还的读者的信息及所借图书编号及名称。\n\nselect distinct 借阅.借书证号,姓名,单位,性别,地址,联系电话,身份证编号,借阅.图书编号,书名from 借阅,书目,读者,图书where 借阅.借书证号=读者.借书证号and 借阅.图书编号=图书.图书编号and 书目.ISBN=图书.ISBNand 归还日期 is null;\n\n\n   检索书名是以“红”开头的所有图书的书名和作者。\n\nselect 书名,作者from 书目where 书名 like &#x27;红%&#x27;;\n\n\n   查询各图书的罚款总数。（分组，图书编号+罚款总数）\n\nselect 书目.ISBN,sum(罚金)from 借阅,罚款分类,书目,图书where 借阅.罚款分类号=罚款分类.罚款分类号and 借阅.图书编号=图书.图书编号group by 书目.ISBN\n\n\n   查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空\n\nselect * from 借阅  left outer join 罚款分类 on(借阅.罚款分类号=罚款分类.罚款分类号)\n\n\n   查询借阅了所有“文学”类书目的读者的姓名、单位。（判断条件）\n\nselect 读者.姓名,读者.单位from 读者where not exists(      select *      from 书目,图书分类      where 书目.图书分类号=图书分类.图书分类号 and 图书分类.类名=&#x27;文学&#x27; and not exists      (            select *            from 借阅,图书            where 借阅.图书编号=图书.图书编号 and 借阅.借书证号=读者.借书证号 and 书目.ISBN=图书.ISBN      ))\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n\nalter table 书目add 出版年份 number;update 书目 set 出版年份=2005 where ISBN=7040195836;update 书目 set 出版年份=1983 where ISBN=9787508040110;update 书目 set 出版年份=2008 where ISBN=9787506336239;update 书目 set 出版年份=2009 where ISBN=9787010073750;\n\n2、求总藏书量、藏书总金额，总库存册数、最高价、最低价。\nselect count(图书编号),sum(单价),max(单价),min(单价)from 书目,图书where 书目.ISBN=图书.ISBN;\n\n3、列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\nselect 书名,作者,出版单位,出版年份from 书目where 书目.ISBN in(select 图书.ISBNfrom 图书group by 图书.ISBN having count( 图书.ISBN)&gt;5);\n\n4、列出年份最久远的书?\nselect 书名,作者,出版单位,出版年份from 书目where 书目.出版年份 in(select min(书目.出版年份)from 书目)\n\n5、目前实际已借出多少册书？\nselect count(借阅.借阅流水号) 借出数量from 借阅where 归还日期 is null;\n\n6、哪一年的图书最多？\nselect * from (select 出版年份,count(出版年份) 数量 from 图书,书目 where 图书.ISBN = 书目.ISBNgroup by 出版年份 order by count(出版年份) desc ) where rownum=1;\n\n7、 哪本借书证未归还的图书最多？\nselect * from (select 借书证号from 借阅where 归还日期 is nullgroup by 借书证号order by count(借书证号) desc) where rownum=1\n\n8、平均每本借书证的借书册数。\nselect 借书证号,count(借书证号)from 借阅 group by 借书证号;\n\n9、哪个单位的读者平均借书册数最多？\nselect 读者.单位from 读者where 读者.借书证号 in (select 借书证号 from (select 借书证号, count(借书证号)from 借阅group by 借书证号order by  count(借书证号) desc ) where rownum=1);\n\n10、最近两年都未被借过的书。\nselect distinct(书目.ISBN),书目.书名,书目.出版单位from 图书,书目,借阅where 图书.图书编号=借阅.图书编号and 书目.ISBN=图书.ISBNand 借阅.借书日期not between to_date(&#x27;20180101&#x27;,&#x27;yyyy/mm/dd&#x27;)and to_date(&#x27;20191231&#x27;,&#x27;yyyy/mm/dd&#x27;);","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验五、六","url":"/2021/04/28/Database-experiment-4/","content":"实验类型验证型实验\n实验目的\n了解数据库恢复技术的原理\n了解oracle各类故障的数据恢复方法\n了解oracle的物理备份\n掌握oracle数据库逻辑备份方法\n掌握oracle数据库恢复的方法\n学会使用exp备份数据库、使用imp恢复数据库\n了解flashback 的使用\n学会使用PLSQL/developer工具完成导入导出\n理解数据库的安全性保护\n掌握ORACLE中有关用户创建的方法\n理解数据库存取控制机制\n熟练掌握PL-SQL的数据控制语言，能通过自主存取控制进行权限管理\n熟悉用户资源文件的使用\n熟悉ORACLE中角色管理\n熟悉视图机制在自主存取控制上的应用\n\n实验内容\n查看归档模式\n使用exp导出数据库\n使用imp导入数据库\n使用flashback 闪回表\n使用PLSQL/developer工具完成导出\n使用PLSQL/developer工具完成导入\n\n实验步骤实验五\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。\n热备份和冷备份，分别使用什么归档模式？\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n客户端可以使用RMAN进行热备份吗？\n逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl按照提示进行导出（2）删除自己表空间中的“预约”表（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl按照提示进行导入（4）查询导入的“预约”表中的信息。（5）导出数据库（以全库方式导出）。\n\n\n必须是DBA才能执行完整数据库或表空间导出操作。\n\n\n使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE   ROW  MOVEMENT（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE   读者 TO TIMESTAMP   TO_ TIMESTAMP(….)\n使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签SQL 插入（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导入表，利用SQL插入导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer（3）浏览或者输入输出文件，然后点击导出。（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n\n实验六\n同学之间相互授权访问对方“读者”表并能进行查询。\n以SYS登录数据库 为你的账号增加系统角色DBA.\n重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。\n建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）\n创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。\n建立视图VIEW_READER, 该视图包含书目（ISBN, 书名，作者，出版单位，图书分类名称）（注：所有属性来自关系书目和图书分类）\n创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。\n\n实验结果\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。使用SYS登录，由于是超级管理员所以要使用： “口令+ as sysdba”登录\n\n\n\n输入archive log list\n\n\n\n热备份和冷备份，分别使用什么归档模式？热备份针对归档模式的数据库，在数据库仍旧处于工作状态时进行备份。而冷备份是指在数据库关闭后，进行备份，适用于所有模式的数据库，热备份的优点在于当备份时，数据库仍旧可以被使用并且可以将数据库恢复到任意一个时间点。冷备份的优点在于他的备份和回复操作相当简单，并且由于冷备份的数据可以工作在非归档模式下，数据库性能会比归档模式稍好。\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n\n1)正常关闭数据库2)备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）3)完成备份后启动数据库4. 客户端可以使用RMAN进行热备份吗？ 可以5. 逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl 按照提示进行导出\n\n\n（2）删除自己表空间中的“预约”表\n\n\n\n（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl，按照提示进行导入\n\n\n\n（4）查询导入的“预约”表中的信息。\n\n\n（5）导出数据库（以全库方式导出）。exp S5120188039/yyk1776572104@orcl FULL=Y\n\n\n\n\n6、使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE ROW MOVEMENT\n\n\n（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。插入数据：\nINSERT INTO 读者 VALUES(&#x27;20181452&#x27;,&#x27;胡晋源&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20186666&#x27;,&#x27;吕硕&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20188039&#x27;,&#x27;姚永坤&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null); \n\n（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE 读者 TO TIMESTAMP TO_ TIMESTAMP(….)代码：\nFLASHBACK TABLE 读者 TO TIMESTAMP TO_TIMESTAMP(&#x27;2020/11/15 16:30:00&#x27;,&#x27;YYYY/MM/DD HH24:MI:SS&#x27;);\n\n7、使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具”导出表\n\n\n（2）点击你要导出的表，然后选择标签SQL插入\n\n\n（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出\n\n\n（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导入表，利用SQL插入导入数据库预约表。\n\n\n\n（8）查询导入的预约表，检查导出是否正确。\n\n\n8、使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer\n\n\n（3）浏览或者输入输出文件，然后点击导出。\n\n\n（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。\n\n\n（8）查询导入的预约表，检查导出是否正确\n\n\n实验六1、同学之间相互授权访问对方“读者”表并能进行查询。2、以SYS登录数据库 为你的账号增加系统角色DBA.\n\n\n使用 “GRANT DBA TO + 用户名”给自己的账号增加系统角色DBA：\n\n\n3、 重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。（1）登录\n\n\n（2）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER1 IDENTIFIED BY ORCL;\n\n\n\n（3）使用GRANT CONNECT TO S5120188039_USER1;\nGRANT RESOURCE TO S5120188039_USER1;GRANT DBA TO S5120188039_USER1;\n\n\n4、 建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）（1）创建角色\nCREATE ROLE S5120188039_OPER;\n\n（2）授权\nGRANT EXECUTE ON PROCESSED_借书 TO S5120188039_OPER;GRANT EXECUTE ON PROCESSED_还书 TO S5120188039_OPER;GRANT EXECUTE ON PROCEDURE_预约 TO S5120188039_OPER;\n\nGRANT SELECT ON 读者 TO S5120188039_OPER;GRANT SELECT ON 书目 TO S5120188039_OPER;GRANT SELECT ON 图书 TO S5120188039_OPER;GRANT SELECT ON 借阅 TO S5120188039_OPER;GRANT SELECT ON 预约 TO S5120188039_OPER;\n\n\n5、创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。（1）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER2 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT S5120188039_OPER TO S5120188039_USER2;\n\n（3）重新登录并且实现借书过程\n\nCALL S5120188039.PROCESSED_借书(20051001,1005050);\n\n（4）查询结果\n\n\n7、 创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。（1）创建数据库用户\nCREATE USER S5120188039_USER3 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT CONNECT TO S5120188039_USER3;\n\nGRANT SELECT ON VIEW_READER TO S5120188039_USER3;\n\n（3）创建概要文件\nCREATE PROFILE LOCK_USER LIMITFAILED_LOGIN_ATTEMPTS 3PASSWORD_LOCK_TIME 10;\n\n（4）分配概要文件\nALTER USER S5120188039_USER3 PROFILE LOCK_USER;\n\n（5）测试输入错误，锁定用户\n\n\n（6）账户锁定进行解锁\nALTER USER S5120188039_USER3 ACCOUNT UNLOCK;\n\n（7）再次测试\n","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"HTML语义化","url":"/2021/05/28/Html-study-1/","content":"定义\nHTML语义化就是根据具体内容，选择合适的标签进行代码的编写。便于开发者阅读和写出更优雅的代码，同时让搜索引擎的爬虫能更好的识别。\n\n简单来讲就是：用正确的标签做正确的事\n\n\n举例说明比如说：\n\n段落用&lt;p&gt;标签\n标题用h1~h6标签\n文章就用article\n\n为什么要使用语义化标签1、 CSS文件读取失败的准备：万一CSS文件挂了，语义化的HTML也能呈现较好的内容结构与代码结构。2、 提高：    - 可访问性：简单来讲，便于其他设备的解析，比如：移动端设备，盲人阅读器等；    - 可检索性：提高搜索引擎的有效爬取，提高网站流量；    - 国际化：让各国开发者容易弄懂网页结构；    - 互用性：减少网页间的差异性，便于团队开发和维护。\n","categories":["HTML学习笔记"],"tags":["HTML","HTML学习笔记"]},{"title":"Http和Https","url":"/2021/04/28/Front-end-basic-learning-1/","content":"Http和Https基本概念\nHttp\n超文本传输协议，是互联网上应用最为广泛的一种网络协议\n是一个客户端和服务器端请求和应答的标准，即TCP\n用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少\nHTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response。\n\n\nHttps\n以安全为目标的http通道/http的安全版\nhttp下加入SSL层\n安全基础为SSL，加密内容需要SSL\n主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n优点：使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n缺点：\nhttps 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\nhttps 缓存不如 http 高效，会增加数据开销。\nSSL 证书需要钱，功能越强大的证书费用越高。\nSSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。\n\n\n\n\n\ntips：\n\nSSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。\nSSL协议可分为两层：  ① SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。  ② SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。\n\n区别\nhttp传输的数据是未加密的，连接很简单，是无状态的；https由SSL协议来对http协议传输的数据进行加密，安全性更高\nHttps 协议需要 ca 证书，费用较高。\n使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443\n\ntips：\n\nCA是证书的签发机构，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。\nCA是负责签发证书、认证证书、管理已颁发证书的机关。\nCA 拥有一个证书（内含公钥和私钥）。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。\n\nhttps协议工作原理① 客户使用 https url 访问服务器，web 服务器建立 ssl 链接② web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。③ 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。④ 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。⑤ web 服务器通过自己的私钥解密⑥ web 服务器通过会话密钥加密与客户端之间的通信。\nhttp 请求的方式\n1、OPTIONS&emsp;&emsp;返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD&emsp;&emsp;向服务器索取与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET&emsp;&emsp;向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url4、POST&emsp;&emsp;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form5、PUT&emsp;&emsp;向指定资源位置上传其最新内容6、DELETE&emsp;&emsp;请求服务器删除Request-URL所标识的资源7、TRACE&emsp;&emsp;回显服务器收到的请求，主要用于测试或诊断8、CONNECT&emsp;&emsp;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n","categories":["前端学习笔记"],"tags":["前端","Http","Https"]},{"title":"TCP和UDP","url":"/2021/07/20/tcp-ip/","content":"TCP 三次握手\n\n\nC 发起请求连接 S 确认，也发起连接 C 确认① 第一次握手：S确认可以接收C发送的报文段② 第二次握手：C确认S收到了自己发送的报文段，然后确认接受到了S发送的报文段③ 第三次握手：S确认C接受到了自己发送的报文段\n\nTCP和UDP的区别\n\n\n比较项\nTCP\nUDP\n\n\n\n首部\n首部为20字节\n只有8个字节\n\n\n连接上\n面向连接，可靠性传输\n发送数据前不需要先建立链接，不可靠\n\n\n传输上\n无差错，不丢失，不重复，且按序到达\n尽最大努力交付，不保证可靠交付\n\n\n对象上\n面向字节流，网络出现拥塞发送率会降低\n面向报文，网络出现拥塞会出现丢包情况\n\n\n服务对象数量\n仅支持1对1\n支持1对1，1对多\n\n\n","categories":["前端学习笔记"],"tags":["TCP","UDP"]},{"title":"JavaScript学习笔记（一）JS概述","url":"/2021/07/20/js-1/","content":"JavaScript实现完整的 JavaScript 实现包含以下几个部分：\n\n核心（ECMAScript）\n文档对象模型（DOM）\n浏览器对象模型（BOM）\n\nECMAScript\nWeb 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。\nECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。\nECMAScript符合性\n支持 ECMA-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；\n支持 Unicode 字符标准。\n增加 ECMA-262 中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。\n支持 ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。\n\n\n\nDOM\n定义：文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使用扩展的 XML。\nDOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。\n\nDOM级别\nLevel1：目标是映射文档结构\nLevel2：增加了对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）。\nLevel3：增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM Load and Save 的新模块中），还有验证文档的方法（DOM Validation）\n\nBOM\n定义：浏览器对象模型（BOM）API，用于支持访问和操作浏览器的窗口。\n是唯一一个没有相关标准的 JavaScript 实现。\nBOM 主要针对浏览器窗口和子窗口（frame）\n\n","categories":["前端学习笔记","JS","ECMAScript","DOM","BOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二）HTML中的JavaScript","url":"/2021/07/20/js-2/","content":"&lt;script&gt;元素&lt;script&gt;元素拥有的属性\n\n\n属性\n状态\n作用\n备注\n\n\n\nasync\n可选\n立即开始下载脚本，但不能阻止其他页面动作\n只对外部脚本文件有效\n\n\ncharset\n可选\n使用 src 属性指定的代码字符集\n很少使用，大多数浏览器不在乎其值\n\n\ncrossorigin\n可选\n配置相关请求的CORS（跨源资源共享）设置\n默认不使用CORS\n\n\ndefer\n可选\n表示脚本可以延迟到文档完全被解析和显示之后再执行\n只对外部脚本文件有效\n\n\nintegrity\n可选\n允许比对接收到的资源和指定的加密签名以验证子资源完整性\n用于确保内容发布网络不会提供恶意内容\n\n\nlanguage\n废弃\n用于表示代码块中的脚本语言\n\n\n\nsrc\n可选\n表示包含要执行的外部文件\n\n\n\ntype\n可选\n标识代码块中脚本语言的内容类型\n代替language\n\n\nJavaScript代码引入方式直接在网页中嵌入JavaScript代码\n示例：\n&lt;script&gt;    function message()&#123;        console.log(&quot;Hello World!&quot;)    &#125;&lt;/script&gt;\n&lt;script&gt;内的代码会被从上到下解释；\n\n在使用行内 JavaScript 代码时，要注意代码中不能出现字符串&lt;/script&gt;；\n\n浏览器解析行内脚本的方式决定了它在看到字符串&lt;/script&gt;时，会将其当成结束的&lt;/script&gt;标签。想避免这个问题，只需要转义字符“\\”。\n\n\n//错误&lt;script&gt;    function message()&#123;        console.log(&quot;&lt;/script&gt;&quot;);    &#125;&lt;/script&gt;//正确写法&lt;script&gt;    function message()&#123;        console.log(&quot;&lt;\\/script&gt;&quot;);    &#125;&lt;/script&gt;\n\n通过在网页中包含外部JS文件\n前提：在&lt;script&gt;标签中使用src属性引入外部文件。\n\n不同文档的引入方式：\n//HTML&lt;script src=&quot;message.js&quot;&gt;&lt;/script&gt;//XHTML&lt;script src=&quot;message.js&quot;/&gt;\n外部JS文件的扩展名是js，不是必须的。\n\n浏览器不会检查所包含JS文件的扩展名\n为使用服务器端脚本语言动态生成JS代码/在浏览器中将JS扩展语言转译为JS提供了可能性。\n\n\n使用src属性后&lt;script&gt;标签中不应该包含其他JS代码\n\n如果都存在，则会忽略行内代码同时下载并执行脚本文件\n\n\nsrc属性可以是完整的URL  ① src属性向指定路径发送一个GET请求  ② 获取相应资源\n\n该GET请求：\n\n不受浏览器同源策略限制\n受父页面HTTP/HTTPS协议的限制\n\n\n\n标签位置\n将所有JS引用放在&lt;body&gt;元素中&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;     &lt;title&gt;Hello World&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 这里是页面内容 --&gt;         &lt;script src=&quot;message1.js&quot;&gt;&lt;/script&gt;         &lt;script src=&quot;message2.js&quot;&gt;&lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;\n\n推迟执行脚本\n&lt;script&gt;的defer属性：表示脚本会被延迟到整个页面都解析完毕后再运行。\n只对外部脚本文件有效\nH5规范要求脚本因该按照它们出现的顺序执行\n建议：将需要推迟的脚本放在页面底部\n\n&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;     &lt;title&gt;Hello World&lt;/title&gt;    &lt;script defer src=&quot;message1.js&quot;&gt;&lt;/script&gt;    &lt;script defer src=&quot;message2.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 这里是页面内容 --&gt;     &lt;/body&gt; &lt;/html&gt;\n\n异步执行脚本\nH5为&lt;script&gt;元素定义了async属性，表示：脚本不需要等待其他脚本，同时也不阻塞文档渲染\n只适用于外部脚本\n添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本\n异步脚本不应该再加载期间修改DOM\n使用async后页面不能使用document.write\n\n动态加载脚本\n向DOM中动态添加script元素\nlet script = document.createElement(&#x27;script&#x27;);script.src = &#x27;message.js&#x27;;document.head.appendChild(script);\n默认为异步方式加载，可以设置同步加载\n\n在文档头部显式声明，进而让预加载器知道动态请求文件的存在\n&lt;link rel=&quot;preload&quot; href=&quot;message.js&quot;&gt;\n\n外部文件优点\n可维护性：用一个目录保存所有JS文件，更容易维护\n缓存：根据特定的设置缓存所有外部链接的JS文件\n适应未来\n\n文档模式作用告诉浏览器以哪种模式呈现，如何解析文档，也就是说两种模式主要影响CSS内容的呈现，某些情况下也会影响JavaScript的执行。\n类型\n混杂模式：向后兼容的解析方式\n标准模式：要求严格的DTD，根据web标准去解析页面的模式\n准标准模式：准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计\n\n模式开启方法1、 混杂模式\n混杂模式在所有浏览器中都以省略文档开头的doctype声明作为开关\n2、 标准模式\n&lt;!-- HTML 4.01 Strict --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;!-- XHTML 1.0 Strict --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; &lt;!-- HTML5 --&gt; &lt;!DOCTYPE html&gt;\n\n3、 准标准模式\n&lt;!-- HTML 4.01 Transitional --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;!-- HTML 4.01 Frameset --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; &lt;!-- XHTML 1.0 Transitional --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;!-- XHTML 1.0 Frameset --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三）JS语法基础","url":"/2021/07/21/js-3/","content":"标识符定义&emsp;&emsp;变量、函数、属性或函数参数的名称。\n规则命名规则\n第一个字符必须是一个字母、下划线或美元符号\n剩下字符可以是字母、下划线、美元符号或数字\n\n其它\n使用小驼峰命名方式（首字母小写，后面每个单词首字母大写）\n关键字、保留字、true、false和null不能作为标识符\n\n严格模式在脚本开头加上：&quot;use strict&quot;;\nfunction message()&#123;    &quot;use strict&quot;;    //函数体&#125;\n\n关键字和保留字\n关键字：\n\n保留字：\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四）变量声明关键字","url":"/2021/07/21/js-4/","content":"var作用域\n使用var操作符定义的变量会成为包含它的函数的局部变量\n去掉var操作符，该操作符成为全局变量\n严格模式下，如果向这样给未声明的变量赋值，会导致抛出 ReferenceError。function test()&#123;    var message = &quot;Hello World!&quot;;&#125;test()console.log(message)//报错----------------------function test()&#123;    message = &quot;Hello World!&quot;;&#125;test()console.log(message)//Hello World!\n\n声明提升\n把所有变量声明都拉到函数作用域的顶部\n\nfunction test()&#123;    console.log(message);    var message = &quot;Hello World!&quot;;&#125;test()//underfined--------等价如下代码--------function test()&#123;    var message;    console.log(message);    message = &quot;Hello World!&quot;;&#125;test()//underfined\n\nlet\n块作用域：作用域仅限于该块内部。\nif(true)&#123;    let message = &quot;Hello World!&quot;;    console.log(message)//Hello World!&#125;console.log(message)//ReferenceError:message没有定义\n同一个块级作用域不能出现重复声明\n\n声明冗余报错不会因混用 let 和 var 而受影响\n\n原因：这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在var message;var message;//正常声明不会报错--------------let message;let message;//SyntaxError:标识符message已经声明过了--------------let message;var message;//SyntaxError:标识符message已经声明过了\n\n\n对于嵌套使用相同标识符，不会出错。\n//声明的变量的值被覆盖if(true)&#123;    var message = &quot;Hello&quot;;    console.log(message)//Hello    if(true)&#123;        var message = &quot;World!&quot;;        console.log(message)//World!    &#125;&#125;-----------------------------------//声明变量的作用域不同if(true)&#123;    let message = &quot;Hello&quot;;    console.log(message)//Hello    if(true)&#123;        let message = &quot;World!&quot;;        console.log(message)//World!    &#125;&#125;\n\n暂时性死区\n定义：let声明之前的执行瞬间被称为“暂时性死区”\n在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。console.log(message);//ReferenceError:message没有定义let message = &quot;Hello World!&quot;;\n\n\n\n全局声明\nlet在全局作用域中声明的变量，不会成为windows对象的属性var message = &quot;Hello World!&quot;;console.log(window.message)//Hello World!-------------------let message = &quot;Hello World!&quot;;console.log(window.message)//underfined\n\n条件声明\nlet不能依赖条件声明模式\n\nfor循环中的let声明\n对比以下实例：\n\nfor(var i=0;i&lt;5;i++)&#123;&#125;console.log(i)//5------------------for(let i=0;i&lt;5;i++)&#123;&#125;console.log(i)//ReferenceError:i未定义\n\nvar声明的迭代变量保存的是导致循环退出的值\nlet声明的迭代变量会为每一个迭代循环声明一个新的迭代变量for(var i=0;i&lt;5;i++)&#123;    setTimeout(()=&gt;console.log(i),0)&#125;//5,5,5,5,5--------------------for(let i=0;i&lt;5;i++)&#123;    setTimeout(()=&gt;console.log(i),0)&#125;//0,1,2,3,4\n\nconst声明\n与let基本相同\n声明变量时必须同时初始化变量，且初始化后不能被修改\nconst声明的限制只适用于它指向的变量的引用const message = &#123;&#125;;message.first = &quot;Hello World!&quot;;message.second = &quot;Say GoodBye!&quot;;\n对于for-of和for-in循环可以很好的使用for(const key in &#123;a:1,b:2&#125;)&#123;    console.log(key)&#125;//a,b\n\n总结比较\n\n\n比较项\nvar\nlet\nconst\n\n\n\n作用域\n全局作用域\n块级作用域\n块级作用域\n\n\n变量声明提升\n是\n否\n否\n\n\n重复声明\n是\n否\n否\n\n\n优先级\n尽量不使用\n次之\n最高\n\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（五）数据类型概述","url":"/2021/07/21/js-5/","content":"数据类型\nECMAScript有6种简单数据类型：Undefined、Null、Boolean、Number、String、Symbol。其中Symbol时ES6新增的数据类型\nObject为复杂数据类型\n\ntypeof操作符\ntypeof是一个操作符，不是函数let message = &quot;Hello World!&quot;;console.log(typeof message);//stringconsole.log(typeof(message));//string\n调用typeof null 返回的是”object”\n特殊值 null 被认为是一个对空对象的引用\n\n\n\n返回值当我们在使用typeof操作符来检测变量时会得到下列字符串之一：\n\n\n\n字符串\n意义\n\n\n\nunderfined\n未定义\n\n\nboolean\n布尔值\n\n\nstring\n字符串\n\n\nnumber\n数值\n\n\nobject\n对象或null\n\n\nfunction\n函数\n\n\nsymbol\n符号\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（六）操作符","url":"/2021/07/21/js-6/","content":"\n操作符包括：数学操作符、位操作符、关系操作符和相等操作符。\n操作符可用于各种值，包括字符串、数值、布尔值、甚至还有对象。\n在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。\n\n一元操作符定义\n只操作一个值的操作符叫一元操作符\n\n递增/递减操作符分类\n前缀版\n操作符位于待操作变量的前面\n副作用：无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变let num = 10;let other = --num + 5;let another = num + 5;console.log(num);//9console.log(other);//14console.log(another);//14\n\n\n后缀版\n操作符位于待操作变量的后面\n后缀版递增和递减在语句被求值后才发生let num = 10;let another = num-- + 5;console.log(num);//10console.log(another);//14\n\n\n前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。\n\n规则\n\n\n数据类型\n规则\n类型转换\n\n\n\n字符串\n有效数值形式，转换为数值再应用改变\n字符串→数值\n\n\n字符串\n非有效数值形式，将变量的值设置为NaN\n字符串→数值\n\n\ntrue\n转换为1再应用改变\n布尔值→数值\n\n\nfalse\n转换为0再应用改变\n布尔值→数值\n\n\n浮点数\n加1或减1\n\n\n\n对象\n调用valueOf()方法取得可以操作的值，对得到的值应用上述规则；如果是NaN，则调用toString()并再次应用其他规则\n对象→数值\n\n\n一元加和减一元加号\n如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换；\n布尔值 false和 true 转换为 0 和 1；\n字符串根据特殊规则进行解析；\n对象会调用它们的 valueOf()和/或 toString()方法以得到可以转换的值。\n\nlet s1 = &quot;01&quot;;let s2 = &quot;1.1&quot;;let s3 = &quot;z&quot;;let a = &#x27;25&#x27;;let b = false;let f = 1.1;let o = &#123;    valueOf()&#123;        return -1;    &#125;&#125;console.log(+s1);//1console.log(+s2);//1.1console.log(+s3);//NaNconsole.log(+a);//25console.log(+b);//0console.log(+f);//1.1console.log(+o);//-1\n\n一元减号\n一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值；\n在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：\n\nlet s1 = &quot;01&quot;;let s2 = &quot;1.1&quot;;let s3 = &quot;z&quot;;let a = &#x27;25&#x27;;let b = false;let f = 1.1;let o = &#123;    valueOf()&#123;        return -1;    &#125;&#125;console.log(-s1);//-1console.log(-s2);//-1.1console.log(-s3);//NaNconsole.log(-a);//-25console.log(-b);//0console.log(-f);//-1.1console.log(-o);//-1\n\n位操作符\nECMAScript中的所有数值都以 IEEE 754 64位格式存储；\n位操作并不直接应用到 64 位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位；\n有符号整数使用 32 位的前 31 位表示整数值；第 32 位表示数值的符号，如 0 表示正，1 表示负。\n负值以一种称为二补数（或补码）的二进制编码存储。\n特殊值NaN 和Infinity在位操作中都会被当成 0 处理；\n如果将位操作符应用到非数值，那么首先会使用 Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。\n\n按位非\n按位非操作符用波浪符（~）表示\n按位非的最终效果是对数值取反并减 1\n\n按位与\n按位与操作符用和号（&amp;）表示。\n真值表：a&amp;b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n0\n\n\n按位或\n按位或操作符用管道符（|）表示。\n真值表：a|b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n1\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n按位异或\n按位异或操作符用脱字符（^）表示。\n真值表：a^b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n左移\n左移操作符用两个小于号（&lt;&lt;）表示\n如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000）\n\n\n\n有符号右移\n有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）\n\n\n\n无符号右移\n无符号移用 3 个大于号表示（&gt;&gt;&gt;），会将数值的所有 32 位都向右移\n对于正数，无符号右移与有符号右移结果相同。\n\n布尔操作符布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。\n逻辑非\n逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值，始终返回布尔值。\n逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。\n转化规则：\n\n\n\n\n操作数\n结果\n\n\n\n对象\nfalse\n\n\n空字符串\ntrue\n\n\n非空字符串\nfalse\n\n\n数值0\ntrue\n\n\n非0数值\nfalse\n\n\nnull\ntrue\n\n\nNaN\ntrue\n\n\nunderfined\ntrue\n\n\n\n同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。\n\n逻辑与\n逻辑与操作符由两个和号（&amp;&amp;）表示\n\n\n\n\n操作数一\n操作数二\nresult\n\n\n\ntrue\ntrue\ntrue\n\n\ntrue\nfalse\nfalse\n\n\nfalse\ntrue\nfalse\n\n\nfalse\nfalse\nfalse\n\n\n\n如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n第一个操作数是对象\n返回第二个操作数\n\n\n第二个操作数是对象\n只有第一个操作数求值为true才会返回该对象\n\n\n两个操作数都是对象\n返回第二个操作数\n\n\n有一个操作数是null\n返回null\n\n\n有一个操作数是NaN\n返回NaN\n\n\n有一个操作数是underfined\n返回underfinded\n\n\n\n逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。\n当变量未被定义则不能对它应用逻辑与操作符。\n\n逻辑或\n逻辑或操作符由两个管道符（||）表示\n\n\n\n\n操作数一\n操作数二\nresult\n\n\n\ntrue\ntrue\ntrue\n\n\ntrue\nfalse\ntrue\n\n\nfalse\ntrue\ntrue\n\n\nfalse\nfalse\nfalse\n\n\n\n如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n第一个操作数是对象\n返回第一个操作数\n\n\n第二个操作数求值为false\n返回第二个操作数\n\n\n两个操作数都是对象\n返回第一个操作数\n\n\n两个操作数是null\n返回null\n\n\n两个操作数是NaN\n返回NaN\n\n\n两个操作数是underfined\n返回underfinded\n\n\n\n逻辑或操作符也具有短路的特性，第一个操作数求值为true，第二个操作数就不会再被求值了。\n\n乘性操作符\nECMAScript 定义了 3 个乘性操作符：乘法、除法和取模。\n如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。\n\n乘法操作符（*）\n\n\n操作数\n结果\n\n\n\n都是数值\n正值相乘为正，负值相乘为正，正负不同相乘为负；如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity乘以 0\n返回 NaN\n\n\n如果是 Infinity 乘以非 0的有限数值\n根据第二个操作数的符号返回 Infinity 或-Infinity\n\n\n如果是 Infinity 乘以 Infinity\n返回 Infinity\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n除法操作符（/）\n\n\n操作数\n结果\n\n\n\n都是数值\n正值相乘为正，负值相除为正，正负不同相除为负；如果 ECMAScript 不能表示商，则返回 Infinity 或-Infinity。\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity除以 Infinity\n返回 NaN\n\n\n如果是 0除以 0\n返回 NaN\n\n\n如果是 非0的有限值除以0\n根据第一个操作数的符号返回 Infinity 或-Infinity\n\n\n如果是 Infinity 除以任何数值\n根据第二个操作数的符号返回 Infinity\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n取模操作数（%）\n\n\n操作数\n结果\n\n\n\n都是数值\n执行常规除法运算，返回余数\n\n\n如果被除数是无限值，除数是有限值\n返回 NaN\n\n\n如果被除数是有限值，除数是0\n返回 NaN\n\n\n如果是 0 除以 0\n返回 NaN\n\n\n如果是 Infinity 除以 Infinity\n返回NaN\n\n\n如果被除数是有限值，除数是无限值\n返回NaN\n\n\n如果被除数是 0 ，除数不是 0\n返回0\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n指数操作数\nES7新增了指数操作符“**”等价于Math.pow()\n指数操作符也有指数赋值操作符**=\n\n加性操作符加法操作符\n如果两个操作数都是数值，应用如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity 加 Infinity\n返回 Infinity\n\n\n如果是 -Infinity 加 -Infinity\n返回 -Infinity\n\n\n如果是 Infinity 加 -Infinity\n返回 NaN\n\n\n如果是 +0 加 +0\n返回 +0\n\n\n如果是 -0 加 +0\n返回 +0\n\n\n如果是 -0 加 -0\n返回 -0\n\n\n\n如果有一操作数是字符串，应用如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n如果两个操作数都是字符串\n第二个字符串拼接到第一个字符串后面\n\n\n如果只有一个操作数是字符串\n将另一个操作数转为字符串，然后再将两个字符串拼接在一起\n\n\n\n如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。\n对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。\n\n减法操作符\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity 减 Infinity\n返回 NaN\n\n\n如果是 -Infinity 减 -Infinity\n返回 NaN\n\n\n如果是 Infinity 减 -Infinity\n返回 Infinity\n\n\n如果是 -Infinity 减 Infinity\n返回 -Infinity\n\n\n如果是 +0 加 +0\n返回 +0\n\n\n如果是 +0 加 -0\n返回 -0\n\n\n如果是 -0 加 -0\n返回 +0\n\n\n\n如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。\n如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。\n\n关系操作符\n关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）。\n\n\n\n\n操作数\n结果\n\n\n\n都是数值\n执行数值比较\n\n\n都是字符串\n比较字符串中对应字符的编码\n\n\n如果有任一操作数是数值\n将另一个操作数转换为数值，执行数值比较\n\n\n如果有任一操作数是对象\n调用其valueOf()方法，取得结果后再根据前面的规则执行比较;如果对象没有 valueOf()方法，则调用其 toString()方法,取得结果后再根据前面的规则执行比较\n\n\n如果有任一操作数是布尔值\n将其转换为数值再执行比较\n\n\n相等操作符等于和不等于\n等于操作符用两个等于号（==）表示\n不等于操作符用叹号和等于号（!=）表示\n这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。\n转换规则如下：\n\n\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是布尔值\n将其转换为数值再比较是否相等\n\n\n如果一个操作数是字符串，另一个操作数是数值\n࠼试将字符串转换为数值，再比较是否相等\n\n\n如果一个操作数是对象，另一个操作数不是\n调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较\n\n\n\n在进行比较时，这两个操作符会遵循以下规则：\nnull和underfined相等\nnull 和 undefined 不能转换为其他类型的值再进行比较\n如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true\n如果两个操作数都是对象，则比较它们是不是同一个对象\n\n\n\n全等和不全等\n全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回回 true\n\n条件操作符variable = boolean_expression ? true_value : false_value\n赋值操作符\n简单赋值用等于号（=）表示，将左手边的值赋给右手边的变量\n复合赋值：仅仅是简写语法，使用它们不会提升性能\n\n逗号操作符\n逗号操作符可以用来在一条语句中执行多个操作\n在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值let num = (5,1,4,8,0);console.log(num);//0\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（七）语句","url":"/2021/07/21/js-7/","content":"if语句\n语法格式：\nif(condition) statement1 else statement2if(condition1)&#123;    statement1&#125; else if(condition2)&#123;    statement2&#125; else&#123;    statement3&#125;\n\n\n\ndo-while语句\n后循环语句：循环体中的代码执行后才会对推出条件进行求值\n语法格式：\n\ndo&#123;    statement&#125;while (expression);\n\nwhile语句\n语法格式：\n\nwhile(expression)&#123;    statement&#125;\n\nfor语句\n语法格式：\n\nfor(initialization;expression;post-loop-expression)&#123;    statement&#125;\n\n\n无穷循环：\n\nfor(::)&#123;    statement&#125;\n\nfor-in语句\nfor-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性\n语法格式：\n\nfor(property in expression)&#123;    statement&#125;\n\n所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异\n如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体\n\nfor-of语句\nfor-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素\n语法格式：\n\nfor(property of expression)&#123;    statement&#125;\n\n\nfor-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素\n如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误\nES2018 对 for-of 语句进行了扩展，增加了 for-await-of 循环支持生成期约的异步可迭代对象。\n\n标签语句\n语法格式：label: statement//--------举例---------start: for(let i=0;i&lt;count;i++)&#123;    console.log(i);&#125;\n\nbreak和continue语句\nbreak 语句用于立即退出循环，强制执行循环后的下一条语句\ncontinue 语句也用于立即退出循环，但会再次从循环顶部开始执行\n\nwith语句\nwith 语句的用途是将代码作用域设置为特定的对象\n语法格式：with (expression) statement;//---------举例----------let a = location.search.sustring(1);let b = location.hostname;let c = location.href;//等价于with(location)&#123;    let a = search.sustring(1);    let b = hostname;    let c = href;&#125;\n\nswitch语句\n语法格式：switch(expression)&#123;    case value1:        statement        break;    case value2:        statement        break;    case value3:        statement        break;    default:        statement&#125;\nswitch 语句可以用于所有数据类型,因此可以使用字符串甚至对象\n条件的值不需要是常量，也可以是变量或表达式\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（八）原始值与引用值","url":"/2021/07/21/js-8/","content":"什么是原始值和引用值\n原始值（primitive value）就是最简单的数据\n原始值有六种：Undefined、Null、Boolean、Number、String 和 Symbol；\n保存原始值的变量是按值（by value）访问的，直接对存储在变量中的实际值进行操作\n\n\n引用值（reference value）则是由多个值构成的对象\n引用值是保存在内存中的对象\nJavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间\n保存引用值的变量是按引用（by reference）访问的\n在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身\n\n\n\n动态属性\n动态属性实际上就是在对象被创建后给这个对象添加新的属性，该属性可以被访问使用，直至对象被销毁或者属性被显示的删除。\n原始值是不能有属性的，只有引用值可以动态添加后面可以使用的属性\n原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。let str1 = &quot;message&quot;;let str2 = new String(&quot;Matt&quot;);str1.age = 18;str2.age = 20;console.log(typeof str1);//stringconsole.log(typeof str2);//onjectconsole.log(str1.age);//underfinedconsole.log(str2.age);//20\n\n复制值对于原始值\n在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。\n两个变量可以独立使用，互不干扰。let num1 = 5;let num2 = num1;\n\n\n对于引用值\n在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;Nicholas&quot;; console.log(obj2.name); // &quot;Nicholas&quot;\n\n\n传递参数\nECMAScript 中所有函数的参数都是按值传递的\nECMAScript 中函数的参数就是局部变量\n对象保存在全局作用域的堆内存上，当对象作为参数传递给函数并在函数内部实现了操作，那么该对象会被修改\n\nfunction addFive(num)&#123;    num += 5;    return num;&#125;let count = 5;let result = addFive(count);console.log(count);//5console.log(result);//10//----------------------------function setName(obj)&#123;    obj.name = &quot;Nicholas&quot;;&#125;let person = new Object();setName(person);console.log(person.name);//&quot;Nicholas&quot;\n\n确定类型\ntypeof 操作符最适合用来判断一个变量是否为原始类型，typeof 虽然对原始值很有用，但它对引用值的用处不大。\ninstanceof可用来判断具体类型\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（九）执行上下文和作用域","url":"/2021/07/21/js-9/","content":"\n每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上\n全局上下文是最外层的上下文；\n在浏览器中，全局上下文就是我们常说的 window 对象；\n上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数；\n当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文ಖ会弹出该函数上下文，将控制权返还给之前的执行上下文；\n上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain），其决定了各级上下文中的代码在访问变量和函数时的顺序；\n活动对象最初只有一个定义变量：arguments；\n全局上下文的变量对象始终是作用域链的最后一个变量对象；\n\n作用域链增强\ntry/catch语句中的catch块\ncatch 语句而言，则会创建一个新的变量对象\n\n\nwith语句\n语句会向作用域链前端添加指定的对象\n\n\n\n变量声明\nvar作用域声明\n\n使用var声明变量时，变量会被自动添加到最接近的上下文；\n如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文\nvar 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前\n通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是Reference Errorvar name = &quot;Lacus&quot;;//等价于name = &quot;Lacus&quot;;var name;//---------------------console.log(msg);//underfinedvar msg = &quot;boy&quot;;\n\n\nlet块级作用域\n\n块级作用域由最近的一对包含花括号{}界定；\nif 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域；\nlet 在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError；\nlet 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部\nlet 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。for(var i=0;i&lt;10;i++)&#123;&#125;console.log(i);//10for(let j=0;i&lt;10;j++)&#123;&#125;console.log(j);//ReferenceError: j没有定义\n\n\nconst常量声明\n\nconst 声明的变量必须同时初始化为౼个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值\nconst 声明只应用到顶级原语或者对象\n\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十）垃圾回收","url":"/2021/07/21/js-10/","content":"\nJavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存；\n通过自动内存管理实现内存分配和闲置资源回收；\n基本思路：确定哪个变量不会再使用，然后释放它占用的内存\n这个过程是周期性的，即垃圾回收程序每隔一定时间，就会自动运行\n\n\n两种主要的标记策略：标记清理和引用计数\n\n标记清理定义当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记；当变量离开上下文时，也会被加上离开上下文的标记。\n标记方式\n当变量进入上下文时，反转某一位\n维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表\n\n引用计数设计思路\n对每个值都记录它被引用的次数；\n声明变量并给它赋一个引用值时，这个值的引用数为 1；\n如果同一个值又被赋给另一个变量，那么引用数加 1；\n如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1；\n当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。\n\n性能\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要；\n无论什么时候开始收集垃圾，都能让它尽快结束工作；\n现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行；\n在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收\n在Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序\n\n内存管理\n将内存占用量保持在一个较小的值可以让页面性能更好；\n优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据；\n解除引用：如果数据不再必要，那么把它设置为 null，从而释放其引用；\n\n通过const和let声明提升性能let和const是块级作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存\n隐藏类和删除操作内存泄漏静态分配与对象池","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Undefined、Null、Boolean）","url":"/2021/07/21/js-5-1/","content":"Undefined类型\n只含有underfined一个值\n\n变量定义但未初始化时自动赋予underfined\n\n变量定义但未初始化和未定义是不同的\nlet message;console.log(message);//underfinedconsole.log(mix)//Error\nunderfined常用于比较来确定变量是否初始化/赋值了\nlet message = underfined;console.log(message == underfined);//true\n变量无论是声明还是未声明，typeof 返回的都是字符串”undefined”\n\nundefined 是一个假值\nlet message;if(message)&#123;    console.log(&quot;变量初始化了！&quot;)&#125;else&#123;    console.log(&quot;变量未初始化！&quot;)&#125;//变量未初始化\n\nNull类型\n只有一个值：null，表示一个空对象指针\nundefined是由null派生而来的，表面上相等\nnull是一个假值\n当变量要保存对象但没有对象来保存可以用null填充\n\nBoolean类型\n有两个字面值：true和false\n布尔值不同于数值，即：true!=1,false!=0\n其它类型的值可以转化为布尔类型\n\n\n\n\n数据类型\n转为true\n转为false\n\n\n\nBoolean\ntrue\nfalse\n\n\nString\n非空字符串\n空字符串\n\n\nNumber\n非零数值（包括无穷）\n0，NaN\n\n\nObject\n任意对象\nnull\n\n\nUnderfined\nN/A（不存在）\nunderfined\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（String）","url":"/2021/07/21/js-5-3/","content":"概述定义零或多个16位Unicode字符序列。\n创建方式\n单引号、双引号、反引号标示。\n以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。\n\nlet message = &#x27;Hello World&#x27;let message1 = &quot;Hello World&quot;let message2 = `Hello World`\n\n字符字面量\n用于标识非打印字符或有其他用途的字符。\n转义序列表示一个字符，在计算字符串长度时算一个字符。\n如下表：\n\n\n\n\n字面量\n含义\n\n\n\n\\n\n换行\n\n\n\\t\n制表\n\n\n\\b\n退格\n\n\n\\r\n回车\n\n\n\\f\n换页\n\n\n\\\\\n反斜杠\n\n\n\\&#39;\n单引号\n\n\n\\&quot;\n双引号\n\n\n字符串特点\n不可变：一旦创建就不能发生变化\n如果要修改每个变量中的字符串的值，必须先销毁原始的字符串然后重新赋值\n\n转换字符串\n方法：toString()\nnull和undefined没有toString()方法，直接返回两个值的字面量文本\n数值调用toString方法可以接受一个参数，表示进制。let num = 10console.log(num.toString(2))//&quot;1010&quot;console.log(num.toString(8))//&quot;12&quot;\n\n模板字面量（ES6）\n模板字面量保留换行字符，可以跨行定义字符串let message1 = &#x27;one\\ntwo&#x27;;let message2 = `onetwo`;console.log(message1);//one//twoconsole.log(message2);//one//twoconsole.log(message1==message2);//true\n\n字符串插值\n表达式：${变量}\n模板字面量不是字符串，是一种特殊的JS语句表达式\n\nlet value = 5;let message = `$&#123;value&#125;+$&#123;value&#125;=$&#123;value*value&#125;`;console.log(message);//5+5=10\n\n\n所有插入的值都会使用toString()强制转为字符串\n\n模板字面量标签函数\n标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果\n\nlet a = 5;let b = 10;function simple(str,aVal,bVal,sum)&#123;    console.log(str);    console.log(aVal);    console.log(bVal);    console.log(sum);    return &#x27;finish&#x27;;&#125;//可使用剩余操作符收入到一个数组中function Tag(str,...exper)&#123;    console.log(str);    for(const expression of exper)&#123;        console.log(experssion)    &#125;&#125;let message = `$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;let result = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]//5//10//15let result1 = Tag`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]//5//10//15console.log(result)//&#x27;finish&#x27;\n\n原始字符串\nString.raw标签函数可用于获取原始字符串\n键盘输入的回车等不能获取到原始字符\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Number）","url":"/2021/07/21/js-5-2/","content":"Number类型概述\nNumber 类型使用 IEEE 754 格式表示整数和浮点值\n\n不同数值类型有不同的数值字面量格式\n\n八进制字面量：\n/*1、第一个数字必须是0，然后对应八进制数字2、字面量中数字超出范围就会忽略第一个0，然后当作十进制处理*/let num1 = 070;//56let num2 = 079;//十进制79let num3 = 08;//十进制8\n十六进制字面量：\n/*1、前缀为0x且区分大小写2、字母大小写均可*/let num1 = 0xa;//10let num2 = 0x1F;//31\n\n浮点数基础知识\n定义：数值中必须包含小数点，并且小数点后面必须至少有一个数字let floatNum1 = 5.20;let floatNum2 = 13.14;let floatNum3 = .20;//不推荐使用\n存储浮点值使用的内存空间是整数值的两倍\n\n科学计数法\n用于表示一个应该乘以10的给定次幂的数值\n表示方式：let num1 = 3.125e7let num2 = 31250000console.log(num1 == num2)//true\nES会将小数点后至少包含6个零的浮点值转为科学计数法\n\n精确度\n精确度可达17为小数console.log(0.05+0.25 == 0.15+0.15)//trueconsole.log(0.1+0.2 == 0.3)//false\nIEEE 754标准：\n\n\n\n值的范围\n由于内存的限制，ES并不支持所有数值\n如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity\n无法表示的负数：-Infinity（负无穷大）\n无法表示的正数：Infinity（无穷大）\n当计算返回正/负无穷时不能再进一步用于任何计算。\nisFinite()函数可用于检测值是不是有限大\nNumber.NEGATIVE_INFINITY和Number,POSIYIVE_INFINITY可以获取正/负无穷let result1 = 3+5;console.log(inFinite(result1));//true------------------let result2 = Number.MAX_VALUE + Number.MAX_VALUEconsole.log(inFinite(result2));//false\n\nNaN\n表示不是数值\nES中，0，+0，-0相除会返回NaN：console.log(0/0);//NaNconsole.log(-0/+0);//NaN\n分母是有符号或无符号0，返回正/负无穷：console.log(512/0);//Infinityconsole.log(512/-0);//-Infinity\nNaN不等于包括NaN在内的任何值console.log(NaN == NaN)//false\nisNaN()用于检测是否为NaN\n可接受任意数据类型\n任何不能转换为数值的值都会使得函数返回true\n\n\n\n\n   \n      数据类型\n      内容\n      结果\n   \n   \n      字符串\n      可以转换为数值\n      false\n   \n   \n      \n      不可以转换为数值\n      true\n   \n   \n      布尔值\n      true\n      false\n   \n   \n      \n      false\n      true\n   \n   \n      数值\n      数字\n      false\n   \n   \n      \n      NaN\n      true\n   \n   \n      \n   \n\n\n数值转换\n\n\n转换函数\nNumber()\nparseInt()\nparseFloat()\n\n\n\n布尔值\ntrue → 1false → 0\nNaN\nNaN\n\n\n数值\n直接返回\n返回对应整数\n返回对应数值\n\n\nnull\n返回0\nNaN\nNaN\n\n\nunderfined\n返回NaN\nNaN\nNaN\n\n\n字符串\n①包含有（无）符号数字字符串→对应十进制数值②包含有效浮点值→对应浮点数③包含十六进制格式→对应十进制④空字符串→返回0⑤除此之外→返回NaN\n①字符串最前面的空格会被忽略，从第一个非空格字符开始转换②如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN③如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符\n①从位置 0 开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止② 始终忽略字符串开头的零③只解析十进制值④ 如果字符串表示整数（没有小数点或者小数点后面只有一个零），则返回整数\n\n\n对象\n调用valueOf()方法，并按上述规则返回值；如果转换结果为NaN，则调用toString()方法，再按照字符串规则转换\nNaN\nNaN\n\n\n\nparseInt(str,base)有两个参数：\nstr：接受一个带转化的字符串\nbase：为一个数值，表示进制\n\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Symbol）","url":"/2021/07/21/js-5-4/","content":"基本用法\nSymbol为原始类型，可以使用typeof操作符进行检测\n\nlet mes = Symbol();console.log(typeof mes)//Symbol\n\n\nSymbol(name)\nname作为对符号的描述\n与符号定义或标识完全无关\n\n\n\nlet sys1 = Symbol(&#x27;foo&#x27;);let sys2 = Symbol(&#x27;foo&#x27;);console.log(sys1 == sys2);//false\n\n\n符号没有字面量语法\n创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性\nSymbol()不能与new关键字一起作为构造函数使用\n为了避免创建符号包装对象\n\n\n可以使用Object()函数创建符号包装对象let str = new String();console.log(typeof str);//objectlet sys = new Symbol();// TypeError: Symbol is not a constructorlet mySymbol = Symbol();let objsys = Object(mySymbol);console.log(typeof objsys);//object\n\n全局符号注册表\nSymbol.for()\n第一次使用౼个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。\n即使使用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同\n全局注册表中的符号必须使用字符串键来创建\n作为参数传给 Symbol.for()的任何值都会被转换为字符串\n注册表中使用的键同时也会被用作符号描述\n\n\n\nlet sys1 = Symbol.for(&#x27;foo&#x27;);let sys2 = Symbol.for(&#x27;foo&#x27;);let sys3 = Symbol(&#x27;foo&#x27;);let sys4 = Symbol.for();console.log(sys1 == sys2);//trueconsole.log(sys1 == sys3);//falseconsole.log(sys4);//Symbol(underfined)\n\n\nSymbol.keyFor() 来查询全局注册表\n如果查询的不是全局符号，则返回 undefined\n如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError\n\nlet sys1 = Symbol.for(&#x27;foo&#x27;);let sys3 = Symbol(&#x27;foo&#x27;);console.log(Symbol.keyFor(sys1));//fooconsole.log(Symbol.keyFor(sys3));//underfinedSymbol.for(123);//TypeError:123 is not a symbol\n\n符号作为属性\n凡是可以使用字符串或数值作为属性的地方，都可以使用符号\nObject.defineProperty(obj,prop,descriptor)\nobj：被操作的对象\nprop：目标对象需要定义或修改的属性的名称\ndescriptor：将被定义或修改的属性描述符\n\n\n\nlet s1 = Symbol(&#x27;foo&#x27;);    s2 = Symbol(&#x27;bar&#x27;);    s3 = Symbol(&#x27;baz&#x27;);    s4 = Symbol(&#x27;qux&#x27;);let o = &#123;    [s1]:&#x27;foo value&#x27;&#125;;console.log(o);//&#123;Symbol(foo):foo value&#125;Object.defineProperty(o,s2,&#123;value:&#x27;bar value&#x27;&#125;);console.log(o);//&#123;Symbol(foo):foo value,Symbol(bar):bar value&#125;Object.defineProperties(o,&#123;    [s3]:&#123;value:&#x27;baz value&#x27;&#125;,    [s4]:&#123;value:&#x27;qux value&#x27;&#125;&#125;);console.log(o);//&#123;Symbol(foo):foo value,Symbol(bar): bar value,//Symbol(baz):baz value,Symbol(qux):qux value&#125;\n\n属性Symbol.asyncIterator()\n一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用\n这个符号表示实现异步迭代器 API 的函数。\nfor-await-of 循环会利用这个函数执行异步迭代操作。\n循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。\n个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例\n\nclass Emitter&#123;    constructor(max)&#123;        this.max = max;        this.asyncIdx = 0;    &#125;    async *[Symbol.asyncIterator]()&#123;        while(this.asyncIdx &lt; this.max)&#123;            yield new Promise((resolve)=&gt;resolve(this.asyncIdex++))        &#125;    &#125;&#125;async function asyncCount()&#123;    let emitter = new Emitter(5);    for await(const x of emitter)&#123;        console.log(x);    &#125;&#125;asyncCount();//0//1//2//3//4\n\nSymbol.hasInstance\n一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用\n在 ES6 中，instanceof 操作符会使用Symbol.hasInstance 函数来确定关系\n这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用\ninstanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数。\n\nfunction Foo()&#123;&#125;let f = new Foo();console.log(f instanceof Foo);//trueconsole.log(Foo[Symbol.hasInstance](f));//trueclass Bar&#123;&#125;class Baz extends Bar&#123;    static [Symbol.hasInstance]()&#123;        return false;    &#125;&#125;let b = new Baz();console.log(Bar[Symbol.hasInstance](b));//trueconsole.log(b instanceof Bar);//trueconsole.log(Baz[Symbol.hasInstance][b]);//falseconsole.log(b instanceof Baz);//false\n\nSymbol.isConcatSpreadable\n一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素\nES6 中的 Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例\n数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾\n类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。\n其他不是类数组对象的对象在 Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。\n类数组对象是指：property（属性名）为正整数的对象let arr1 = [&#x27;foo&#x27;];let arr2 = [&#x27;bar&#x27;];console.log(arr1.concat(arr2));//[&#x27;foo&#x27;,&#x27;bar&#x27;]arr2[Symbol.isConcatSpreadable] = false;console.log(arr1.concat(arr2));//[&#x27;foo&#x27;,[&#x27;bar&#x27;]]let obj = &#123;length:1,0:&#x27;baz&#x27;&#125;;console.log(arr1.concat(obj));//[&#x27;foo&#x27;,&#123;length:1,0:&#x27;baz&#x27;&#125;]obj[Symbol.isConcatSpreadable] = true;console.log(arr1.concat(obj));//[&#x27;foo&#x27;,&#x27;baz&#x27;]let set = new Set().add(&#x27;qux&#x27;);console.log(arr1.concat(set));//[&#x27;foo&#x27;,Set(1)]\n\nSymbol.iterator\n一个方法，该方法ᤄ回对象默认的迭代器。由 for-of 语句使用\nfor-of 循环这样的语言结构会利用这个函数执行迭代操作。\n\nclass Emitter&#123;    constructor(max)&#123;        this.max = max;        this.asyncIdx = 0;    &#125;    *[Symbol.interctor]()&#123;        while(this.asyncIdx &lt; this.max)&#123;            yield this.idx++;        &#125;    &#125;&#125;function Count()&#123;    let emitter = new Emitter(5);    for await(const x of emitter)&#123;        console.log(x);    &#125;&#125;Count();//0//1//2//3//4\n\nSymbol.match\n一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\nString.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。\n\nclass FooMatcher&#123;    static [Symbol.match](target)&#123;        return target.includes(&#x27;foo&#x27;);    &#125;&#125;console.log(&#x27;foobar&#x27;.match(FooMatcher));//trueconsole.log(&#x27;barbaz&#x27;.match(Foomatcher));//falseclass StringMatcher&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.match](target)&#123;        return target.includes(this.str);    &#125;&#125;console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;foo&#x27;)));//trueconsole.log(&#x27;barbaz&#x27;.match(new StringMatcher(&#x27;quz&#x27;)));//false\n\nSymbol.replace\n一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用\nString.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\n\nclass Replace&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.replace](target,replacment)&#123;        return target.split(this.str).join(replacement);    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.replace(new Replace(&#x27;foo&#x27;),&#x27;qux&#x27;));\n\nSymbol.search\n一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用\nString.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\n\nclass Search &#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.search](target)&#123;        return target.indexOf(this.str);    &#125;&#125;console.log(&#x27;foobar&#x27;.search(new Search(&#x27;foo&#x27;)));//0console,log(&#x27;barfoo&#x27;.search(new Search(&#x27;foo&#x27;)));//3console.log(&#x27;barbaz&#x27;.search(new Search(&#x27;qux&#x27;))); // -1\n\nSymbol.species\n一个函数值，该函数作为创建派生对象的构造函数\n用于对内置类型实例方法的返回值暴露实例化派生对象的方法\n用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义\n\nclass Bar extends Array&#123;&#125;class Baz extends Array&#123;    static get [Symbol.species]()&#123;        return  Array;    &#125;&#125;let bar = new Bar();console.log(bar instanceof Array);//trueconsole.log(bar instanceof Bar);//truebar = bar.concat(&#x27;bar&#x27;);console.log(bar instanceof Array);//trueconsole.log(bar instanceof Bar);//truelet baz = new Baz();console.log(baz instanceof Array);//trueconsole.log(baz instanceof Baz);//truebar = bar.concat(&#x27;baz&#x27;);console.log(baz instanceof Array);//trueconsole.log(baz instanceof Baz);//false\n\nSymbol.split\n一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用\nString.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值\n\nclass Spilter&#123;    static [Symbol.split](target)&#123;        return target.split(&#x27;foo&#x27;);    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(Spliter));//[&#x27;bar&#x27;,&#x27;baz&#x27;]class Split&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.split](target)&#123;        return target.split(this.str)    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(new Split(&#x27;foo&#x27;)));//[&#x27;bar&#x27;,&#x27;baz&#x27;]\n\nSymbol.toPrimitive\n一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用\n对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为\n\nclass Foo&#123;&#125;let foo = new Foo();console.log(3+foo);//&quot;3[object Object]&quot;console.log(3-foo);//&quot;NaN&quot;console.log(String(foo));//&quot;[object Object]&quot;class Bar&#123;    constructor()&#123;        this[Symbol.toPrimitive] = function(hint)&#123;            switch (hint)&#123;                case &#x27;number&#x27;:                    return 3;                case &#x27;string&#x27;:                    return &#x27;string bar&#x27;;                case &#x27;default&#x27;:                default:                    return &#x27;default bar&#x27;;             &#125;        &#125;    &#125;&#125;let bar = new Bar();console.log(3+bar);//&quot;3default bar&quot;console.log(3-bar);//0console.log(String(bar));//&quot;&quot;string bar&quot;\n\nSymbol.toStringTag\n一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用\n通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”\n\nlet s = new Set();console.log(s);//Set(0)&#123;&#125;console.log(s.toString());//[object Object]console.log(s[Symbol.toStringTag]);//Setclass Foo&#123;&#125;let foo = new Foo();console.log(foo);//Foo&#123;&#125;console.log(foo.toString());//[object Object]console.log(foo[Symbol.toStringTag]);//underfinedclass Bar&#123;    constructor()&#123;        this[Symbol.toStringTag] = &#x27;Bar&#x27;;    &#125;&#125;let bar = new Bar();console.log(bar);//Bar()console.log(bar.toString());//[object Bar]console.log(bar[Symbol.toStringTag]);//Bar\n\nSymbol.unscopables\n一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除\n不推荐使用 with，因此也不推荐使用 Symbol.unscopables\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Object）","url":"/2021/07/21/js-5-5/","content":"定义\nES中对象是一组数据和功能的集合\n对象被认为是౼个特定引用类型的实例\n\n创建和使用\n对象通过new操作符跟对象类型的名称来创建\n如果没有参数，可以省略括号\n\n属性和方法\n\n\n属性和方法\n作用\n\n\n\nconstructor\n用于创建当前对象的函数\n\n\nhasOwnProperty(propertyName)\n用于判断当前对象上是否存在给定属性\n\n\nisPrototypeOf(Object)\n用于判断当前对象是否是另一个对象的原型\n\n\npropertyIsEnumerable(propertyName)\n用于判断给定的属性是否可以使用for-in语句枚举\n\n\ntoLocaleString()\n返回对象的字符串表示，该字符串反映对象所在的本地化执行环境\n\n\ntoString()\n返回对象的字符串表示\n\n\nvalueOf()\n返回对象对应的字符串、数值或布尔值表示，通常与toString()返回值相同\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十一）Date","url":"/2021/08/13/js-11/","content":"基本内容\nECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。\nDate 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。\n使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。\n\n\n\n创建\n要创建日期对象，就使用 new 操作符来调用 Date 构造函数\n在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间;\n\nlet now = new Date();\n\n\n要基于其他日期和时间创建日期对象，必须传入其毫秒表示。\nECMAScript为此提供了两个辅助方法：Date.parse()和Date.UTC()\nDate.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。规则如下：\n\n\n\n\n格式\n结果\n\n\n\n月/日/年\n5/23/2021\n\n\n月名 日,年\nMay 23,2021\n\n\n周几 月名 日 年 时:分:秒 时区\nSun May 23 2021 00:00:00 GMT-0700\n\n\nYYYY-MM-DDTHH:mm:ss.sssZ\n2021-05-23T00:00:00\n\n\n\n如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN；\n如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。\nDate.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（131）、时（023）、分、秒和毫秒这些参数中，只有前两个（年和月）是必需的；\n如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。\nECMAScript 还提供了 Date.now()方法，ᤄ回表示方法执行时日期和时间的毫秒数。\n\n继承的方法\nDate 类型重写了 toLocaleString()、toString()和 valueOf()方法；\nDate 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间，这通常意։着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息；\ntoString()方法通常返回ࣛ时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的；\nDate 类型的 valueOf()方法಩本就不返回字符串，这个方法被重写后ᤄ回的是日期的毫秒表示。\n\n日期格式化方法\n\n\n方法\n结果\n\n\n\ntoDateString()\n显示日期中的周几、月、日、年（格式特定于实现）\n\n\ntoTimeString()\n显示日期中的时、分、秒和时区（格式特定于实现）\n\n\ntoLocaleDateString()\n显示日期中的周几、月、日、年（格式特定于实现和地区）\n\n\ntoLocaleTimeString()\n显示日期中的时、分、秒（格式特定于实现和地区）\n\n\ntoUTCString()\n显示完整的 UTC 日期（格式特定于实现）\n\n\n日期/时间组件方法\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十二）RegExp","url":"/2021/08/13/js-12/","content":"基础知识创建语法\n正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用；\n每个正则表达式可以ࣛ带零个或多个 flags（标记），用于控制正则表达式的行为。\n\nlet expression = /pattern/flages;\n\n\n\n\nflags\n作用\n\n\n\ng\n全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的f内容就结束\n\n\ni\n不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写\n\n\nm\n多行模式，表示查找到一行文本末尾时会继续查找\n\n\ny\n粘附模式，表示只查找从 lastIndex 开始及之后的字符串\n\n\nu\nUnicode 模式，启用 Unicode 匹配\n\n\ns\ndotAll 模式，表示元字符.匹配任何字符（包括\\n 或\\r）\n\n\n\n元字符包括：( [ { \\ ^ $ | ) ] } ? * + .\n所有元字符在模式中也必须转义\n\n// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写let pattern1 = /[bc]at/i;// 匹配第一个&quot;[bc]at&quot;，忽略大小写let pattern2 = /\\[bc\\]at/i; // 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写let pattern3 = /.at/gi; // 匹配所有&quot;.at&quot;，忽略大小写let pattern4 = /\\.at/gi;\n\nRegExp 实ׁኔᙝ\nglobal：布尔值，表示是否设置了 g 标记。\nignoreCase：布尔值，表示是否设置了 i 标记。\nunicode：布尔值，表示是否设置了 u 标记。\nsticky：布尔值，表示是否设置了 y 标记。\nlastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。\nmultiline：布尔值，表示是否设置了 m 标记。\ndotAll：布尔值，表示是否设置了 s 标记。\nsource：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。\nflags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）\n\nlet pattern1 = /\\[bc\\]at/i; console.log(pattern1.global); // false console.log(pattern1.ignoreCase); // true console.log(pattern1.multiline); // false console.log(pattern1.lastIndex); // 0 console.log(pattern1.source); // &quot;\\[bc\\]at&quot; console.log(pattern1.flags); // &quot;i&quot;\n\nRegExp 实例方法\nRegExp 实例的主要方法是 exec()，主要用于配合捕获组使用；\n这个方法只接收一个参数，即要应用模式的字符串\n如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null\n返回的数组包含两个额外的属性：index 和 input，index 是字符串中匹配模式的起始位置，input 是要查找的字符串\n\n\n如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息\n\nlet text = &quot;mom and dad and baby&quot;; let pattern = /mom( and dad( and baby)?)?/gi; let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches.input); // &quot;mom and dad and baby&quot; console.log(matches[0]); // &quot;mom and dad and baby&quot; console.log(matches[1]); // &quot; and dad and baby&quot; console.log(matches[2]); // &quot; and baby&quot;\n\nRegExp 构造函数属性\n这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化；\n\n\n\nlet text = &quot;this has been a short summer&quot;; let pattern = /(.)hort/g; if (pattern.test(text)) &#123;     console.log(RegExp.input); // this has been a short summer     console.log(RegExp.leftContext); // this has been a     console.log(RegExp.rightContext); // summer     console.log(RegExp.lastMatch); // short     console.log(RegExp.lastParen); // s &#125;//==============等价于==============let text = &quot;this has been a short summer&quot;; let pattern = /(.)hort/g; /*  * 注意：Opera 不支持简写属性名 * IE 不支持多行匹配 */ if (pattern.test(text)) &#123;     console.log(RegExp.$_); // this has been a short summer     console.log(RegExp[&quot;$`&quot;]); // this has been a     console.log(RegExp[&quot;$&#x27;&quot;]); // summer     console.log(RegExp[&quot;$&amp;&quot;]); // short     console.log(RegExp[&quot;$+&quot;]); // s &#125;\n\n以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下：\ninput 属性中包含原始的字符串。\nleftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。\nlastMatch 属性包含ӛ配整个正则表达式的上一个字符串，即”short”。 \nlastParen 属性包含捕获组的上一次匹配，即”s”。\n\n局限模式下列特性目前还没有得到 ECMAScript 的支持：\n\n\\A 和\\Z 错（分别匹配字符串的开始和末尾）\n联合及交叉类\n原子组\nx（忽略空格）匹配模式\n条件式匹配\n正则表达式注释\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十五）集合引用类型","url":"/2021/08/13/js-15/","content":"Object\nObject 的实例没有多少功能，但很适合存储和在应用程序间交换数据；\n创建 Object 的实例有两种方式：\n使用 new 操作符和 Object 构造函数；\n使用对象字面量（object literal）表示法；\n\n\n在对象字面量表示法中，属性名可以是字符串或数值，但数值属性会自动转换为字符串；\n在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。\n\n//第一种let person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29;//第二种let person = &#123;     name: &quot;Nicholas&quot;,     age: 29 &#125;;\n\n\n虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。\n在使用中括号时，要在括号内使用属性名的字符串形式；\n使用中括号的主要优势就是可以通过变量访问属性；\n点语法是首选的属性存取方式，除非访问属性时必须使用变量；\n\nArrayMapWeakMapSet","categories":["前端学习笔记","JS","Object"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十四）单例内置对象","url":"/2021/08/13/js-14/","content":"\n定义：任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象\n这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了；\n\nGlobalGlobal对象\n\nMathMath对象","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十三）原始值包装类型","url":"/2021/08/13/js-13/","content":"\n为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。\n每当用到౼个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。\n\nlet s1 = &quot;some text&quot;; let s2 = s1.substring(2);//========以上代码实际运行步骤===========let s1 = new String(&quot;some text&quot;); let s2 = s1.substring(2); s1 = null;\n\n\n引用类型与原始值包装类型的主要区别在于对象的生命周期；\n不能在运行时给原始值添加属性和方法；\n\nBoolean\nBoolean 是对应布尔值的引用类型；\n要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false；\nBoolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false；\ntoString()方法被调用时也会被覆盖，返回字符串”true”或”false”；\n所有对象在布尔表达式中都会自动转换为 true；\nBoolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 falselet falseObject = new Boolean(false); let result = falseObject &amp;&amp; true; console.log(result); // true let falseValue = false; result = falseValue &amp;&amp; true; console.log(result); // falseconsole.log(typeof falseObject); // object console.log(typeof falseValue); // boolean console.log(falseObject instanceof Boolean); // true console.log(falseValue instanceof Boolean); // false\n\nNumber\n创建Number对象就使用 Number 构造函数并传入一个数值\n\nlet numberObject = new Number(10);\n\n\n不建议直接实例化 Number 对象，因为在处理原始数值和引用数值时，typeof 和 instacnceof 操作符会返回不同的结果\n\nlet numberObject = new Number(10); let numberValue = 10; console.log(typeof numberObject); // &quot;object&quot; console.log(typeof numberValue); // &quot;number&quot; console.log(numberObject instanceof Number); // true console.log(numberValue instanceof Number); // false\n\n基础方法\nNumber 类型重写了 valueOf()、toLocaleString()和 toString()方法\nvalueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串\ntoString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串；\n\nlet num = 10; console.log(num.toString()); // &quot;10&quot; console.log(num.toString(2)); // &quot;1010&quot; console.log(num.toString(8)); // &quot;12&quot; console.log(num.toString(10)); // &quot;10&quot; console.log(num.toString(16)); // &quot;a&quot;\n\ntoFixed()\ntoFixed()方法返回包含指定小数点位数的数值字符串；如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的\ntoFixed()方法可以表示有 0~20 个小数位的数值\n\nlet num = 10.005; console.log(num.toFixed(2)); // &quot;10.01&quot;\n\ntoExponential()\n返回以科学记数法（也称为指数记数法）表示的数值字符串\n接收一个参数，表示结果中小数的位数\n\nlet num = 10; console.log(num.toExponential(1)); // &quot;1.0e+1&quot;\n\ntoPrecision()\n会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式\n接收一个参数，表示结果中数字的总位数（不包含指数）\n本质上，toPrecision()方法会根据数值和精度来决定调用 toFixed()还是 toExponential()\n为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入\n\nlet num = 99; console.log(num.toPrecision(1)); // &quot;1e+2&quot; console.log(num.toPrecision(2)); // &quot;99&quot; console.log(num.toPrecision(3)); // &quot;99.0&quot;\n\nString\nString 是对应字符串的引用类型；\n要创建一个 String 对象，使用 String 构造函数并传入一个数值\nString 对象的方法可以在所有字符串原始值上调用\n3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值；\n每个 String 对象都有一个 .length 属性，表示字符串中字符的数量；\n即使字符串中包含双字节字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数\n\nlet stringObject = new String(&quot;hello world&quot;);let stringValue = &quot;hello world&quot;; console.log(stringValue.length); // &quot;11&quot;\n\n字符串操作方法","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript字符串操作方法","url":"/2021/09/13/js-13-1/","content":"字符串拼接方法\nconcat()用于将一个或多个字符串拼接成一个新字符串\n\nlet stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;); console.log(result); // &quot;hello world&quot; console.log(stringValue); // &quot;hello&quot;\n\n可以接收任意多个参数，因此可以一次性拼接多个字符串；\n\nlet stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;, &quot;!&quot;); console.log(result); // &quot;hello world!&quot; console.log(stringValue); // &quot;hello&quot;\n\n从字符串中提取子字符串的方法\nslice()、substr()和 substring()；\n这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数；\n不会修改调用它们的字符串，而只会返回提取到的原始新字符串值；\n\n\n\n\n方法\n参数一\n参数二\n\n\n\nslice()\n子字符串开始的位置\n提取结束的位置\n\n\nsubstr()\n子字符串开始的位置\n返回的子字符串数量\n\n\nsubstring()\n子字符串开始的位置\n提取结束的位置\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.slice(3)); // &quot;lo world&quot; console.log(stringValue.substring(3)); // &quot;lo world&quot; console.log(stringValue.substr(3)); // &quot;lo world&quot; console.log(stringValue.slice(3, 7)); // &quot;lo w&quot; console.log(stringValue.substring(3,7)); // &quot;lo w&quot; console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot;\n\n\n当某个参数是负值时：\nslice()方法将所有负值参数都当成字符串长度加上负参数值；\nsubstr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0；\nsubstring()方法会将所有负参数值都转换为 0;\n\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.slice(-3)); // &quot;rld&quot; console.log(stringValue.substring(-3)); // &quot;hello world&quot; console.log(stringValue.substr(-3)); // &quot;rld&quot; console.log(stringValue.slice(3, -4)); // &quot;lo w&quot; console.log(stringValue.substring(3, -4)); // &quot;hel&quot; console.log(stringValue.substr(3, -4)); // &quot;&quot; (empty string)\n\n字符串位置方法\n有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()\n\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;)); // 4 console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7\n\n\n这两个方法都可以接收可选的第二个参数，表示开始搜索的位置；\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7 console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4\n\n字符串包含方法\nstartsWith()、endsWith()和 includes()用于判断字符串中是否包含另一个字符串的方法\nstartsWith()检查开始于索引 0 的匹配项\nendsWith()检查开始于索引(string.length - substring.length)的匹配项\nincludes()检查整个字符串\n\nlet message = &quot;foobarbaz&quot;; console.log(message.startsWith(&quot;foo&quot;)); // true console.log(message.startsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;baz&quot;)); // true console.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.includes(&quot;bar&quot;)); // true console.log(message.includes(&quot;qux&quot;)); // false\n\n\nstartsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置；\n如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符\nendsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样\n\nlet message = &quot;foobarbaz&quot;; console.log(message.startsWith(&quot;foo&quot;)); // true console.log(message.startsWith(&quot;foo&quot;, 1)); // false console.log(message.includes(&quot;bar&quot;)); // true console.log(message.includes(&quot;bar&quot;, 4)); // falseconsole.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;bar&quot;, 6)); // true\n\ntrim()方法\n这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果；\ntrimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符；\n\nlet stringValue = &quot; hello world &quot;; let trimmedStringValue = stringValue.trim(); console.log(stringValue); // &quot; hello world &quot; console.log(trimmedStringValue); // &quot;hello world&quot;\n\nrepeat() 方法\n这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果；\n\nlet stringValue = &quot;na &quot;; console.log(stringValue.repeat(16) + &quot;batman&quot;); // na na na na na na na na na na na na na na na na batman\n\npadStart() 和 padEnd() 方法\npadStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件；\n这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）；\n\nlet stringValue = &quot;foo&quot;; console.log(stringValue.padStart(6)); // &quot; foo&quot; console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;......foo&quot; console.log(stringValue.padEnd(6)); // &quot;foo &quot; console.log(stringValue.padEnd(9, &quot;.&quot;)); // &quot;foo......&quot;\n\n\n可选的第二个参数并不限于一个字符；\n如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度；\n如果长度小于或等于字符串长度，则会返回原始字符串；\n\nlet stringValue = &quot;foo&quot;; console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot; console.log(stringValue.padStart(2)); // &quot;foo&quot; console.log(stringValue.padEnd(8, &quot;bar&quot;)); // &quot;foobarba&quot; console.log(stringValue.padEnd(2)); // &quot;foo&quot;\n\n字符串迭代与解构\n字符串的原型上暴露了一个**@@iterator方法**，表示可以迭代字符串的每个字符；\n\nlet message = &quot;abc&quot;; let stringIterator = message[Symbol.iterator](); console.log(stringIterator.next()); // &#123;value: &quot;a&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;b&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;c&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: undefined, done: true&#125;\n\n\n在 for-of 循环中可以通过这个迭代器按序访问每个字符\n\nfor (const c of &quot;abcde&quot;) &#123;  console.log(c); &#125; // a // b // c // d // e\n\n字符串大小写转换\ntoLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()\ntoLowerCase()和toUpperCase()方法是原来就有的方法；\ntoLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现；\n\n字符串模式匹配方法\nmatch()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同；\nmatch()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象；\n\nlet text = &quot;cat, bat, sat, fat&quot;; let pattern = /.at/; // 等价于 pattern.exec(text) let matches = text.match(pattern); console.log(matches.index); // 0 console.log(matches[0]); // &quot;cat&quot; console.log(pattern.lastIndex); // 0\n\n\nsearch()方法：唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象；\n这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。\nsearch()始终从字符串开头向后匹配模式\n\nlet text = &quot;cat, bat, sat, fat&quot;; let pos = text.search(/at/); console.log(pos); // 1\n\n\nreplace()方法：接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数\n如果第一个参数是字符串，那么只会替换第一个子字符串。\n要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记\n\nlet text = &quot;cat, bat, sat, fat&quot;; let result = text.replace(&quot;at&quot;, &quot;ond&quot;); console.log(result); // &quot;cond, bat, sat, fat&quot; result = text.replace(/at/g, &quot;ond&quot;); console.log(result); // &quot;cond, bond, sond, fond&quot;\n\n\nreplace()的第二个参数可以是一个函数。\n在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串；\n在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串；\n这个函数应该返回一个字符串，表示应该把匹配项替换成什么；\n\nfunction htmlEscape(text) &#123;     return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) &#123;     switch(match) &#123;         case &quot;&lt;&quot;:             return &quot;&amp;lt;&quot;;         case &quot;&gt;&quot;:             return &quot;&amp;gt;&quot;;         case &quot;&amp;&quot;:             return &quot;&amp;amp;&quot;;         case &quot;\\&quot;&quot;:             return &quot;&amp;quot;&quot;;         &#125;     &#125;); &#125; console.log(htmlEscape(&quot;&lt;p class=\\&quot;greeting\\&quot;&gt;Hello world!&lt;/p&gt;&quot;)); // &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;\n\nlocaleCompare()方法\n这个方法比较两个字符串，返回如下 3 个值中的一个；\n如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）\n如果字符串与字符串参数相等，则返回 0。\n如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）\n\n\n\nlet stringValue = &quot;yellow&quot;; console.log(stringValue.localeCompare(&quot;brick&quot;)); // 1 console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0 console.log(stringValue.localeCompare(&quot;zoo&quot;)); // -1","categories":["前端学习笔记","JS","字符串"],"tags":["JS学习"]},{"title":"JavaScript——Global对象","url":"/2021/09/15/js-14-1/","content":"特点\n代码不会显式地访问它；\nGlobal对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法；\n在全局作用域中定义的变量和函数都会变成 Global 对象的属性；\n\n方法URL编码方式\n\nlet uri = &quot;http://www.wrox.com/illegal value.js#start&quot;; // &quot;http://www.wrox.com/illegal%20value.js#start&quot; console.log(encodeURI(uri)); // &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; console.log(encodeURIComponent(uri));\n\n\n\nlet uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;; // http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start console.log(decodeURI(uri)); // http:// www.wrox.com/illegal value.js#start console.log(decodeURIComponent(uri));\n\neval()方法\n它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串\n\neval(&quot;console.log(&#x27;hi&#x27;)&quot;); //======等价于======console.log(&quot;hi&quot;);\n\n当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置；\n通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链；\n\nlet msg = &quot;hello world&quot;; eval(&quot;console.log(msg)&quot;); // &quot;hello world&quot;\n\n\n可以在 eval()内部定义一个函数或变量，然后在外部代码中引用：\n\neval(&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;); sayHi();\n\n\n通过 eval()定义的任何变量和函数都不会被提升，它们只是在 eval()执行的时候才会被创建\n\neval(&quot;let msg = &#x27;hello world&#x27;;&quot;); console.log(msg); // Reference Error: msg is not defined\n\nGlobal对象属性\n像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性；\n所有原生引用类型构造函数，比如 Object 和 Function，也都是 Global 对象的属性；\n\n\n\nwindow对象\nECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理；\n\nvar color = &quot;red&quot;; function sayColor() &#123;     console.log(window.color); &#125; window.sayColor(); // &quot;red&quot;\n\n\n当一个函数在没有明确（通过成为౼个对象的方法，或者通过 call()/apply()）指定 this 值的情况下执行时，this 值等于Global 对象\n\nlet global = function() &#123;  return this; &#125;();\n","categories":["前端学习笔记","JS","Global对象"],"tags":["JS学习"]},{"title":"JavaScript——Math对象","url":"/2021/09/22/js-14-2/","content":"\nMath 对象上提供的计算要比直接在JavaScript实现的快得多，因为Math对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令\n\nMath对象属性\n\nmin() 和 max()方法\nmin()和 max()方法用于确定一组数值中的最小值和最大值；\n这两个方法都接收任意多个参数；\n\nlet max = Math.max(3, 54, 32, 16); console.log(max); // 54 let min = Math.min(3, 54, 32, 16); console.log(min); // 3\n\n\n要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：\n\nlet values = [1, 2, 3, 4, 5, 6, 7, 8]; let max = Math.max(...val);\n\n舍入方法\n\nconsole.log(Math.ceil(25.9)); // 26 console.log(Math.ceil(25.5)); // 26 console.log(Math.ceil(25.1)); // 26 console.log(Math.round(25.9)); // 26 console.log(Math.round(25.5)); // 26 console.log(Math.round(25.1)); // 25 console.log(Math.fround(0.4)); // 0.4000000059604645 console.log(Math.fround(0.5)); // 0.5 console.log(Math.fround(25.9)); // 25.899999618530273 console.log(Math.floor(25.9)); // 25 console.log(Math.floor(25.5)); // 25 console.log(Math.floor(25.1)); // 25\n\nrandom()方法\nMath.random()方法ᤄ回一个 0~1 范围内的随机数\n从一组整数中随机选择一个数：\n\nnumber = Math.floor(Math.random() * total_number_of_choices + first_possible_value)\n\n//从 1~10 范围内随机选择一个数let num = Math.floor(Math.random() * 10 + 1);//从 2~10 范围内随机选择一个数function selectFrom(lowerValue, upperValue) &#123;     let choices = upperValue - lowerValue + 1;     return Math.floor(Math.random() * choices + lowerValue); &#125; let num = selectFrom(2,10); console.log(num); // 2~10 范围内的值，其中包含 2 和 10\n\n\n如果是为了加密而需要生成随机数，建议使用 window.crypto.getRandomValues()\n\n其他方法","categories":["前端学习笔记","JS","Global对象"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Set","url":"/2021/10/18/js-15-4/","content":"基本API\n创建的同时初始化实例：\n\n// 使用数组初始化集合 const s1 = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s1.size); // 3 // 使用自定义迭代器初始化集合const s2 = new Set(&#123;     [Symbol.iterator]: function*() &#123;         yield &quot;val1&quot;;         yield &quot;val2&quot;;         yield &quot;val3&quot;;     &#125; &#125;); alert(s2.size); // 3\n\n\n初始化之后，可以使用：\nadd ()增加值；\nhas()查询；\nsize取得元素数量；\ndelete()删除元素；\n\n\n\nconst s = new Set(); alert(s.has(&quot;Matt&quot;)); // false alert(s.size); // 0 s.add(&quot;Matt&quot;)  .add(&quot;Frisbie&quot;); alert(s.has(&quot;Matt&quot;)); // true alert(s.size); // 2 s.delete(&quot;Matt&quot;); alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // true alert(s.size); // 1 s.clear(); // 销毁集合实例中的所有值alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // false alert(s.size); // 0 \n\n\nSet 可以包含任何 JavaScript 数据类型作为值：\n\nconst s = new Set(); const functionVal = function() &#123;&#125;; const symbolVal = Symbol(); const objectVal = new Object(); s.add(functionVal); s.add(symbolVal); s.add(objectVal); alert(s.has(functionVal)); // true alert(s.has(symbolVal)); // true alert(s.has(objectVal)); // true // SameValueZero 检查意味着独立的实例不会冲突alert(s.has(function() &#123;&#125;)); // false\n\n\n用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变:\n\nconst s = new Set(); const objVal = &#123;&#125;,     arrVal = []; s.add(objVal); s.add(arrVal); objVal.bar = &quot;bar&quot;; arrVal.push(&quot;bar&quot;); alert(s.has(objVal)); // true alert(s.has(arrVal)); // true\n\n\nadd()和delete ()操作是幂等的；\ndelete()返回一个布尔值，表示集合中是否存在要删除的值:\n\nconst s = new Set(); s.add(&#x27;foo&#x27;); alert(s.size); // 1 s.add(&#x27;foo&#x27;); alert(s.size); // 1 // 集合里有这个值alert(s.delete(&#x27;foo&#x27;)); // true // 集合里没有这个值alert(s.delete(&#x27;foo&#x27;)); // false\n\n顺序与迭代\n集合实例可以提供一个迭代器( Iterator ),能以插入顺序生成集合内容。\n可以通过values()方法及其别名方法keys() (或者Symbol. iterator属性，它引用values() )取得这个迭代器:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s.values === s[Symbol.iterator]); // true alert(s.keys === s[Symbol.iterator]); // true for (let value of s.values()) &#123;  alert(value); &#125; // val1 // val2 // val3 for (let value of s[Symbol.iterator]()) &#123;  alert(value); &#125; // val1 // val2 // val3\n\n\nvalues ()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); console.log([...s]); // [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;] \n\n\n集合的entries()方法返回一个迭代器，可以按照插人顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); for (let pair of s.entries()) &#123;  console.log(pair); &#125; // [&quot;val1&quot;, &quot;val1&quot;] // [&quot;val2&quot;, &quot;val2&quot;] // [&quot;val3&quot;, &quot;val3&quot;] \n\n\n如果不使用迭代器，而是使用回调方式，则可以调用集合的forEach() 方法并传人回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); s.forEach((val, dupVal) =&gt; alert(`$&#123;val&#125; -&gt; $&#123;dupVal&#125;`)); // val1 -&gt; val1 // val2 -&gt; val2 // val3 -&gt; val3","categories":["前端学习笔记","JS","ES6","Set"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Map","url":"/2021/10/08/js-15-2/","content":"基本API\n使用 new 关键字和 Map 构造函数可以创建一个空映射；\n如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组：\n初始化之后，可以使用 set()方法再添加键/值对；\n可以使用 get()和 has()进行查询；\n可以通过 size 属性获取映射中的键/值对的数量；\n可以使用 delete()和 clear()删除值；\n\n// 使用嵌套数组初始化映射const m1 = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m1.size); // 3 const m = new Map(); alert(m.has(&quot;firstName&quot;)); // false alert(m.get(&quot;firstName&quot;)); // undefined alert(m.size); // 0 m.set(&quot;firstName&quot;, &quot;Matt&quot;)  .set(&quot;lastName&quot;, &quot;Frisbie&quot;); alert(m.has(&quot;firstName&quot;)); // true alert(m.get(&quot;firstName&quot;)); // Matt alert(m.size); // 2 m.delete(&quot;firstName&quot;); // 只删除这一个键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // true alert(m.size); // 1 m.clear(); // 清除这个映射实例中的所有键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // false alert(m.size); // 0\n\n\nMap 可以使用任何 JavaScript 数据类型作为键；\n\nconst m = new Map(); const functionKey = function() &#123;&#125;; const symbolKey = Symbol(); const objectKey = new Object(); m.set(functionKey, &quot;functionValue&quot;); m.set(symbolKey, &quot;symbolValue&quot;); m.set(objectKey, &quot;objectValue&quot;); alert(m.get(functionKey)); // functionValue alert(m.get(symbolKey)); // symbolValue alert(m.get(objectKey)); // objectValue // SameValueZero 比较意味着独立实例不冲突alert(m.get(function() &#123;&#125;)); // undefined\n\n\n在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时依然保持不变；\n\nconst m = new Map(); const objKey = &#123;&#125;,     objVal = &#123;&#125;,     arrKey = [],     arrVal = []; m.set(objKey, objVal); m.set(arrKey, arrVal); objKey.foo = &quot;foo&quot;; objVal.bar = &quot;bar&quot;; arrKey.push(&quot;foo&quot;); arrVal.push(&quot;bar&quot;); console.log(m.get(objKey)); // &#123;bar: &quot;bar&quot;&#125; console.log(m.get(arrKey)); // [&quot;bar&quot;]\n\n顺序与迭代\nMap 实例会维护键值对的插入顺序；\n映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过**entries()**方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m.entries === m[Symbol.iterator]); // true\n\n\nentries()是默认迭代器，可以直接对映射实例使用扩展操作，把映射转换为数组；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]]\n\n\nforEach(callback,opt_thisArg)方法同样可以迭代每个键/值对，第一个参数传入一个回调方法；\n第二个参数用于重写回调函数内部的this值；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); m.forEach((val, key) =&gt; alert(`$&#123;key&#125; -&gt; $&#123;val&#125;`)); // key1 -&gt; val1 // key2 -&gt; val2 // key3 -&gt; val3 \n\n\nkeys()和 values()分别返回以插入顺序生成键和值的迭代器；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); for (let key of m.keys()) &#123;     alert(key); &#125; // key1 // key2 // key3 for (let key of m.values()) &#123;     alert(key); &#125; // value1 // value2 // value3 \n\n\n键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改；\n修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值；\n\nconst m1 = new Map([  [&quot;key1&quot;, &quot;val1&quot;] ]); for (let key of m1.keys()) &#123;     key = &quot;newKey&quot;;     alert(key); // newKey     alert(m1.get(&quot;key1&quot;)); // val1 &#125; const keyObj = &#123;id: 1&#125;; const m = new Map([     [keyObj, &quot;val1&quot;] ]); ","categories":["前端学习笔记","JS","Map"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——WeakMap","url":"/2021/10/17/js-15-3/","content":"\nWeakMap是Map 的“兄弟”类型,其API也是Map的子集。\nWeakMap中的”weak”(弱).描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。\n\n基本API\n可以使用 new 关键字实例化一个空的 WeakMap：\n\nconst wm = new WeakMap();\n\n\n弱映射中的键只能是 Object 或者继承自 Object的类型,尝试使用非对象设置键会抛出TypeError。\n值的类型没有限制。\n如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插人新实例中:\n\nconst key1 = &#123;id: 1&#125;,     key2 = &#123;id: 2&#125;,    key3 = &#123;id: 3&#125;;// 使用嵌套数组初始化弱映射const wm1 = new WeakMap([     [key1, &quot;val1&quot;],     [key2, &quot;val2&quot;],     [key3, &quot;val3&quot;] ]); alert(wm1.get(key1)); // val1 alert(wm1.get(key2)); // val2 alert(wm1.get(key3)); // val3 // 初始化是全有或全无的操作// 只要有一个键无效就会抛出错误，导致整个初始化失败const wm2 = new WeakMap([     [key1, &quot;val1&quot;],     [&quot;BADKEY&quot;, &quot;val2&quot;],     [key3, &quot;val3&quot;] ]); // TypeError: Invalid value used as WeakMap key typeof wm2; // ReferenceError: wm2 is not defined // 原始值可以先包装成对象再用作键const stringKey = new String(&quot;key1&quot;); const wm3 = new WeakMap([     stringKey, &quot;val1&quot; ]); alert(wm3.get(stringKey)); // &quot;val1&quot; \n\n\n初始化之后可以使用set ()再添加键/值对，可以使用get ()和has()查询，还可以使用delete()删除:\n\nconst wm = new WeakMap(); const key1 = &#123;id: 1&#125;,     key2 = &#123;id: 2&#125;; alert(wm.has(key1)); // false alert(wm.get(key1)); // undefined wm.set(key1, &quot;Matt&quot;)   .set(key2, &quot;Frisbie&quot;); alert(wm.has(key1)); // true alert(wm.get(key1)); // Matt wm.delete(key1); // 只删除这一个键/值对alert(wm.has(key1)); // false alert(wm.has(key2)); // true\n\n弱键\nWeakMap 中“weak”表示弱映射的键不属于正式的引用，不会阻止垃圾回收；\n只要键存在，键/值对就会存在于映射中，并被当作对值的引用；\n\nconst wm = new WeakMap(); wm.set(&#123;&#125;, &quot;val&quot;); \n\nset ()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。\n不可迭代键\n因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。\nWeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。\n\n","categories":["前端学习笔记","JS","ES6","WeakMap"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——WeakSet","url":"/2021/10/18/js-15-5/","content":"基本API\n使用new关键字实例化一个空的WeakSet:\n弱集合中的值只能是object或者继承自object的类型，尝试使用非对象设置值会抛出TypeError。\n如果想在初始化时填充弱集合，则构造函数可以接收-一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中:\n\nconst val1 = &#123;id: 1&#125;,     val2 = &#123;id: 2&#125;,     val3 = &#123;id: 3&#125;; // 使用数组初始化弱集合const ws1 = new WeakSet([val1, val2, val3]); alert(ws1.has(val1)); // true alert(ws1.has(val2)); // true alert(ws1.has(val3)); // true // 初始化是全有或全无的操作// 只要有一个值无效就会抛出错误，导致整个初始化失败const ws2 = new WeakSet([val1, &quot;BADVAL&quot;, val3]); // TypeError: Invalid value used in WeakSet typeof ws2; // ReferenceError: ws2 is not defined // 原始值可以先包装成对象再用作值const stringVal = new String(&quot;val1&quot;); const ws3 = new WeakSet([stringVal]); alert(ws3.has(stringVal)); // true \n\n\n初始化之后可以使用add()再添加新值，可以使用has()查询，还可以使用delete()删除:\n\nconst ws = new WeakSet(); const val1 = &#123;id: 1&#125;,     val2 = &#123;id: 2&#125;; alert(ws.has(val1)); // false ws.add(val1) .add(val2); alert(ws.has(val1)); // true alert(ws.has(val2)); // true ws.delete(val1); // 只删除这一个值alert(ws.has(val1)); // false alert(ws.has(val2)); // true\n\n弱值原理同WeakMap\n不可迭代值\nWeakset中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。\nWeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。\n\n","categories":["前端学习笔记","JS","ES6","WeakSet"],"tags":["JS学习"]},{"title":"Javascript——Object和Map比较分析","url":"/2021/10/17/js-tips-1/","content":"内存占用\nObject 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对;\n\n插入性能\n向object和 Map中插入新键/值对的消耗大致相当，不过插人Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。\n\n查找速度\n与插入不同，从大型object和 Map中查找键/值对的性能差异极小，但如果只包含少量键/值对,则object有时候速度更快。在把object 当成数组使用的情况下（比如使用连续整数作为属性)，浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言,查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择Obiect更好一些。\n\n删除性能\n使用delete删除object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此,出现了一些伪删除对象属性的操作，包括把属性值设置为undefined或null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map。\n\n","categories":["前端学习笔记","JS","Object","Map"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Array","url":"/2021/09/08/js-15-1/","content":"创建数组① 使用 Array 构造函数\n在使用 Array 构造函数时，也可以省略 new 操作符；\n\nlet colors = new Array();\n\n\n如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值：\n\nlet colors = new Array(15);\n\n\n也可以给 Array 构造函数传入要保存的元素：\n\nlet colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);\n\n② 使用数组字面量（array literal）表示法：let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个元素的数组let names = []; // 创建一个空数组let values = [1,2,]; // 创建一个包含 2 个元素的数组\n\n③ from()\nfrom()用于将类数组结构转换为数组实例；\n\nArray.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构：\n// 字符串会被拆分为单字符数组console.log(Array.from(&quot;Matt&quot;)); // [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] // 可以使用 from()将集合和映射转换为一个新数组const m = new Map().set(1, 2)                     .set(3, 4); const s = new Set().add(1)                     .add(2)                     .add(3)                     .add(4); console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] // Array.from()对现有数组执行浅复制const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4] alert(a1 === a2); // false // 可以使用任何可迭代对象const iter = &#123;     *[Symbol.iterator]() &#123;         yield 1;         yield 2;         yield 3;         yield 4;     &#125; &#125;; console.log(Array.from(iter)); // [1, 2, 3, 4]// arguments 对象可以被轻松地转换为数组function getArgsArray() &#123;     return Array.from(arguments); &#125; console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] // from()也能转换带有必要属性的自定义对象const arrayLikeObject = &#123;     0: 1,     1: 2,     2: 3,     3: 4,     length: 4 &#125;; console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]\nArray.from()还接收第二个可选的映射函数参数；\n\n这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组；\n\n\n还可以接收第三个可选参数，用于指定映射函数中 this 的值；\n\n\nconst a1 = [1, 2, 3, 4]; const a2 = Array.from(a1, x =&gt; x**2); const a3 = Array.from(a1, function(x) &#123;return x**this.exponent&#125;, &#123;exponent: 2&#125;); console.log(a2); // [1, 4, 9, 16] console.log(a3); // [1, 4, 9, 16]\n\n④ of()\nArray.of()可以把一组参数转换为数组\n用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：\n\nconsole.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]console.log(Array.of(undefined)); // [undefined]\n\n数组空位\n使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）；\nECMAScript 会将逗号之间相应索引位置的值当成空位；\n\nconst options = [,,,,,]; // 创建包含 5 个元素的数组console.log(options.length); // 5 console.log(options); // [,,,,,]\n\n\nES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：\n\nconst options = [1,,,,5]; for (const option of options) &#123;  console.log(option === undefined); &#125; // false // true // true // true // falseconst a = Array.from([,,,]); // 使用 ES6 的 Array.from()创建的包含 3 个空位的数组for (const val of a) &#123;  alert(val === undefined); &#125; // true// true// truealert(Array.of(...[,,,])); // [undefined, undefined, undefined]for (const [index, value] of options.entries()) &#123;  alert(value); &#125; // 1 // undefined // undefined // undefined // 5\n\n数组索引\n要取得或设置数组的值，需要使用中括Ձ并提供相应值的数字索引：\n如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]，则数组长度会自动扩展到该索引值加 1；\n数组中最后一个元素的索引始终是 length - 1；\n数组最多可以包含 4294967295 个元素；\n\nlet colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 定义一个字符串数组alert(colors[0]); // 显示第一项colors[2] = &quot;black&quot;; // 修改第三项colors[3] = &quot;brown&quot;; // 添加第四项alert(colors.length); // 3 alert(names.length); // 0\n\n检测数组\nECMAScript 提供了 Array.isArray()方法，的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的；\n\n迭代器方法\n在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()；\nkeys()返回数组索引的迭代器；\nvalues()返回数组元素的迭代器；\nentries()返回索引/值对的迭代器；\n\nconst a = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]; // 因为这些方法都返回迭代器，所以可以将它们的内容// 通过 Array.from()直接转换为数组实例const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] console.log(aEntries); // [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]\n\n复制和填充方法\n批量复制方法 copyWithin()；\n填充数组方法 fill()；\n这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引；\n\nfill()\nfill()方法可以向一个已有的数组中插入全部或部分相同的值；\n开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾；\n负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引；\nfill()默认忽略超出数组边界、零长度及方向相反的索引范围；\n\n\n\nconst zeroes = [0, 0, 0, 0, 0]; // 用 5 填充整个数组zeroes.fill(5); console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素zeroes.fill(6, 3); console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素zeroes.fill(7, 1, 3); console.log(zeroes); // [0, 7, 7, 0, 0]; zeroes.fill(0); // 重置// 用 8 填充索引大于等于 1 且小于 4 的元素// (-4 + zeroes.length = 1) // (-1 + zeroes.length = 4) zeroes.fill(8, -4, -1); console.log(zeroes); // [0, 8, 8, 8, 0];const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略zeroes.fill(1, -10, -6); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引过高，忽略zeroes.fill(1, 10, 15); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引反向，忽略zeroes.fill(2, 4, 2); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引部分可用，填充可用部分zeroes.fill(4, 3, 10) console.log(zeroes); // [0, 0, 0, 4, 4]\n\ncopyWithin()\ncopyWithin()会按照指定范围ุ复制数组中的部分内容，然后将它们插入到指定索引开始的位置；\ncopyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：\n\nlet ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置// 在源索引或目标索引到达数组边界时停止ints.copyWithin(5); console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); // 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置ints.copyWithin(0, 5); console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]reset(); // 从 ints 中复制索引 0 开始到索引 3 结束的内容// 插入到索引 4 开始的位置ints.copyWithin(4, 0, 3); alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); // JavaScript 引擎在插值前会完整复制范围内的值// 因此复制期间不存在重写的风险ints.copyWithin(2, 0, 6); alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset(); // 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的ints.copyWithin(-4, -7, -3); alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] let ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引过低，忽略ints.copyWithin(1, -15, -12); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset() // 索引过高，忽略ints.copyWithin(1, 12, 15); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引反向，忽略ints.copyWithin(2, 4, 2); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];reset(); // 索引部分可用，复制、填充可用部分ints.copyWithin(4, 7, 10) alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];\n\n转换方法\n所有对象都有 toLocaleString()、toString()和 valueOf()方法；\n在调用数组的 toLocaleString()方法时，会得到一个以逗号分隔的数组值的字符串；\n\nlet colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,green alert(colors.valueOf()); // red,blue,green alert(colors); // red,blue,green\n\n\n首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果；\n\n\n\nlet person1 = &#123;     toLocaleString() &#123;         return &quot;Nikolaos&quot;;     &#125;,     toString() &#123;         return &quot;Nicholas&quot;;     &#125; &#125;; let person2 = &#123;     toLocaleString() &#123;         return &quot;Grigorios&quot;;     &#125;,     toString() &#123;         return &quot;Greg&quot;;     &#125; &#125;; let people = [person1, person2]; alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg alert(people.toLocaleString()); // Nikolaos,Grigorios\n\n\n如果数组中某一项是null或undefined，则在join()、toLocaleString()、toString()、valueOf()返回的结果中会以空字符串表示\n\n栈方法\n\nlet colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // black alert(colors.length); // 2\n\n队列方法\n\n\n使用shift()和 push()，可以把数组当成队列来使用：\n\nlet colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.shift(); // 取得第一项alert(item); // red alert(colors.length); // 2\n\n\n使用 unshift()和 pop()，可以在相反方向上模拟队列：\n\nlet colors = new Array(); // 创建一个数组let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项alert(count); // 2 count = colors.unshift(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // green alert(colors.length); // 2\n\n排序方法\n\nlet values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); // 5,4,3,2,1 \n\nsort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。\n即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。\n\n//一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。let values = [0, 1, 5, 10, 15]; values.sort(); alert(values); // 0,1,10,15,5\n\n\nsort()方法可以接收一个比较函数\n比较函数接收两个参数：\n如果第一个参数应该排在第二个参数前面，就返回负值；* 如果两个参数相等，就返回 0；\n如果第一个参数应该排在第二个参数后面，就返回正值；\n\n\n\nfunction compare(value1, value2) &#123;     if (value1 &lt; value2) &#123;         return -1;     &#125; else if (value1 &gt; value2) &#123;         return 1;     &#125; else &#123;         return 0;     &#125; &#125;let values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); // 0,1,5,10,15 \n\n\n比较函数还可简写为一个箭头函数：\n\nlet values = [0, 1, 5, 10, 15]; values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0); alert(values); // 15,10,5,1,0 \n\n操作方法concat()方法\n可以在现有数组全部元素基础上创建一个新数组；\n原理：它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾,最后返回这个新构建的数组；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]); console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]\n\n\n打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let newColors = [&quot;black&quot;, &quot;brown&quot;]; let moreNewColors = &#123;     [Symbol.isConcatSpreadable]: true,     length: 2,     0: &quot;pink&quot;,     1: &quot;cyan&quot; &#125;; newColors[Symbol.isConcatSpreadable] = false; // 强制不打平数组let colors2 = colors.concat(&quot;yellow&quot;, newColors); // 强制打平类数组对象let colors3 = colors.concat(moreNewColors); console.log(colors); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] console.log(colors3); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]\n\nslice()方法\n用于创建一个包含原有数组中一个或多个元素的新数组，操作不影响原始数组；\n接收一个或两个参数：返回元素的开始索引和结束索引；\n如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素；\n如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素；\n\n\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; let colors2 = colors.slice(1); let colors3 = colors.slice(1, 4); alert(colors2); // green,blue,yellow,purple alert(colors3); // green,blue,yellow \n\nsplice()方法\n在数组中间插入元素；\n删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量；\n插入：需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素，第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素；\n替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let removed = colors.splice(0,1); // 删除第一项alert(colors); // green,blue alert(removed); // red，只有一个元素的数组removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 在位置 1 插入两个元素alert(colors); // green,yellow,orange,blue alert(removed); // 空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，只有一个元素的数组\n\n搜索和位置方法\nECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索；\n\n严格相等\n\nlet numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; alert(numbers.indexOf(4)); // 3 alert(numbers.lastIndexOf(4)); // 5 alert(numbers.includes(4)); // true alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.includes(4, 7)); // false let person = &#123; name: &quot;Nicholas&quot; &#125;; let people = [&#123; name: &quot;Nicholas&quot; &#125;]; let morePeople = [person]; alert(people.indexOf(person)); // -1 alert(morePeople.indexOf(person)); // 0 alert(people.includes(person)); // false alert(morePeople.includes(person)); // true \n\n断言函数\n断言函数接收 3 个参数：元素、索引和数组本身；\n\n元素是数组中当前଼索的元素；\n索引是当前元素的索引；\n数组就是正在଼索的数组\n\n\nfind()和 findIndex()方法使用了断言函数：\n\n这两个方法都从数组的最小索引开始；\nfind()返回第一个匹配的元素；\nfindIndex()返回第一个匹配元素的索引\n这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。\n\n\n\nconst people = [     &#123;         name: &quot;Matt&quot;,         age: 27     &#125;,     &#123;         name: &quot;Nicholas&quot;,         age: 29     &#125; ]; alert(people.find((element, index, array) =&gt; element.age &lt; 28)); // &#123;name: &quot;Matt&quot;, age: 27&#125; alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28)); // 0 \n\n迭代方法\n\nlet numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2); alert(everyResult); // false let someResult = numbers.some((item, index, array) =&gt; item &gt; 2); alert(someResult); // truelet filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2); alert(filterResult); // 3,4,5,4,3 let mapResult = numbers.map((item, index, array) =&gt; item * 2); alert(mapResult); // 2,4,6,8,10,8,6,4,2numbers.forEach((item, index, array) =&gt; &#123;  // 执行某些操作 &#125;); \n\n归并方法\n\nlet values = [1, 2, 3, 4, 5]; let sum1 = values.reduce((prev, cur, index, array) =&gt; prev + cur); alert(sum); // 15let sum2 = values.reduceRight(function(prev, cur, index, array)&#123;     return prev + cur; &#125;); alert(sum); // 15 ","categories":["前端学习笔记","JS","Array"],"tags":["JS学习"]}]