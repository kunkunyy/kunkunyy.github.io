[{"title":"Hello World","url":"/2021/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Markdown学习笔记","url":"/2021/03/12/markdown-study-notes/","content":" 之前只是用markdown写过博客并没有系统的去了markdown语法，现在将创建博客后的第一篇文章用来记录我学习markdown的经历以及对于知识点的理解。\nmarkdown官方介绍和个人理解菜鸟教程介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n个人理解\nMarkdown是一种纯文本标记语言\n语法简单，容易上手\n按照语法，自动排版，格式易操作\n……\n\n语法学习标题标题有两种书写格式，推荐使用第一种。\n# 号标识标题\n用法：使用 # 号可表示 1-6 级标题，每升一级添加一个 # 号\n易错点：最后一个 # 号后空一格\n示例：# 一级标题## 二级标题\n结果\n  \n\n\n= 和 - 标记标题\n用法：在对应文字下方输入 = （-）即可\n示例：一级标题=二级标题-\n结果\n\n\n\n段落格式换行\n实现方式：\n句子末尾空两格然后回车\n空一行实现换行\n\n\n\n字体斜体*猫猫头*_猫猫头_\n粗体**猫猫头**__猫猫头__\n粗斜体***猫猫头***___猫猫头___\n\n分割线\n实现方式：\n在一行中用三个以上的星号、减号、底线来建立一个分隔线。\n行内不能有其他东西。\n可以在星号或是减号中间插入空格。\n\n\n\n删除线（在文字上添加删除线）\n实现方式：~~猫猫头的小窝~~\n效果展示：猫猫头的小窝\n\n下划线\n实现方式：&lt;u&gt;猫猫头的小窝&lt;/u&gt;\n效果展示：猫猫头的小窝\n\n脚注\n补充说明词语或者句子内容。\n可用于标注出处，翻译等。\n实现方式：“[^情不知所起，一往而深。]”[^情不知所起，一往而深。]:感情不知道什么时候就开始了，而且愈来愈深厚。\n效果展示：“情不知所起，一往而深。”\n\n列表有序、无序列表\n实现方式：\n有序：数字并加上 . 号来表示。\n无序：星号(*)、加号(+)或是减号(-)作为列表标记，且标记后面要添加一个空格。\n\n\n\n列表嵌套\n实现方式：在子列表中的选项前面添加四个空格（或者一个Tab键）\n例子：1. 猫猫头：    - 猫猫头的代码库    - 猫猫头的图片库\n\n\n\n\n区块\n实现方式：在段落开头使用 &gt; 符号，后面紧跟一个空格符号。\n嵌套使用：\n区块嵌套：每增加一个 &gt; 符号增加一层。\n区块嵌套列表：&gt; + 猫猫头的代码库&gt; + 猫猫头的图片库\n\n\n猫猫头的代码库\n猫猫头的图片库\n\n\n\n列表嵌套区块：1. 猫猫头    &gt; 猫猫头的图片库    &gt; 猫猫头的代码库\n\n\n猫猫头\n猫猫头的图片库猫猫头的代码库\n\n\n\n\n\n代码\n实现方式：\n代码区块：\n使用 4 个空格或者一个制表符（Tab 键）。\n用 ``` 包裹一段代码，并指定一种语言，也可以不指定（推荐）。\n\n\n\n\n\n链接\n实现方法：[链接名称](链接地址)或者&lt;链接地址&gt;\n例子：[百度](www.baidu.com)\n\n图片\n实现方式：![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n\n补充：可以使用&lt;img&gt;标签，用于指定图片的高度与宽度。\n\n表格\n实现方式：\n使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n\n示例：| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n总结这里就暂时总结了markdown一些基本用法，能够满足用来写博客就可以了，后面继续加油吧！有什么问题可以留言哦！\n","categories":["markdown"],"tags":["markdown","study notes"]},{"title":"Python max函数不同参数结果比较","url":"/2021/03/15/python-skill-max/","content":"前言&emsp; &emsp; 在菜鸟教程中对于max函数描述是这样的：max() 方法返回给定参数的最大值，参数可以为序列。这个描述只是客观的将这个函数的功能给描述出来了，但这只是一个模糊的定义。由于没有指定可传入参数的类型，所以说这就带给了这个函数无限种可能。现在就来讨论讨论吧！如果有哪些地方表述不是很正确希望大家在评论区指出来哦！\n数字类型&emsp; &emsp; 首先我们来看看最简单大数字类型。毋庸置疑，当参数是数字的时候，直接返回最大的数就好了。但是要注意的是这里的数字指的是一系列数，返回其中最大的。下面来看一个简单的例子。\n&gt;&gt;&gt; max(1,2,3,4,5,6,7,8,9)9\n\n字符串类型&emsp; &emsp; 我们知道python中字符串是由单引号双引号括起来的一个字符序列。那么当输入max的变量为一个字符串它会返回给我们什么结果呢？\n&emsp; &emsp; 我们先看下面这个例子：\n&gt;&gt;&gt;a=&#x27;1,6,0,4,5&#x27;&gt;&gt;&gt;max(a)&#x27;6&#x27;\n我们输入一个由单个数字组成的字符串，穿入max函数后返回了其中的 ‘6’ 这个字符。难道是将字符转化为数字然后再比较大小吗？那字符串中的 ‘,’ 又去哪了呢？那如果是字母又如何进行比较呢？来看下一个例子：\n&gt;&gt;&gt;b=&#x27;fabced&#x27;&gt;&gt;&gt;max(b)&#x27;f&#x27;\n这里变量b为一个字母组成的字符串，结果返回给我们的是字符 ‘f’ ，这里我们大致应该可以判断出来：当max函数的输入变量为一个字符串的时候，则返回字符串中字符所对应的ASCII码最大的那个字符。\n&emsp; &emsp; 为了验证这一结论我们利用下面这个例子进行验证：\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;max(c)&#x27;c&#x27;\n&emsp; &emsp; 从这个例子我们就可以验证刚刚的结论了：c这个字符串中字符’1’’a’’2’’c’对应的ASCII码的大小分别为49，97，50，99，所以字符’c’所对应的ASCII码值最大固返回字符’c’。那么字符’,’去哪了呢？实际上字符’,’也是参与了比较，由于它所对应的ASCII码为44最小，所以看似跟舍弃了一样。\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;min(c)&#x27;,&#x27;\n\n另外，max函数还可以对于传入的可迭代对象找出元素中的最大值。这里可迭代的对象主要是列表和字典\n列表同样对于列表，它满足可迭代这样一个特点，这里我们主要分四种情况来讨论：\n\n元素全为数字&gt;&gt;&gt;a=[1,2,3,4,5]&gt;&gt;&gt;max(a)5\n元素全为字符&gt;&gt;&gt;b=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]&gt;&gt;&gt;max(b)&#x27;e&#x27;\n&gt;&gt;&gt;c=[&#x27;ab&#x27;,&#x27;ac&#x27;,&#x27;ad&#x27;,&#x27;ae&#x27;]&gt;&gt;&gt;max(c)&#x27;ae&#x27;\n&gt;&gt;&gt;d=[&#x27;1a&#x27;,&#x27;1b&#x27;,&#x27;2a&#x27;,&#x27;2b&#x27;]&gt;&gt;&gt;max(d)&#x27;2b&#x27;\n通过以上几个例子我们不难发现：\n列表中元素类型需一致；（前提条件）\n若列表中元素数字类型值，则返回列表中元素的最大值；\n若列表中元素为字符，字符转换为对应ASCII码值输出最大的；\n若列表中元素为字符串，将组成字符串的每个字符的ASCII码相加，然后输出最大的。\n\n列表（元组）刚刚我们讨论了简单元素组成的列表作为参数的情况，接下来我们看一看由元组组成的列表：我们还是按照上面的步骤来。\n\n全为数字\n&gt;&gt;&gt;a=[(1,3),(2,2),(1,4),(3,0)]&gt;&gt;&gt;max(a)(3,0)\n对应位置元素类型相同\n&gt;&gt;&gt;b=[(&#x27;a&#x27;,1),(&#x27;b&#x27;,5),(&#x27;a&#x27;,6)]&gt;&gt;&gt;max(b)(&#x27;b&#x27;,5)\n&gt;&gt;&gt;c=[(&#x27;a&#x27;,&#x27;A&#x27;),(&#x27;a&#x27;,&#x27;B&#x27;)]&gt;&gt;&gt;max(c)(&#x27;a&#x27;,&#x27;B&#x27;)\n元组大小不一致\n&gt;&gt;&gt;d=[(1,4),(3,1,5),(3,1)]&gt;&gt;&gt;max(d)(3,1,5)\n对应位置元素不同\n&gt;&gt;&gt;e=[(6,4),(6,1,5),(3,&#x27;a&#x27;)]&gt;&gt;&gt;max(e)(6,4)\n&gt;&gt;&gt;f=[(1,4),(&#x27;a&#x27;,2),(3,1)]&gt;&gt;&gt;max(e)TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;\n通过以上几个例子对比分析我们不难发现：\n\n按照元组内部排列顺序从前到后对应位置进行比较，如果对应位置元素类型和大小相同，则比较下一个位置的元素，按照此规则进行比较直至找到最大值或者出错。\n\n类型不匹配：列表元组中当比较到对应位置发现存在相比较的两个元素类型不相同时报错；\n\n当比较位置不存在元素时，默认为NUL；\n\n当比较的元素为数字类型值，则返回列表中元素的最大值；\n\n当比较的元素为字符，字符转换为对应ASCII码值返回；\n\n当比较的元素为字符串，将组成字符串的每个字符的ASCII码相加返回。\n\n\n字典\n对于字典类型来说相比较容易一些，只需要比较字典的键值，输出最大的键值；\n键值的比较同上。\n\n&gt;&gt;&gt;a=&#123;1:1,2:19,3:100,4:1&#125;&gt;&gt;&gt;max(a)4&gt;&gt;&gt;b=&#123;20:21,5:20,13:14&#125;&gt;&gt;&gt;max(b)20","categories":["python"],"tags":["Skill","python"]},{"title":"Python 字符串连接方法","url":"/2021/03/16/python-skill-string-concatenation/","content":"之前在学习Python的时候对于字符串的连接并没有过多的研究，能应付考试就好啦。最近在写博客遇到相关内容去查了查，发现字符串连接的方法还是非常多的，这篇博客就来记录一下方便以后查看。\n字符串连接方法总结假设’str1’，’str2’为两个字符串。\n‘+’ 连接a = str1b = str2print(a+b)&gt;&gt;&gt;str1str2\n\n模式串”%s”方法print（&#x27;%s%s&#x27; %(str1,str2)）&gt;&gt;&gt;str1str2\nformat 方法print(&quot;&#123;&#125;&#123;&#125;&quot;.format(str1，str2))print(&quot;&#123;0&#125;&#123;1&#125;&quot;.format(str1，str2))print(&quot;&#123;c&#125;&#123;d&#125;&quot;.format(c=str1，d=str2))&gt;&gt;&gt;str1str2\n‘f-string’方法print(f&#x27;&#123;str1&#125;&#123;str2&#125;&#x27;) &gt;&gt;&gt;str1str2\njoin方法\n列表print(&#x27;&#x27;.join([str1,str2])) &gt;&gt;&gt;str1str2\n字典：只有键和值均为字符串时才可使用。a=&#123;&#x27;20&#x27;:&#x27;20&#x27;,&#x27;520&#x27;:&#x27;1314&#x27;&#125;print(&#x27;&#x27;.join(a))print(&#x27;&#x27;.join(a.value（））) &gt;&gt;&gt; &#x27;20520&gt;&gt;&gt; &#x27;201314&#x27;\n通过() 多行拼接s = (    &#x27;Hello&#x27;    &#x27; &#x27;    &#x27;World&#x27;    &#x27;!&#x27;)print(s)&gt;&gt;&gt; Hello World! \n通过string模块中的Template对象拼接\n实现原理：通过Template初始化一个字符串。这些字符串中包含了一个个key。通过调用substitute或safe_subsititute，将key值与方法中传递过来的参数对应上，从而实现在指定的位置导入字符串。from string import Templates = Template(&#x27;$&#123;s1&#125; $&#123;s2&#125;!&#x27;)print(s.safe_substitute(s1=&#x27;Hello&#x27;,s2=&#x27;World&#x27;))&gt;&gt;&gt; Hello World\n空格自动连接&gt;&gt;&gt; &quot;Hello&quot; &quot;Nasus&quot;&#x27;HelloNasus&#x27;\n\n","categories":["python"],"tags":["Skill","python"]},{"title":"python学习笔记（一）","url":"/2021/03/15/python-study-note/","content":"本科学习python课程笔记，之前使用的有道云笔记记载，现在将它搬运到博客中。\n第一章是一些基本概念，所以从第二章开始记的。所以，一起加油咯！\n\n第二章主要是turtle库的使用，然后简单介绍了python中的字符串的使用，第三章会详细讲字符串。\n字符串简单介绍字符串的两种序号表达\n假设字符串长度为L：\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n\n\n\n字符串截取范围\nTempStr[0:-1]    从0到-1，但不包括-1\n口诀：前取后不取\n\nturtle库介绍&emsp; &emsp; 实际上我们使用turtle库来绘制图形就是：在操纵“小海龟”在我们所定义的画布（canvas）（或者叫做窗体也可以）上进行爬行，它行动留下的痕迹就是我们所要绘制图形的轮廓。&emsp; &emsp; 在了解绘制原理后我们就对于这个必不可少的画布进行了解和学习。\n画布坐标轴&emsp; &emsp; 一般情况下，当你创建了一个画布它就会对应的生成坐标轴，一方面是为了方便我们绘制图形；另一方面也是为了避免造成歧义导致出错。&emsp; &emsp; 下图是对应坐标系的规定：\n\n\n\n画布（窗体）的创建\nturtle.screensize(canvwidth=None,canvheight=None,bg=None)\n参数：画布宽、高、背景色\n\n\nturtle.setup(width, height, startx, starty)\n参数：窗体宽、高、窗体左上角顶点的横纵坐标\n输入宽和高为整数时,表示像素;为小数时,表示占据电脑屏幕的比例\n\n\n\n画笔&emsp; &emsp;默认情况下，我们的“画笔”是一个位于坐标原点面朝正向的小海龟，我们通过控制小海龟来完成图形的绘制。\n画笔的属性\nturtle.pensize/width(width)\n用于设置画笔宽度\n\n\nturtle.pencolor()\n用于设置画笔颜色\n\n\nturtle.speed(x)\n用于设置画笔速度，0≤x≤10\n\n\n\n画笔移动状态\nturtle.forward/backward(d)\n向前/向后移动距离为d\n\n\nturtle.right/left(r)\n向左/右转动度数\n\n\nturtle.down/up()\n画笔落下/抬起\n\n\nturtle.fillcolor()\n给绘制的图形填充颜色\n\n\nturtle.circle(r,angle)\n绘制圆，半径正负均可，angle为角度\n\n\n\n\nturtle.done()\n结束程序\n\n\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"python学习笔记（二）","url":"/2021/03/15/python-study-notes-2/","content":"第三章这一章主要是对基本数据类型的学习，包括数字和字符串类型以及对应的操作。\n数字类型\n类型：整数、浮点数、复数\n\n浮点数\n浮点数间运算存在不确定尾数，如下图所示：\n\n\n原因：浮点数是小数的一种二进制表示方法，由于浮点数存在精度限制，在使用浮点数做运算时就可能会产生不确定尾数。\n解决方法：round(x,d)对x四舍五入，d是小数截取位数。\n\n\n科学计数法\n\n\n复数\n实、虚部获取方法：z为一复数\n实部：z.real\n虚部：z.imag\n\n\n\n数字类型关系\n不同类型间可进行混合运算，生成结果为”最宽”类型\n整数 &gt; 浮点数 &gt; 复数\n\n数值运算函数常用函数abs(x)\n对于x取绝对值\n\nsqrt(x)\nx的平方根\n\npow(x,y)\nx的y次幂\n\nround(x,[d])\n对于数x，四舍五入保留d位\n\nmax()/min()\n返回给定参数的最大值\n参数可以为：数字、字符串、列表、元组\n不同参数返回结果请参考这篇文章：max不同参数比较\n\nint(x)\n将x变成整数，直接舍弃小数部分；\n参数：数字，字符\n\nfloat(x)\n将x变成浮点数，增加小数部分\n参数：数字，字符\n\n字符串字符串表示方法\n一对单、双或三引号构成\n多行字符串表示方法：\n三引号\n小括号\n\n\n单、双、三引号的使用：  &#x27;这里有个&quot;双引号&quot;哦&#x27; &quot;这里有个&#x27;单引号&#x27;嘎&quot;&#x27;&#x27;&#x27; 这里既有&#x27;单引号&#x27;嘎，又有&quot;双引号&quot;哦  &#x27;&#x27;&#x27;\n\n字符串排序\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n字符串字符的获取\n假设变量name为一字符串，其中N、M均为索引号：\n获取单个字符：name[N];\n获取一段字符串：name[N:M];\n根据步长K切片：name[N:M:K];\n\n\n\n字符串的操作符、处理函数和方法字符串的操作符\nx+y\n连接两个字符串x和y\n字符串连接方法\n\n\nx*n\n复制n次字符串x\n\n\nx in s\n判断x是否是s的子串，，是返回true，否返回false\n\n\n\n字符串常用处理函数和方法\nlen(x)：返回字符串长度\nstr(x)：任意类型x对应的字符串形式\nstr.lower()/upper()\n返回新的字符串，全部字符小写/大写\n\n\nstr.split(sep)\n返回的是一个列表，将源字符串按照sep进行分割\n\n\nstr.count(sub)\n返回字串sub在str中出现的次数\n\n\nstr.replace(old,new)\n返回新的字符串，将str中所有old子串替换为new\n\n\nstr.center(width[,fillchart])\n字符串str根据宽度width居中，fillchart为剩余区域的填充字符\n\n\nstr.join(item)\n在item除最后一个元素外增加一个str\n多用于字符串分割\n\n\n\n字符串类型格式化\n&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)\n槽：\n槽内部对格式化的配置方式\n\n&gt;&gt;&gt; &quot;&#123;0:=^20&#125;.format(&quot;python&quot;)&quot;&#x27;=======PYTHON======&#x27;\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"Python学习笔记（三）","url":"/2021/03/22/python-study-notes-3/","content":"程序控制结构是每一种程序设计语言都会涉及到的一块，这边文章就来讲讲python中的程序设计结构。\n条件语句用于条件组合的三个保留字设x，y为两个条件：\n\n\n\n操作符\n描述\n\n\n\nx and y\n逻辑与\n\n\nx or y\n逻辑或\n\n\nnot x\n逻辑非\n\n\n单分支结构\n单分支结构的定义想必大家也比较清楚了。条件语句中单分支结构写法如下：if 判断条件:    执行语句\n当条件符合时，执行相应的语句；不符合时则跳过。*\n\n二分支结构\n二分支增添了else这个保留字，和if一起使用，及满足判断条件执行if中的内容，不满足就执行else中内容：\nif 判断条件:    执行语句else：    执行语句\n多分支结构\n多分支结构在二分支的结构上引入了elif这个保留字，实际上等价于C语言中的else if：\nif 判断条件:    执行语句elif 判断条件:    执行语句......else:    执行语句\n\n循环语句for循环\npython中的for循环需要和保留字in进行搭配使用，即：for 元素 in 迭代对象:    执行语句\n这里我们要注意的是for语句是从可迭代的对象中依次取出每一个元素，然后再进行操作。\n\n\n和range()函数一起使用：\nrange()用于生成一个可迭代的对象\nrange(start, stop[, step])for i in range(3):    print(i)012----------------------------for i in range(1,3):    print(i)12----------------------------for i in range(1,5,2):    print(i)13\n\n\n列表，元组，集合，字符串#遍历列表a = [1,2,3]for i in a:    print(i)123----------------------------#遍历元组b = (&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;)for i in b:    print(i)helloworld!----------------------------#遍历集合c = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;&#125;for i in c:    print(i)helloworld!----------------------------#遍历字符串d = &quot;python&quot;for i in d:    print(i)python\n字典e = &#123;&#x27;name&#x27;:&#x27;sun&#x27;,&#x27;habit&#x27;:&#x27;sunshine&#x27;&#125;#遍历键值对for i,j in e.items():    print(i,j)name sunhabit sunshine----------------------------#遍历键for i in e.keys():    print(i)namehabit----------------------------#遍历值for i in e.values():    print(i)sunsunshine\n文件\n\n\nfi是一个文件标识符，遍历其每行，产生循环\nfor line in fi:    &lt;语句块&gt;\nwhile循环\n使用方法：\n\n当条件判断为True时，执行语句块；\n当条件判断为False时，循环终止。while &lt;条件&gt;：    &lt;语句块&gt;\n\n\n与else同用：\n\n当while语句条件为true时，执行语句块内容，为false时执行else语句中的内容。while &lt;条件&gt;:    &lt;语句块&gt;else:    &lt;语句块&gt;\n\n\n\n循环保留字：continue和breakcontinue\n被用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环\n\nbreak\n可以跳出 for 和 while 的循环体\nbreak仅跳出当前最内层循环\n示例：for i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        continue    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)PYTHON正常退出\nfor i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        break    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python学习笔记（四）","url":"/2021/03/27/python-study-notes-4/","content":"函数的使用函数定义在Python中我们时常会使用函数来提高代码的效率和复用性，函数的定义如下：\ndef &lt;函数名&gt;(&lt;参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n\n这里def保留字用于声明函数，必须填写。\n\n参数设置\n参数设置主要有四类：必选参数、默认参数、可选参数、关键字参数\n\ndef &lt;函数名&gt;(&lt;必选参数&gt;,&lt;默认参数&gt;&lt;可选参数&gt;&lt;关键字参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n下面以计算n!这个函数为例子来介绍这些参数：\n必选参数传递\n当函数只有一个参数时默认该参数为必选参数\n\n默认参数传递\n优势：减低函数的难度\ntips：默认参数必须指向不变对象\n下面例子当中的参数m就是可选参数，def fact(n,m=1):    s = 1    for i in range(1,n+1):        s *= i    return s//m\n\n可变参数传递\n传入参数的个数是可变的。\n在参数前面加上*就是可变参数。\n在函数内部，参数numbers接收得到的是一个tuple，调用该函数时，可以传入任意个参数，包括0个参数def num(*fail):    total = 0    for i in fail:        total += i    return total\n这里fail可以接受多个参数的传递，如下所示：print(num(1,2))3print(num(4,5,6))15\n\n关键字参数传递\n使用**表示关键字参数def action(time,person,**job):    print(&quot;At&quot;,time,person,&quot;wants to&quot;,job)action(&#x27;7:00&#x27;,&#x27;Mom&#x27;,job = &#x27;clean house&#x27;)At 7:00 Mom wants to &#123;&#x27;job&#x27;: &#x27;clean house&#x27;&#125;\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"大数据分析实验（一）","url":"/2021/04/01/Big-data-analysis-experiment-1/","content":"Python 快速开发实验目的和要求\n熟悉 Python 开发环境；\n掌握项目和文件的建立；\n掌握 Python 的基本语法；\n\n实验内容和分析题目一：自定义函数，设置固定次数的登陆题目内容\n由键盘输入密码；\n若密码正确则屏幕显示：“Login success!”\n若密码错误则显示：“Wrong password or invalid input”，并显示剩余输入机会次数；\n共 3 次机会，用完则屏幕显示：“Your account has been suspended”，并退出程序。\n\n解题思路① 首先创建一个文件模拟数据库用于存储用户的账户和密码② 通过读取用户的输入来和文件中的账户密码进行比较③ 如果存在则显示登陆成功，否则显示登陆失败④ 定义一个变量用于存储用户失败次数，当失败次数大于3后，显示账户已被锁定然后结束程序。\n实验设计① 定义一个函数其参数为用户输入的用户名和密码，该函数将数据库文件打开然后按照存储形式进行比较，如果存在就返回True否则返回False② 主函数定义变量frequency用于标记用户登陆失败次数③ 利用while语句实现失败重新登陆这一过程；当匹配成功跳出循环，当超过三次也跳出循环结束程序。\n考察知识\n函数定义\n文件操作\nwhile语句\n\n实验代码#定义账号密码文件#读取文件，验证用户输入的账号密码是否在文件内#存在返回true，不存在返回falsedef Login_authentication(user, pwd):    f = open(&quot;information.txt&quot;, mode=&quot;r&quot;, encoding=&quot;UTF-8&quot;)    for line in f:        #按照你在文件中对字符串的存储方式来进行字符串比较        if line.strip() == user + &quot;-&quot; + pwd:            f.close()            return True    else:        f.close()        return False#存储错误次数frequency = 0while frequency &lt; 3:    #读取用户输入调用验证函数    user_name = input(&quot;Please enter user name：&quot;)    user_password = input(&quot;Please enter user password:&quot;)    ret = Login_authentication(user_name,user_password)    if ret:        print(&quot;Login success!&quot;)        break    else:        frequency += 1        if frequency == 3:            print(&quot;Your account has been suspended&quot;)        else:            print(&quot;Wrong password or invalid input,remaining times:&#123;&#125;&quot;.format(3-frequency))            print(end=&quot;\\n&quot;)\n\n实验结果\n运行结果：\n数据库文件：\n\n题目二：自定义函数, 将敏感词过滤后的文本写入指定位置的 txt题目内容\n自定义函数 texcreat(name,text),将 text 写入“name.txt”文件中\n自定义函数 Repalce,将某些敏感词(比如“暴力”)替换成“**”\n自定义函数将敏感词过滤后的文本写入指定 txt 文档中。\n\n解题思路① 创建一个文件用于存储定义敏感词；② 将用户输入的一句话作为参数传到敏感词过滤函数当中；③ 遍历该函数通过敏感词读取函数返回的由敏感词组成的列表比较该句话中是否存在敏感词，如果存在则将对应敏感词的字符长度存储下来然后用*来替代；④ 最后再将过滤完成的句子存放到以用户输入的文件名而创建的文件当中。\n实验设计① 创建一个存放敏感词的文件sensitive_word，输入一些敏感词存入到里面；② 定义一个函数read_sensitive_word函数用于读取文件中的敏感词然后将其存放在列表中，将存储敏感词的列表当作值进行返回；③ 创建一个函数texcreat用于接收用户输入的文件名然后创建这个文件，并将过滤敏感词后的句子存到该文件中；④ 定义一个函数Replace用于过滤敏感词；⑤ 主函数通过接受用户输入，先后调用过滤函数、读取敏感词函数、创建文件函数，然后结束程序。\n考察知识\n函数\n文件操作\n字符串操作\n\n实验代码#读取敏感词语文件def read_sensitive_word():    with open(&#x27;sensitive_word.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file_to_read:        lines = list()        for line in file_to_read.readlines():            if line is not None:                #去除字符串前后的空格，然后将字符串写入列表中                lines.append(line.strip(&#x27;\\n&#x27;))    return lines#创建文件，将过滤后的内容写入def texcreat(name,text):    file = open(name+&#x27;.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)    file.write(text)    file.close()#过滤敏感词def Replace(word):    sensitive_word = read_sensitive_word()    for line in sensitive_word:        if line in word:            #获取对应敏感词长度            word_length = len(line)            #将敏感词进行替换            word = word.replace(line, &#x27;*&#x27; * word_length)    return wordname = input(&quot;请输入文件名：&quot;)sentence = input(&quot;请输入你想说的话：&quot;)texcreat(name,Replace(sentence))\n\n实验结果\n运行结果：\n敏感词文件：\n\n题目三：电子抽奖器模拟题目内容&emsp;&emsp;商店街上新开了一家超市，经营各种生活用品、食品、电器等。经营者是一对年轻夫妇， 为了纪念开业，他们举行了为期一个周的抽奖活动，并到处广告宣传，说这次抽奖平均 100 人就能有 1 人获得一等奖。首次宣传，促销期间门庭若市。 但最近商业街一些老店主跑来告状，说那家店在抽奖促销期间每天客流明显超过 100 人，然而一周过去了，抽中开业纪念大奖的只有 5 个人。请你模拟一下电子抽奖器，分析一下一周 5 个人中奖是否正常？\n解题思路① 利用random函数来随机生成数用于模拟中奖情况；② 循环多次来代替随机抽样，最后以数值型呈现出最终概率。\n实验设计① 定义一个“抽奖函数”利用random库中的randint方法在0-9之间随机生成一个数，当数小于1时为真，大于1时为假，用于实现中奖概率为1%的条件；② 在主函数中利用for循环循环多次实现模拟情况然后每次循环都调用“抽奖函数”，以其返回值作为判断依据然后统计最终的中奖次数。\n考察知识\n函数\nrandom库\n\n实验代码import random# 判断中奖函数def lottery():    flag = random.randint(0, 9)    if flag &lt; 1:        return True    else:        return Falseif __name__ == &#x27;__main__&#x27;:    # 中奖次数    a = 0    # 没有中奖次数    b = 0    for i in range(1000000):        if (lottery()):            a += 1        else:            b += 1print(&#x27;共计中奖：&#x27;, a, &#x27;，未中奖：&#x27;, b)\n\n实验结果\n运行结果：\n\n题目四：小说《Walden》单词词频统计题目内容&emsp;&emsp;Walden 中文译名《瓦尔登湖》，是美国作家梭罗独居瓦尔登湖畔的记录，描绘了他两年多时间里的所见、所闻和所思。该书崇尚简朴生活，热爱大自然的风光，内容丰厚，意义深远，语言生动。请用 Python 统计小说 Walden 中各单词出现的频次，并按频次由高到低排序。\n解题思路① 读取文件；② 为了避免因为大小写情况导致统计出错，先将所有大写字母转为小写字母；③ 截取字符串，然后将单词和出现次数以键值对的形式存储在字典中然后输出。\n考察知识\n字符串\n文件操作\n字典\n\n实验代码import re#读取文件file = open(&#x27;Walden.txt&#x27;,&#x27;r&#x27;)text = file.read()file.close()#将所有英文字母变成小写text = text.lower()#使用正则表达式用空格替换标点符号text = re.sub(&#x27;[,.?:;&quot;\\&#x27;]&#x27;,&#x27;&#x27;,text)#以空格为分隔符截取字符串words = text.split(&quot; &quot;)#创建统计单词的字典word_sq = &#123;&#125;#统计单词出现个数存入字典中for i in words:    if i not in word_sq.keys():        word_sq[i] = 1    else:        word_sq[i] += 1#按照字典的值进行排序res = sorted(word_sq.items(),key=lambda x:x[1], reverse=True)print(&quot;单词 出现次数&quot;)for i in res:    print(i[0],i[1])\n\n实验结果\n运行结果：\n\n","categories":["experiment"],"tags":["big data analysis experiment","experiment"]},{"title":"Python学习笔记（五）","url":"/2021/04/03/python-study-notes-5/","content":"组合数据类型集合基本内容\n定义：包含0个或多个数据项的无序组合\n特点：\n元素之间无序，每个元素唯一，不存在相同元素\n元素不可更改，不能是可变数据类型\n用大括号 {} 表示，元素间用逗号分隔\n\n\n创建方式：建立集合类型用 {} 或 set()\ntips：空集合必须用set()创建&gt;&gt;&gt; A = &#123;&quot;python&quot;, 123, (&quot;python&quot;,123)&#125;&#123;123, &#x27;python&#x27;, (&#x27;python&#x27;, 123)&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; C = &#123;&quot;python&quot;, 123, &quot;python&quot;,123&#125;&#123;&#x27;python&#x27;, 123&#125;\n\n集合间操作\n\n\n操作符\n描述\n\n\n\nS\nT\n\n\nS - T\n返回一个新集合，包括在集合S但不在T中的元素\n\n\nS &amp; T\n返回一个新集合，包括同时在集合S和T中的元素\n\n\nS ^ T\n返回一个新集合，包括集合S和T中的非相同元素\n\n\nS &lt;= T 或 S &lt; T\n返回True/False，判断S和T的子集关系\n\n\ns &gt;= T 或 S &gt; T\n返回True/False，判断S和T的包含关系\n\n\nS -= T\n更新集合S，包括在集合S但不在T中的元素\n\n\nS &amp;= T\n更新集合S，包括同时在集合S和T中的元素\n\n\nS ^= T\n更新集合S，包括集合S和T中的非相同元素\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)#并运算&gt;&gt;&gt; A|B&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;y&#x27;, &#x27;3&#x27;, 123&#125;#交运算&gt;&gt;&gt; A&amp;B&#123;&#x27;p&#x27;, &#x27;y&#x27;&#125;#非相同元素&gt;&gt;&gt; A^B&#123;&#x27;2&#x27;, 123, &#x27;3&#x27;, &#x27;1&#x27;&#125;#差运算&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;&#x27;3&#x27;, &#x27;1&#x27;, &#x27;2&#x27;&#125;\n\n集合处理方法\n\n\n操作函数\n描述\n\n\n\nS.add(x)\n如果x不在集合S中，将x增加到S\n\n\nS.discard(x)\n移除S中元素x，如果x不在集合S中，不报错\n\n\nS.remove(x)\n移除S中元素x，如果x不在集合S中，产生KeyError异常\n\n\nS.clear()\n移除S中所有元素\n\n\nS.pop()\n随机返回S的一个元素，更新S，若S为空产生KeyError异常\n\n\nS.copy()\n返回集合S的一个副本\n\n\nlen(S)\n返回集合S的元素个数\n\n\nx in S\n判断S中元素x，x在集合S中，返回True，否则返回False\n\n\nx not in S\n判断S中元素x，x不在集合S中，返回False，否则返回True\n\n\nset(x)\n将其他类型变量x转变为集合类型\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; for item in A:        print(item, end=&quot;&quot;)p123y&gt;&gt;&gt; A&#123;&#x27;p&#x27;, 123, &#x27;y&#x27;&#125;&gt;&gt;&gt; try:        while True:            print(A.pop(), end=&quot;&quot;))    except:        passp123y&gt;&gt;&gt; Aset()\n\n应用场景\n包含关系比较：&gt;&gt;&gt; &quot;p&quot; in &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;True&gt;&gt;&gt; &#123;&quot;p&quot;, &quot;y&quot;&#125; &gt;= &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;False\n数据去重：&gt;&gt;&gt; ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, 123]&gt;&gt;&gt; s = set(ls)&#123;&#x27;p&#x27;, &#x27;y&#x27;, 123&#125;&gt;&gt;&gt; lt = list(s) [&#x27;p&#x27;, &#x27;y&#x27;, 123]\n\n总结\n集合使用{}和set()函数创建\n集合间操作：交(&amp;)、并(|)、差(-)、补(^)、比较(&gt;=&lt;)\n集合类型方法：.add()、.discard()、.pop()等\n集合类型主要应用于：包含关系比较、数据去重\n\n序列类型序列类型及操作序列类型定义\n序列是具有先后关系的一组元素。\ntips：\n序列是一维元素向量，元素类型可以不同\n类似数学元素序列： s0, s1,    … ,    sn-1\n元素间由序号引导，通过下标访问序列的特定元素\n\n\n序列是一个基类类型包括：\n字符串类型\n元组类型\n列表类型\n\n\n\n操作符\n\n\n操作符及应用\n描述\n\n\n\nx in s\n如果x是序列s的元素，返回True，否则返回False\n\n\nx not in s\n如果x是序列s的元素，返回False，否则返回True\n\n\ns + t\n连接两个序列s和t\n\n\ns * n 或 n * s\n将序列s复制n次\n\n\ns[i]\n索引，返回s中的第i个元素，i是序列的序号\n\n\ns[i: j] 或 s[i: j: k]\n切片，返回序列s中第i到j以k为步长的元素子序列\n\n\n函数和方法\n\n\n函数和方法\n描述\n\n\n\nlen(s)\n返回序列s的长度\n\n\nmin(s)\n返回序列s的最小元素，s中元素需要可比较\n\n\nmax(s)\n返回序列s的最大元素，s中元素需要可比较\n\n\ns.index(x) 或 s.index(x, i, j)\n返回序列s从i开始到j位置中第一次出现元素x的位置\n\n\ns.count(x)\n返回序列s中出现x的总次数\n\n\n元组类型定义\n元组是序列类型的一种扩展\n元组是一种序列类型，一旦创建就不能被修改\n使用小括号 () 或 tuple() 创建，元素间用逗号 , 分隔\n可以使用或不使用小括号\n\n&gt;&gt;&gt; creature = &quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, &quot;human&quot;&gt;&gt;&gt; creature(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;)&gt;&gt;&gt; color = (0x001100,\t&quot;blue&quot;, creature)&gt;&gt;&gt; color(4352, &#x27;blue&#x27;, (&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;))\n\n操作\n元组继承了序列类型的全部通用操作\n元组因为创建后不能修改，因此没有特殊操作\n使用或不使用小括号\n\n列表类型定义\n列表是一种序列类型，创建后可以随意被修改\n使用方括号 [] 或list() 创建，元素间用逗号 , 分隔\n列表中各元素类型可以不同，无长度限制\n\n操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nls[i] = x\n替换列表ls第i元素为x\n\n\nls[i: j: k] = lt\n用列表lt替换ls切片后所对应元素子列表\n\n\ndel ls[i]\n删除列表ls中第i元素\n\n\ndel ls[i: j: k]\n删除列表ls中第i到第j以k为步长的元素\n\n\nls += lt\n更新列表ls，将列表lt元素增加到列表ls中\n\n\nls *= n\n更新列表ls，其元素重复n次\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls[1:2] = [1, 2, 3, 4][&#x27;cat&#x27;, 1, 2, 3, 4, &#x27;tiger&#x27;, 1024]&gt;&gt;&gt; del ls[::3] [1, 2, 4, &#x27;tiger&#x27;]&gt;&gt;&gt; ls*2[1, 2, 4, &#x27;tiger&#x27;, 1, 2, 4, &#x27;tiger&#x27;]\n\n\n\n\n函数或方法\n描述\n\n\n\nls.append(x)\n在列表ls最后增加一个元素x\n\n\nls.clear()\n删除列表ls中所有元素\n\n\nls.copy()\n生成一个新列表，赋值ls中所有元素\n\n\nls.insert(i,x)\n在列表ls的第i位置增加元素x\n\n\nls.pop(i)\n将列表ls中第i位置元素取出并删除该元素\n\n\nls.remove(x)\n将列表ls中出现的第一个元素x删除\n\n\nls.reverse()\n将列表ls中的元素反转\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls.append(1234)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024, 1234]&gt;&gt;&gt; ls.insert(3, &quot;human&quot;)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;, 1024, 1234]&gt;&gt;&gt; ls.reverse()[1234, 1024, &#x27;human&#x27;, &#x27;tiger&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;]\n\n应用场景\n元组用于元素不改变的应用场景，更多用于固定搭配场景\n列表更加灵活，它是最常用的序列类型\n最主要作用：表示一组有序数据，进而操作它们\n元素遍历:for item in ls :    &lt;语句块&gt;\n数据保护：如果不希望数据被程序所改变，转换成元组类型&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; lt = tuple(ls)&gt;&gt;&gt; lt(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024)\n\n小结\n序列是基类类型，扩展类型包括：字符串、元组和列表\n元组用()和tuple()创建，列表用[]创建\n元组操作与序列操作基本相同\n列表操作在序列操作基础上，增加了更多的灵活性\n\n字典类型字典类型定义\n字典类型是“映射的体现”\n键值对：键是数据索引的扩展\n字典是键值对的集合，键值对之间无序\n采用大括号{}和dict()创建，键值对用冒号表示\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d&#123;&#x27;中国&#x27;: &#x27;北京&#x27;, &#x27;美国&#x27;: &#x27;华盛顿&#x27;, &#x27;法国&#x27;: &#x27;巴黎&#x27;&#125;&gt;&gt;&gt; d[&quot;中国&quot;]&#x27;北京&#x27;&gt;&gt;&gt; de = &#123;&#125; &gt;&gt;&gt; type(de)&lt;class &#x27;dict&#x27;&gt;\n\n字典类型操作方法\n\n\n函数或方法\n描述\n\n\n\ndel d[k]\n删除字典d中键k对应的数据值\n\n\nk in d\n判断键k是否在字典d中，如果在返回True，否则False\n\n\nd.keys()\n返回字典d中所有的键信息\n\n\nd.values()\n返回字典d中所有的值信息\n\n\nd.items()\n返回字典d中所有的键值对信息，以元组形式返回\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; &quot;中国&quot; in dTrue&gt;&gt;&gt; d.keys()dict_keys([&#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;法国&#x27;])&gt;&gt;&gt; d.values()dict_values([&#x27;北京&#x27;, &#x27;华盛顿&#x27;, &#x27;巴黎&#x27;])\n\n字典类型操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nd.get(k, )\n键k存在，则返回相应值，不在则返回值\n\n\nd.pop(k, )\n键k存在，则取出相应值，不在则返回值\n\n\nd.popitem()\n随机从字典d中取出一个键值对，以元组形式返回\n\n\nd.clear()\n删除所有的键值对\n\n\nlen(d)\n返回字典d中元素的个数\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d.get(&quot;中国&quot;,&quot;伊斯兰堡&quot;)&#x27;北京&#x27;&gt;&gt;&gt; d.get(&quot;巴基斯坦&quot;,&quot;伊斯兰堡&quot;)&#x27;伊斯兰堡&#x27;&gt;&gt;&gt; d.popitem()(&#x27;美国&#x27;, &#x27;华盛顿&#x27;)\n\n小结\n映射关系采用键值对表达\n字典类型使用{}和dict()创建，键值对之间用 : 分隔\nd[key] 方式既可以索引，也可以赋值\n字典类型有一批操作方法和函数，例如.get()\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 学习笔记（六）","url":"/2021/04/05/python-study-notes-6/","content":"文件操作文件概述定义和分类\n定义：文件是一个存储在辅助存储器上的数据序列，可以包含任何数据内容。\n概念上:文件是数据的集合和抽象。\n优点：组织和表达数据更有效、更灵活。\n分类：文本文件和二进制文件。\n\n文本文件和二进制文件\n\n\n比较项\n文本文件\n二进制文件\n\n\n\n定义\n由文本字符为内容的文件\n直接由比特0和1组成\n\n\n字符编码\n是\n否\n\n\n读取方式\n文件经编码形成字符串，打印出含有意义的字符\n文件被解析为字节（比特）流\n\n\n表示形式\n一个字符由2个字节表示\n单一字节表示\n\n\ntextFile = open(&quot;7.1.txt&quot;,&quot;rt&quot;) #t表示文本文件方式print(textFile.readline())textFile.close()binFile = open(&quot;7-1.txt&quot;,&quot;rb&quot;)\t#r表示二进制文件方式print(binFile.readline())binFile.close()\n&gt;&gt;&gt;中国是个伟大的国家！ b&#x27;\\xd6\\xd0\\xb9\\xfa\\xca\\xc7\\xb8\\xf6\\xce\\xb0\\xb4\\xf3\\xb5\\xc4\\xb9\\xfa\\xbc\\xd2\\xa3\\xa1&#x27;\n\n文件操作文件打开和关闭\n文件打开函数: open()\n表示方法：\n&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)\n文件名可以是文件的实际名字，也可以是包含完整路径的名字。\n\n\n打开模式举例：\n\n\n\n\n打开模式\n含义\n\n\n\n‘r’\n只读模式，如果文件不存在，返回异常FileNotFoundError，默认值\n\n\n‘w’\n覆盖写模式，文件不存在则创建，存在则完全覆盖源文件\n\n\n‘x’\n创建写模式，文件不存在则创建，存在则返回异常FileExistsError\n\n\n‘a’\n追加写模式，文件不存在则创建，存在则在原文件最后追加内容\n\n\n‘b’\n二进制文件模式\n\n\n‘t’\n文本文件模式，默认值\n\n\n‘+’\n与r/w/x/a一同使用，在原功能基础上增加同时读写功能\n\n\n文件读写定义a为一文件：\n\n文件读取：\n\n\n\n\n方法\n含义\n\n\n\na.readall()\n读入整个文件内容，返回一个字符串或字节流*\n\n\na.read(size=-1)\n从文件中读入整个文件内容，如果给出参数，读入前size长度的字符串或字节流\n\n\na.readline(size = -1)\n从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流\n\n\na.readlines(hint=-1)\n从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行\n\n\n\n文件写入：\n\n\n\n\n方法\n含义\n\n\n\na.write(s)\n向文件写入一个字符串或字节流\n\n\na.writelines(lines)\n将一个元素为字符串的列表写入文件\n\n\na.seek(offset)\n改变当前文件操作指针的位置，offset的值： 0：文件开头； 1: 当前位置； 2: 文件结尾\n\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 实验一 Python运行环境搭建及使用","url":"/2021/04/05/python-experiment-1/","content":"实验目的\n熟悉 Python 开发环境的使用\n熟悉 Python 应用程序的创建与运行\n掌握 Python 输入与输出实验内容练习一题目分别用交互模式和批量模式完成以下代码的练习。str1=input(&quot;请输入一个人的名字：&quot;)str2=input(&quot;请输入一个国家的名字：&quot;)print(&quot;世界这么大，&#123;&#125;想去&#123;&#125;看看&quot;.format(str1,str2))\n练习二题目整数序列求和：用户输入一个正整数 N,计算从 1 到 N(包含 1 和 N)相加之后的结果。代码N = input(&quot;请输入一个正整数N：&quot;)sum = 0for i in range (int(N)):    sum += i + 1print(&quot;1到N相加后的结果为：&quot;,sum)\n练习三题目健康食谱输出：列出 5 种不同的食材，输出它们可能组成的所有菜式名称。代码array = [&#x27;土豆&#x27;,&#x27;豇豆&#x27;,&#x27;辣椒&#x27;,&#x27;五花肉&#x27;,&#x27;豆腐&#x27;]for i in range(0,5):    for j in range(0,5):        if not(i==j):            print(&quot;&#123;&#125;&#123;&#125;&quot;.format(array[i],array[j]))\n练习四题目太阳花的绘制：使用 turtle 库绘制一个太阳花的图形，如下图所示。￼代码from turtle import *color(&#x27;red&#x27;,&#x27;yellow&#x27;)begin_fill()while True:    forward(200)    left(170)    if abs(pos())&lt;1:        breakend_fill()done()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十 Tkinter的使用（1）","url":"/2021/04/05/python-experiment-10/","content":"实验目的\n掌握 tkinter 的使用\n熟悉可视化界面的设计方法实验内容题目完成以下代码，熟悉 tkinter 各个部件的使用代码#(1) 创建主窗口及 Label 部件（标签）创建使用import tkinter as tk# SY11-1window = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)l = tk.Label(window,text =&#x27;你好！欢迎使用Python tkinter!&#x27;,bg = &#x27;AliceBlue&#x27;,font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()window.mainloop()#（2）Button 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)var = tk.StringVar()l = tk.Label(window,textvariable = var,bg = &#x27;AliceBlue&#x27;,    font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()on_hit = Falsedef touch():    global on_hit    if on_hit == False:        on_hit = True        var.set(&#x27;你点击了确认按钮&#x27;)    else:        on_hit = False        var.set(&#x27;&#x27;)b = tk.Button(window,text=&#x27;确认&#x27;,font=(&#x27;Arial&#x27;,12),width = 10,              height=1,command = touch)b.pack()window.mainloop()#（3）Entry 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-3&#x27;)window.geometry(&#x27;500x300&#x27;)e1 = tk.Entry(window,show=&#x27;*&#x27;,font=(&#x27;Arial&#x27;,14))e2 = tk.Entry(window,show=None,font=(&#x27;Arial&#x27;,14))e1.pack()e2.pack()window.mainloop()#（4）Text 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-4&#x27;)window.geometry(&#x27;500x300&#x27;)e = tk.Entry(window,show = None)e.pack()def insert_point():    var = e.get()    t.insert(&#x27;insert&#x27;,var)def insert_end():    var = e.get()    t.insert(&#x27;end&#x27;,var)b1 = tk.Button(window,text=&#x27;insert point&#x27;,width = 10,               height = 2,command = insert_point)b1.pack()b2 = tk.Button(window,text=&#x27;insert end&#x27;,width = 10,               height = 2,command = insert_end)b2.pack()t = tk.Text(window,height = 3)t.pack()window.mainloop()#（5）Canvas 窗口部件import tkinter as tk # 使用 Tkinter 前需要先导入window = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)canvas = tk.Canvas(window, bg=&#x27;AliceBlue&#x27;, height=200, width=500)image_file = tk.PhotoImage(file=&#x27;123.gif&#x27;)image = canvas.create_image(250, 0, anchor=&#x27;n&#x27;,image=image_file)x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0-50, y0-50, x1-50, y1-50)oval = canvas.create_oval(x0+120, y0+50, x1+120, y1+50, fill=&#x27;yellow&#x27;)arc = canvas.create_arc(x0, y0+50, x1, y1+50, start=0, extent=180)rect = canvas.create_rectangle(330, 30, 330+20, 30+20)canvas.pack()def moveit():    canvas.move(rect, 2, 2)b = tk.Button(window, text=&#x27;move item&#x27;,command=moveit).pack()window.mainloop()#（6）messageBox 窗口部件import tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)def hit_me(): tkinter.messagebox.showinfo(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;) # tkinter.messagebox.showwarning(title=&#x27;Hi&#x27;, message=&#x27;有警告！&#x27;) # 提出 # tkinter.messagebox.showerror(title=&#x27;Hi&#x27;, message=&#x27;出错了！&#x27;) # 提出错 # print(tkinter.messagebox.askquestion(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # 询问选择对话窗 return &#x27;yes&#x27;, &#x27;no&#x27; # print(tkinter.messagebox.askyesno(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27; # print(tkinter.messagebox.askokcancel(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27;tk.Button(window, text=&#x27;hit me&#x27;, bg=&#x27;green&#x27;, font=(&#x27;Arial&#x27;, 14), command=hit_me).pack()window.mainloop()#（7）窗口部件三种放置方式 pack/grid/place#7-1import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)for i in range(3):    for j in range(3):        tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10,ipadx=10, ipady=10)window.mainloop()#7-2import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;top&#x27;) # 上tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;bottom&#x27;) # 下tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;left&#x27;) # 左tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;right&#x27;) # 右window.mainloop()#7-3import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;Pl&#x27;, font=(&#x27;Arial&#x27;, 20), ).place(x=50, y=100, anchor=&#x27;nw&#x27;)window.mainloop()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十二 数据分析与可视化（1）","url":"/2021/04/05/python-experiment-12/","content":"实验目的1、 熟悉 numpy 库常用方法的使用2、 熟悉 pandas 库的基本使用3、 能够利用 matplotlib 库进行简单的图形绘制\n实验内容题目根据某商品近 5 年的销售流水，做数据分析和可视化。模拟产生数据代码如下：￼\n（1）编写程序生成某商品(2014-01-01 到 2018-12-31)的销售流水，模拟数据文件名为 data.csv，数据格式如下：（说明：日期是连续的，销量是随机数，单价范围为[101，105]的随机值）￼\n代码import randomimport datetimeimport csvfn = &#x27;data.csv&#x27;with open(fn,&#x27;w&#x27;) as fp:    wr = csv.writer(fp)    wr.writerow([&#x27;日期&#x27;,&#x27;销量&#x27;,&#x27;单价&#x27;])    startDate = datetime.date(2014,1,1)    for i in range(1825):        amount = 300+i*5+random.randrange(100)        price = 100+random.randint(1,5)        wr.writerow([str(startDate),amount,price])        startDate = startDate+datetime.timedelta(days=1)\n（2）使用 pandas 读取文件 data.csv 中的数据，创建 DataFrame 对象，并删除其中所有缺失值；代码import pandas as pddf = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()\n（3）使用 matplotlib 生成折线图，反映每月的销量情况，并把图形保存为本地文件 one.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:7])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot()plt.savefig(&#x27;one.jpg&#x27;)plt.show()\n结果￼\n（4）按年进行统计，使用 matplotlib 绘制柱状图显示每年的营业额，并把图形保存为本地文件 two.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;two.jpg&#x27;)plt.show()\n结果￼\n（5）按年进行统计，使用 matplotlib 绘制柱状图显示每年销售量最大的月份及销售额，并把图形保存为本地文件 three.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).max()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;three.jpg&#x27;)plt.show()\n结果￼\n（6）按年度统计该商品的营业额数据，使用 matplotlib 生成饼状图显示每年都的营业额分布情况，并把图形保存为本地文件 four.jpg。代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.pie(subplots=True)plt.savefig(&#x27;four.jpg&#x27;)plt.show()\n结果￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十一 Tkinter的使用（2）","url":"/2021/04/05/python-experiment-11/","content":"实验目的掌握界面程序的设计\n实验内容练习一题目：用户登陆界面程序编写一个用户登录界面，用户可以登录账户信息，如果账户已经存在，可以直接登录，登录名或者登录密码输入错误会提示，如果账户不存在，提示用户注册，点击注册进去注册页面，输入注册信息，确定后便可以返回登录界面进行登录。\n代码import pickleimport tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;登 录&#x27;)window.geometry(&#x27;500x400&#x27;)l1 = tk.Label(window,text=&#x27;用户名：&#x27;,font= 12).place(x=100,y=82)l2 = tk.Label(window,text=&#x27;密  码：&#x27;,font= 12).place(x=100,y=152)var_user_name = tk.StringVar()entry_user_name = tk.Entry(window,textvariable=var_user_name,font= 18,width=30,bd =5)entry_user_name.place(x=180,y=80)var_user_password = tk.StringVar()entry_user_password = tk.Entry(window,textvariable=var_user_password,show=&#x27;*&#x27;,font= 18,width=30,bd =5)entry_user_password.place(x=180,y=150)def user_login_in():    user_name = var_user_name.get()    user_password = var_user_password.get()    try:        with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:            user_info = pickle.load(user_file)    except FileNotFoundError:        with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:            user_info = &#123;&#x27;admin&#x27;:&#x27;admin&#x27;&#125;            pickle.dump(user_info,user_file)    if user_name ==&#x27; &#x27; or user_password == &#x27; &#x27;:        tk.messagebox.showerror(message=&#x27;用户名或密码不能为空！&#x27;)    elif user_name in user_info:        if user_password == user_info[user_name]:            tk.messagebox.showinfo(title=&#x27;welcome&#x27;,message=&#x27;欢迎您：&#x27;+user_name)        else:            tk.messagebox.showerror(message=&#x27;密码错误！&#x27;)    else:        is_signup = tk.messagebox.askyesno(&#x27;欢迎&#x27;,&#x27;您还没有注册，是否现在注册&#x27;)        if is_signup:            user_sign_up()def user_sign_up():    def registration():        input_name = new_name.get()        input_password = new_password.get()        input_password_confirm =new_password_confirm.get()        try:            with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:                exist_user_info = pickle.load((user_file))        except FileNotFoundError:            exist_user_info = &#123;&#125;        if input_name in exist_user_info:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名已存在！&#x27;)        elif input_password ==&#x27;&#x27; or input_name ==&#x27;&#x27;:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名或密码不能为空！&#x27;)        elif input_password != input_password_confirm:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;密码前后不一致！&#x27;)        else:            exist_user_info[input_name] = input_password            with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:                pickle.dump(exist_user_info,user_file)            tk.messagebox.showinfo(&#x27;欢迎&#x27;,&#x27;注册成功！&#x27;)            window_sign_up.destroy()    window_sign_up = tk.Toplevel(window)    window_sign_up.geometry(&#x27;350x200&#x27;)    window_sign_up.title(&#x27;注册&#x27;)    new_name = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;用户名：&#x27;).place(x=10,y=10)    tk.Entry(window_sign_up,textvariable=new_name).place(x=150,y=10)    new_password = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请输入密码：&#x27;).place(x=10,y=50)    tk.Entry(window_sign_up,textvariable=new_password,show=&#x27;*&#x27;).place(x=150,y=50)    new_password_confirm = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请再次确认密码：&#x27;).place(x=10,y=90)    tk.Entry(window_sign_up,textvariable=new_password_confirm,show=&#x27;*&#x27;).place(x=150,y=90)    bt_confirm_sign_up = tk.Button(window_sign_up,text=&#x27;确认注册&#x27;,command=registration)    bt_confirm_sign_up.place(x=150,y=130)def user_sign_out():    window.destroy()bt_login = tk.Button(window,text=&#x27;登    录&#x27;,width=30,font= 18,bg=&#x27;DarkTurquoise&#x27;,activebackground=&#x27;Turquoise&#x27;,command=user_login_in)bt_login.place(x=150,y=210)bt_register = tk.Button(window,text=&#x27;注册&#x27;,width=25,command= user_sign_up)bt_register.place(x=150,y=270)bt_exit = tk.Button(window,text=&#x27;退出&#x27;,width=5,command = user_sign_out)bt_exit.place(x=350,y=270)window.mainloop()\n练习二题目：tkinter 版猜数游戏使用 Python 标准库 tkinter 编写 GUI 版本的猜数游戏。 每次猜数之前要启动游戏并设置猜数范围和最大猜测次数等参数， 退出游戏时显示战绩（共玩几次， 猜对几次） 信息。\n代码import tkinter as tkimport randomnumber = random.randint(0,1024)running = Truenum = 0num_max = 1024num_min = 0def eBtnClose(event):    root.destory()def eBtnGuess(evnet):    global num_max    global num_min    global num    global running    if running:        val_a = int(entry_a.get())        if val_a ==number:            labelqval(&quot;恭喜你答对啦！&quot;)            num +=1            running =False            numGuess()        elif val_a &lt;number:            if val_a &gt;num_min:                num_min = val_a                num +=1                label_tip_min.config(label_tip_min,text=num_min)            labelqval(&quot;小了哦&quot;)        else:            if val_a &lt; num_max:                num_max = val_a                num +=1                label_tip_max.config(label_tip_max,text=num_max)            labelqval(&quot;大了哦&quot;)    else:        labelqval(&#x27;你已经答对了&#x27;)def numGuess():    if num ==1:        labelqval(&#x27;居然一次就答对了&#x27;)    elif num&lt;10:        labelqval(&#x27;十次以内就答对了，继续加油！尝试次数为：&#x27;+str(num))    elif num&lt;50:        labelqval(&#x27;很不错！尝试次数为：&#x27;+str(num))def labelqval(vText):    label_val_q.config(label_val_q,text=vText)root = tk.Tk(className=&quot;猜数游戏&quot;)root.geometry(&quot;400x50&quot;)line_a_tip = tk.Frame(root)label_tip_max = tk.Label(line_a_tip,text=num_max)label_tip_min = tk.Label(line_a_tip,text=num_min)label_tip_max.pack(side=&quot;top&quot;,fill=&quot;x&quot;)label_tip_min.pack(side=&quot;bottom&quot;,fill=&quot;x&quot;)line_a_tip.pack(side=&quot;left&quot;,fill=&quot;y&quot;)line_question = tk.Frame(root)label_val_q = tk.Label(line_question,width=&quot;80&quot;)label_val_q.pack(side=&quot;left&quot;)line_question.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_input = tk.Frame(root)entry_a =tk.Entry(line_input,width=&quot;40&quot;)btnGuess = tk.Button(line_input,text = &quot;猜&quot;)entry_a.pack(side=&quot;left&quot;)entry_a.bind(&#x27;&lt;Return&gt;&#x27;,eBtnGuess)btnGuess.bind((&#x27;&lt;Button-1&gt;&#x27;),eBtnGuess)btnGuess.pack(side=&quot;left&quot;)line_input.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_btn = tk.Frame(root)btnClose = tk.Button(line_btn,text=&quot;关闭&quot;)btnClose.bind(&#x27;&lt;Button-1&gt;&#x27;,eBtnClose)btnClose.pack(side=&quot;left&quot;)line_btn.pack(side=&quot;top&quot;)labelqval(&quot;请输入0到1024之间任意整数：&quot;)entry_a.focus_set()root.mainloop()\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十三 数据分析与可视化（2）","url":"/2021/04/05/python-experiment-13/","content":"实验目的1、 掌握第三方库 TuShare 的数据获取方法2、 能够利用 pandas 库进行简单的数据分析3、 能够利用 matplotlib 库进行数据可视化4、 综合应用上述第三方库解决问题的能力\n实验内容一、读取 stock_hist_data.csv 中招商银行（股票代码 600036）2018 年下半年的股票数据并完成如下数据处理和分析任务：(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。(2) 输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；(3) 列出成交量（volume）在 1000000 以上的记录；(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。data_frame = pd.DataFrame(pd.read_csv(&#x27;stock_hist_data.csv&#x27;).iloc[:,:6])data_frame = data_frame.sort_values(&#x27;date&#x27;,ascending=True)data_frame.close.plot()plt.title(&quot;收盘价(close)的走势图&quot;)plt.savefig(&#x27;收盘价(close)的走势图.jpg&#x27;)plt.show()#（2）输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；data_volume_max_index = data_frame.volume.idxmax()data_volume_max = data_frame.loc[data_volume_max_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].values# print(data_volume_max_index)data_volume_min_index = data_frame.volume.idxmin()data_volume_min = data_frame.loc[data_volume_min_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].valuesprint(&quot;半年成交量中&#123;&#125;这一天最高，为&#123;&#125;。\\n&quot;.format(data_volume_max[0],data_volume_max[1]))print(&quot;半年成交量中&#123;&#125;这一天最低，为&#123;&#125;。\\n&quot;.format(data_volume_min[0],data_volume_min[1]))#(3) 列出成交量（volume）在 1000000 以上的记录；data_volume_more_than_1000000 = data_frame[data_frame.volume &gt; 1000000]print(&quot;成交量在1000000以上的记录为：\\n&quot;,data_volume_more_than_1000000)#(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；data_frame_count = data_frame[data_frame.close &gt; data_frame.open][&#x27;date&#x27;].count()print(&quot;收盘价高于开盘价的天数共有：&#123;&#125;天\\n&quot;.format(data_frame_count))#(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。data_frame_5 = data_frame.loc[:,[&#x27;date&#x27;,&#x27;close&#x27;]]data_frame_5[&#x27;date&#x27;] = data_frame_5[&#x27;date&#x27;].apply(lambda x:x[:7])data_frame_5_close_average = data_frame_5.groupby(&#x27;date&#x27;).mean()# print(data_frame_5_close_average)data_frame_5_close_average.plot.bar()plt.title(&quot;每月收盘价(close)的平均值&quot;)plt.savefig(&#x27;average.jpg&#x27;)plt.show()\n结果（1）（5）\n二、读取“2018 世界杯球队数据.csv”，实现如下功能：(1) 输出净胜球大于 0 的球队；(2) 输出被罚红牌的球队；(3) 输出进球成功率超过 10%的球队以及进球数和射门数；(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；(5) 按照进球数降序输出所有球队及进球信息；(6) 按照所属区进行分组，按升序统计输出每个区的进球数；(7) 按照所属区进行分组，绘制每个区进球数的条形图；(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 输出净胜球大于 0 的球队；data_frame = pd.DataFrame(pd.read_csv(&#x27;2018世界杯球队数据.csv&#x27;,encoding=&#x27;gbk&#x27;))data_frame_1 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;失球&#x27;]]data_frame_1_win_goal = data_frame_1[&#x27;进球&#x27;] - data_frame_1[&#x27;失球&#x27;]data_frame_1[&#x27;净胜球&#x27;] = data_frame_1_win_goaldata_frame_1 = data_frame_1[data_frame_1.净胜球 &gt;0]data_frame_1_final = data_frame_1.loc[:,[&#x27;球队&#x27;,&#x27;净胜球&#x27;]]data_frame_1_name = data_frame_1_final[&#x27;球队&#x27;].valuesprint(&#x27;净胜球大于0的球队有：&#x27;,end=&#x27;&#x27;)for i in data_frame_1_name:    print(i,end=&#x27; &#x27;)#(2) 输出被罚红牌的球队；data_frame_2 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;红牌&#x27;]]data_frame_2 = data_frame_2[data_frame_2.红牌 &gt; 0].valuesprint(&#x27;被罚红牌的队伍有:&#x27;)for i in data_frame_2:    print(i[0],end=&#x27; &#x27;)#（3）输出进球成功率超过 10%的球队以及进球数和射门数；data_frame_3 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;射门&#x27;]]data_frame_3_goalrate = data_frame_3[&#x27;进球&#x27;] / data_frame_3[&#x27;射门&#x27;]*100data_frame_3[&#x27;进球率&#x27;] = data_frame_3_goalratedata_frame_3 = data_frame_3[data_frame_3.进球率 &gt; 10]data_frame_3.drop(labels=&#x27;进球率&#x27;,axis=1,inplace=True)print(data_frame_3)#(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；data_frame_4 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;黄牌&#x27;]]data_frame_4_TotalGoalAverage = data_frame_4[&#x27;进球&#x27;].mean()# print(data_frame_4_TotalGoalAverage)data_frame_4 = data_frame_4[(data_frame_4.进球 &gt; data_frame_4_TotalGoalAverage) &amp; (data_frame_4.黄牌 &lt; 5)]print(data_frame_4)#(5) 按照进球数降序输出所有球队及进球信息；data_frame_5 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_5.sort_values(by=&#x27;进球&#x27;,ascending=False,inplace=True)print(data_frame_5)#(6) 按照所属区进行分组，按升序统计输出每个区的进球数；data_frame_6 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_6_final = data_frame_6.groupby(&#x27;所属洲&#x27;).sum()data_frame_6_final.sort_values(by=&#x27;进球&#x27;,inplace=True)print(data_frame_6_final)#(7) 按照所属区进行分组，绘制每个区进球数的条形图；data_frame_7 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_7_final = data_frame_7.groupby(&#x27;所属洲&#x27;).sum()data_frame_7_final.plot.bar()plt.title(&#x27;各大洲进球数&#x27;)plt.show()#(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。data_frame_8 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;抢断&#x27;,&#x27;射门&#x27;]]data_frame_8 = data_frame_8[data_frame_8.所属洲 == &#x27;欧洲&#x27;]data_frame_8_bar = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_8_pie = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;抢断&#x27;]]data_frame_8_plot = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;射门&#x27;]]# print(data_frame_8_bar)plt.subplot(221)plt.title(&#x27;欧洲球队抢断数&#x27;)plt.scatter(data_frame_8_pie[&#x27;抢断&#x27;],data_frame_8_pie[&#x27;球队&#x27;])plt.subplot(222)plt.title(&#x27;欧洲球队射门次数占比&#x27;)plt.pie(data_frame_8_plot[&#x27;射门&#x27;],labels=data_frame_8_plot[&#x27;球队&#x27;])plt.subplot(212)plt.title(&#x27;欧洲球队进球数&#x27;)plt.bar(data_frame_8_bar[&#x27;球队&#x27;],data_frame_8_bar[&#x27;进球&#x27;])plt.show()\n结果（6）（7）￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十四 网络爬虫基础（1）","url":"/2021/04/05/python-experiment-14/","content":"实验目的1、网络爬虫的基本原理与规范。2、掌握使用 Requests 库获取静态网页信息。3、掌握使用 BeautifulSoup4 库解析网页信息。4、掌握正则表达式的基本用法。\n实验内容题目 中国大学排名定向爬虫(1) 查看 https://www.shanghairanking.cn/rankings/bcur/2020 网页中关于各大学排名的信息组织(F12 快捷键查阅 html 代码)(2)使用 requests、beautifulsoup4 或 re 库抓取并解析排名，输出各大学的排名信息，如下图所示。￼\n代码import requestsfrom bs4 import BeautifulSoupimport  bs4def getHTMLText(url):    try:        r = requests.get(url,timeout=30)        r.raise_for_status()        r.encoding = &#x27;utf-8&#x27;        return r.text    except:        return &quot;&quot;def fillUniviList(ulist,html):    soup = BeautifulSoup(html,&quot;html.parser&quot;)    for tr in soup.find(&#x27;tbody&#x27;).children:        if isinstance(tr,bs4.element.Tag):            tds = tr(&#x27;td&#x27;)            ulist.append([tds[0].text,tds[1].text,tds[4].text])def printUnivList(ulist,num):    tplt = &quot;&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;&quot;    print(tplt.format(&quot;排名&quot;,&quot;学校排名&quot;,&quot;总分&quot;,chr(12288)))    for i in range(num):        u = ulist[i]        print(tplt.format(u[0].strip(),u[1].strip(),u[2].strip(),chr(12288)))def main():    uinfo = []    url = &#x27;https://www.shanghairanking.cn/rankings/bcur/2020&#x27;    html = getHTMLText(url)    fillUniviList(uinfo,html)    printUnivList(uinfo,20)main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验二 字符串及基本数据类型操作","url":"/2021/04/05/python-experiment-2/","content":"实验目的1．掌握字符串编码、索引方式2．掌握字符串的操作3．掌握字符串格式化4．掌握基本数据类型的运算操作\n实验内容练习一题目完成以下代码练习，熟悉字符串的相关使用。\n略\n练习二题目输出由任意字符串堆积的 10 行等腰三角形。其中，str.center()方法用于字符串两边填充：str.rjust(width[,fillchar])方法用于字符串右填充。\n代码width = 2*10-1for i in range(1,11):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width,&#x27; &#x27;))\n运行结果￼\n练习三题目能力值的计算：一年 365 天，以第 1 天的能力值为基数，记为 1.0，当每天好好学习时能力值相比前一天提高 1‰，当没有学习时由于遗忘等原因能力值相比前一天下降 1‰，完成下列能力值的计算：(1) 每天努力和每天放任，一年下来的能力值分别多少？(2) 一周 5 个工作日，如果每个工作日都好好学习，在周末放任一下，计算 1 年后的能力值。\n代码#（1）dayfactor = 0.0001dayup = pow(1+dayfactor,365)daydown = pow(1-dayfactor,365)print(&quot;每天努力：&#123;:.3f&#125;,每天放任：&#123;:.3f&#125;&quot;.format(dayup,daydown))#（2）dayfactor = 0.0001dayup = 1.0for i in range(365):    if i%7 in [6,0]:        dayup = dayup*(1-dayfactor)    else:        dayup = dayup*(1+dayfactor)print(&quot;1年后的能力值&#123;:.2f&#125;&quot;.format(dayup))\n练习四题目凯撒密码：设想在某些情况下给朋友传递字条信息，但又不希望传递中途被第三方看懂这些信息，因此需要对字条信息进行加密处理。凯撒密码采用了替换算法对信息中的每一个英文字符循环替换为该字符后面第三个字符，对应关系如下：原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C其它字符保持不变。编程实现：程序接收用户输入待加密的信息，输出加密后的密文。\n代码enter_code = input(&quot;请输入一段信息：&quot;)encode = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;output_code = &quot;&quot;for c in enter_code:    if c in enter_code:        index = encode.index(c)        index += 3        index %= len(encode)        output_code += encode[index]    else:        output_code += cprint(&quot;加密后的密文为：&quot;,output_code)\n练习五题目文本进度条：参考教材，使用字符串完成进度条的设计。要求：(1) 显示当前进度的百分比；(2) 动态刷新显示当前的进度。\n代码import timescale = 50print(&quot;执行开始&quot;.center(scale//2,&#x27;-&#x27;))t = time.clock()for i in range(scale+1):    a = &#x27;*&#x27; * i    b = &#x27;.&#x27; * (scale-i)    c = (i/scale) * 100    t -= time.clock()    print(&quot;\\r&#123;:^.3f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,-t),end=&#x27;&#x27;)    time.sleep(0.05)print(&quot;\\n&quot;+&quot;执行结束&quot;.center(scale//2,&#x27;-&#x27;))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验三 程序的控制结构（分支）","url":"/2021/04/05/python-experiment-3/","content":"实验目的1、掌握程序的单分支结构2、掌握程序的双分支结构3、掌握程序的多分支结构4、掌握 if 的嵌套\n实验内容练习一题目：身体质量指数 BMIBMI 值可以“客观的”衡量个人的肥胖程度或者说健康程度。世界卫生组织（WHO）根据对全球人口体重的统计认为，BMI 值低于 18.5 kg/m2 时属于“过轻”，表明个体可能营养不良或者饮食无法保障；BMI 值高于 25 kg/m2 时属于“过重”。根据下表所示指标编程测试自己的身体指数状况。￼\n代码height ,weight = eval(input(&quot;请输入身高（米）和体重（公斤）[逗号隔开]：&quot;))bmi = weight / pow(height,2)print(&quot;BMI 指数为：&#123;:.2f&#125;&quot;.format(bmi))who,dom=&quot;&quot;,&quot;&quot;if bmi &lt; 18.5:\twho,dom = &quot;偏瘦&quot;,&quot;偏瘦&quot;elif 18.5&lt;= bmi &lt; 24:\twho, dom = &quot;正常&quot;, &quot;正常&quot;elif 24&lt;= bmi &lt; 25:\twho, dom = &quot;正常&quot;, &quot;偏胖&quot;elif 25&lt;= bmi &lt; 28:\twho, dom = &quot;偏胖&quot;, &quot;偏胖&quot;elif 28&lt;= bmi &lt; 30:\twho, dom = &quot;偏胖&quot;, &quot;肥胖&quot;else:\twho, dom = &quot;肥胖&quot;, &quot;肥胖&quot;print(&quot;BMI 指标为：国际&#x27;&#123;0&#125;&#x27;，国内&#x27;&#123;1&#125;&#x27;&quot;.format(who,dom))\n练习二题目：学生成绩等级判断编程实现输入学生成绩 score，得出其等级状况 grade,其对应关系如下：100&gt;=Score&gt;=85 grade=”A”70&lt;=Score&lt;85 grade=”B”60&lt;=Score&lt;70 grade=”C”0&lt;Score&lt;60 grade=”D”Score&gt;100 或 Score&lt;0 给出出错提示\n代码score = input(&quot;请输入你的成绩：&quot;)try:\tscore = eval(score)\tif score &lt; 0 or score &gt; 100: 5. print(&quot;成绩输入有误，请重新输入&quot;)\telse:\t\tif 0 &lt;= score &lt; 60:\t\t\tgrade = &quot;D&quot;\t\telif 60 &lt;= score &lt; 70:\t\t\tgrade = &quot;C&quot;\t\telif 70 &lt;= score &lt; 85:\t\t\tgrade = &quot;B&quot;\t\telif 85 &lt;= score &lt;= 100:\t\t\tgrade = &quot;A&quot; 15. print(&quot;你的成绩属于&#123;&#125;级别&quot;.format(grade))except NameError:\tprint(&quot;输入错误，请输入一个整数！&quot;)\n练习三题目：猜数游戏在程序中预设一个 0-9 之间的整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\t    print(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\t    exit()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验四 程序的控制结构（循环）","url":"/2021/04/05/python-experiment-4/","content":"实验目的1、掌握程序的几种循环结构及扩展用法2、掌握 break 和 continue 的用法3、掌握 random 库的用法4、了解程序的异常处理及用法\n实验内容练习一题目：统计不同字符个数用户从键盘输入一行字符，编写一个程序，统计并输出其中英文字符、数字、空格和其它字符的个数。\n代码charts = input(&quot;请输入一行字符：&quot;)english = num = space = other = 0for i in charts:\tif &#x27;0&#x27;&lt;= i &lt;= &#x27;9&#x27;:\t\tnum += 1\telif (&#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;) or (&#x27;A&#x27; &lt;= i &lt;=&#x27;Z&#x27;):\t\tenglish += 1\telif i == &#x27; &#x27;:\t\tspace += 1\telse:\t\tother += 1print(&quot;在你输入的字符串中：英文字符有&#123;&#125;个，数字有&#123;&#125;个，空格有&#123;&#125;个，其他字符有&#123;&#125;个&quot;.format(english,num,space,other))\n练习二题目：猜数游戏续在上一次猜游戏实验题目的基础上，完善程序，实现如下的功能：系统自动生成 1-100 以内的随机整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。如果用户输入的不是整数，而是小数，则提示用户“输入错误，必须输入整数！”，并让用户重新输入。如果用户输入的不是数字，则给出出错提示“输入格式错误，结束程序！”\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\tprint(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\texit()\n练习三题目：最大公约数计算从键盘接收两个整数，编写程序求出这两个整数的最大公约数和最小公倍数（提示：用辗转相除法求最大公约数，用两数乘积除以最大公约数求得最小公倍数）\n代码num1,num2 = eval(input(&quot;请输入两个整数(逗号隔开输入)：&quot;))greatest_common_divisor = 0least_common_multiple = 0def Calculation(a,b):\tif b == 0:\t\treturn a\t\treturn Calculation(b,a%b)if num1 &lt; num2:\ttemp = num1\tnum1 = num2\tnum2 = tempgreatest_common_divisor = Calculation(num1,num2)least_common_multiple = num2 * num1 / greatest_common_divisorprint(&quot; 两 数 的 最 大 公 约 数 为 &#123;&#125; ， 最 小 公 倍 数 为&#123;:.0f&#125;&quot;.format(greatest_common_divisor,least_common_multiple))\n练习四题目请编写程序实现如下数字金字塔的显示：￼\n代码s = &#x27;&#x27;for i in range(1,10):\ts = s + str(i)\tleft_part = s[::-1]\tright_part = s[1:]\tstrs = left_part + right_part\tprint(strs.center(17,&quot; &quot;))\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验五 组合数据类型","url":"/2021/04/05/python-experiment-5/","content":"实验目的1、理解组合数据类型的概念2、掌握列表、字典与集合的定义和使用方法3、熟练 random 模块的应用\n实验内容练习一题目编写程序，在 26 个字母大小写和 10 个数字组成的列表中随机生成 10个 8 位密码。\n代码#设置的密码没有重复的元素import randomList =[]#存入字母和数字for i in range(26):\tList.append(chr(ord(&#x27;A&#x27;)+i))\tList.append(chr(ord(&#x27;a&#x27;)+i))for i in range(10):\tList.append(str(i))#随机生成 10 个 8 位数的密码for i in range(10):\tpassword_List = random.sample(List,8) #生成结果仍为列表\tpassword = &quot;&quot;.join(password_List) #将列表转化成字符串\tprint(password)\n练习二题目通过键盘输入系列整数值，输入 0 则表示输入结束，将这些值（不含 0）建立为一个列表，并按从大到小的顺序输出该列表各元素。\n代码List = []num = eval(input(&quot;请输入一个整数：&quot;))while num != 0:\tList.append(num)\tnum = eval(input(&quot;请输入一个整数：&quot;))List.sort(reverse = True)for i in range(len(List)):\tprint(List[i])\n练习三题目输入一个大于 2 的自然数， 输出小于该数字的所有素数组成的集合。\n代码import mathdef isprime(n):\tfor i in range(2,n):\t\tif n % i ==0:\t\t\treturn False\t\telse:\t\t\treturn Truenum_input = eval(input(&quot;请输入一个大于 2 的自然数：&quot;))num = math.ceil(num_input)prime_set = set()for i in range(2,num):\tif isprime(i):\t\tprime_set.add(i)\tprint(&quot;小于&#123;&#125;的所有素数集合是：&#123;&#125;&quot;.format(num_input,prime_set))\n练习四题目使用字典来创建程序，提示用户输入电话号码，并用英文单词形式显示数字。例如：输入 138 则显示“one three eight”。\n代码num = [i for i in range(10)]word = [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;]phone_list = dict(zip(num,word))phone_num = input(&quot;请输入电话号码：&quot;)result=&quot;&quot;#print(phone_num)for i in phone_num:\tphone_i = eval(i)\tfor key in phone_list:\t\tif phone_i == key:\t\t\tresult += phone_list[key] + &quot; &quot;print(result)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验六","url":"/2021/04/05/python-experiment-6/","content":"实验目的1、 培养分析问题并对进行建模的能力。2、 熟练使用组合数据类型解决实际问题。3、 熟练运用选择结构和循环结构解决实际问题。\n实验内容练习一题目统计《三国演义》中人物出场次数最多的前 20 人。\n代码import jieba as jietext = (open(&#x27;三国演义.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)).read()words = jie.lcut(text)nowords =&#123;&quot;这个&quot;,&quot;引兵&quot;,&quot;次日&quot;,&quot;人马&quot;,&quot;不知&quot;,&quot;汉中&quot;,&quot;众将&quot;,&quot;只见&quot;,&quot;大喜&quot;,&quot;天下&quot;,&quot;东吴&quot;,&quot;于是&quot;,&quot;今日&quot;,&quot;不敢&quot;,&quot;魏兵&quot;,&quot;陛下&quot;,&quot;太守&quot;,&quot;天子&quot;,&quot;一面&quot;,&quot;原来&quot;,&quot;令人&quot;,&quot;江东&quot;,&quot;喊声&quot;,&quot;下马&quot;,&quot;何不&quot;,&quot;大军&quot;,&quot;忽报&quot;,&quot;先生&quot;,&quot;百姓&quot;,&quot;然后&quot;,&quot;何故&quot;,&quot;先锋&quot;,&quot;不如&quot;,&quot;赶来&quot;,&quot;此人&quot;,&quot;夫人&quot;,&quot;先主&quot;,&quot;后人&quot;,&quot;背后&quot;,&quot;城中&quot;,&quot;蜀兵&quot;,&quot;上马&quot;,&quot;大叫&quot;,&quot;都督&quot;,&quot;一人&quot;,&quot;如何&quot;,&quot;商议&quot;,&quot;却说&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;,&quot;将军&quot;,&quot;二人&quot;,&quot;后主&quot;,&quot;荆州&quot;,&quot;如何&quot;,&quot;主公&quot;,&quot;军马&quot;,&quot;军士&quot;,&quot;左右&quot;,&quot;正是&quot;,&quot;徐州&quot;,&quot;忽然&quot;,&quot;因此&quot;,&quot;成都&quot;,&quot;未知&quot;,&quot;不见&quot;,&quot;大败&quot;,&quot;大事&quot;,&quot;之后&quot;,&quot;一军&quot;,&quot;起兵&quot;,&quot;引军&quot;,&quot;军中&quot;,&quot;接应&quot;,&quot;进兵&quot;,&quot;大惊&quot;,&quot;可以&quot;,&quot;大怒&quot;,&quot;不得&quot;,&quot;以为&quot;,&quot;心中&quot;,&quot;一声&quot;,&quot;下文&quot;,&quot;曹兵&quot;,&quot;追赶&quot;&#125;counts =&#123;&#125;for word in words:\tif len(word) == 1:\t\tcontinue\telif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:\t\trword = &quot;孔明&quot;\telif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:\t\trword = &quot;刘备&quot;\telif word == &quot;孟德&quot; or word == &quot;丞相&quot;:\t\trword = &quot;曹操&quot;\telif word == &quot;关公&quot; or word == &quot;云长&quot;:\t\trword = &quot;关羽&quot;\telse:\t\trword = word\tcounts[rword] = counts.get(rword,0) + 1for word in nowords:\tdel(counts[word])items = list(counts.items())items.sort(key=lambda x:x[1],reverse = True)for i in range(20):\tword,count = items[i]\tprint(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))\n练习二题目编写程序，模拟抓狐狸小游戏。假设一共有一排 5 个洞口，小狐狸最开始的时候在其中一个洞口，然后玩家随机打开一个洞口，如果里面有狐狸就抓到了。如果洞口里没有狐狸就第二天再来抓， 但是第二天狐狸会在玩家来抓之前跳到隔壁洞口里。\n代码import random as ranflag =ran.randint(0,4)tiao = [-1,1]while True:\ttry:\t\tinp = eval(input(&quot;请输入 0-4 中任意一个数：&quot;))\texcept:\t\tprint(&quot;输入格式有误，请重新输入！&quot;)\t\tcontinue\tif inp &lt;0 or inp &gt;4:\t\tprint(&quot;输入范围有误！&quot;)\t\tcontinue\tif inp == flag:\t\tprint(&quot;找到了，游戏结束！&quot;)\t\tbreak\telse:\t\tflag += tiao[ran.randint(0,1)]\t\tflag %= 5\t\tprint(flag)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验七 阶段测试","url":"/2021/04/05/python-experiment-7/","content":"题目一打印输出如下字符图案。￼\n代码width_top = 2*6-1;width_di = 2*5-1;for i in range(1,7):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width_top,&#x27; &#x27;))for i in range(5,-1,-1):    str = &#x27;*&#x27; * (2 * i - 1)    print(str.center(width_top,&#x27; &#x27;))\n题目二输入一个年份，判断并输出该年份是否为闰年。。\n代码date = eval(input(&quot;请输入一个年份：&quot;))# print(date)if (date%100!=0 and date%4==0) or (date%400==0):    print(&quot;&#123;&#125;年是闰年&quot;.format(date))else:    print(&quot;&#123;&#125;年不是闰年&quot;.format(date))\n题目三编写一个程序，输入任意一行字符，并将其中的小写字母转换为大写字母，然后打印输出，注意：非小写字母不转换。\n代码str = input(&quot;请输入一行字符：&quot;)for i in str:    if 97&lt;=ord(i)&lt;=122:        i = chr(ord(i)-32)    print(i,end=&#x27;&#x27;)\n题目四使用turtle库画一个心形，例如：￼\n代码from turtle import *color(&#x27;red&#x27;,&#x27;pink&#x27;)begin_fill()left(140)fd(135)right(180)circle(60,-180)backward(35)right(100)forward(35)circle(-60,180)fd(135)end_fill()exitonclick()\n题目五编写一个程序来计算输入的一行字符串中的单词频率（单词不区分大小写），并按字母顺序对键进行排序，然后输出所有单词及其出现的次数。 提示：对一个字典counts内的单词按字母顺序排序，代码可以为：sorted_words = sorted(counts.keys())\n例如，输入：\nNew to Python or choosing between Python 2 and Python 3? Read Python 2 or Python 3.\n则输出为：￼\n代码str = input(&quot;请输入一行字符串：&quot;)word_dic=&#123;&#125;word =&quot;&quot;for i in str:    if 48&lt;=ord(i)&lt;=57 or 97&lt;=ord(i)&lt;=122:        word = word+i    elif 65&lt;=ord(i)&lt;=90:        i = chr(ord(i)+32)        word = word+i    else:        if word == &quot;&quot;:            continue        else:            word_value = &#123;word: 1&#125;            if (word in word_dic.keys()):                word_dic[word] += 1                word = &quot;&quot;            else:                word_dic.update(word_value)                word = &quot;&quot;sorted_word = sorted(word_dic.items(),key=lambda d:d[0])# print(sorted_word)for key,value in sorted_word:    print(&quot;&#123;&#125;:&#123;&#125;&quot;.format(key,value))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验八 函数","url":"/2021/04/05/python-experiment-8/","content":"实验目的\n掌握函数的定义与调用过程\n掌握参数的传递方式和传递过程\n理解和使用匿名函数\n理解递归调用的思想和方法\n掌握变量的作用域实验内容练习一题目定义求 n!的函数 fact()和求和函数 sum(),在此基础上编程实现 1！+2！+…m!的计算。代码def fact(num):    result = 1    for i in range(1,num+1):        result *= i    return resultdef sum(num):    result = 0    for i in range(1,num+1):        result = result + fact(i)    return resultnum=eval(input(&quot;请输入一个数m：&quot;))print(&quot;1!+2!+...+&#123;&#125;!=&#123;&#125;&quot;.format(num,sum(num)))\n练习二题目定义匿名函数实现求平方，定义判素数函数 list_prime(),该函数可以实现接受任意个数的判断，并将所有素数作为返回值。在此基础上编程实现随机输入任意个数，从中挑选出所有素数，并计算所有素数平方和。代码def list_prime(num):    sum = 0    for i in range(1,num):        if (num % i==0):            sum +=1;    if sum&gt;=2:        return 0    else:        return pingfang(num)def pingfang(num):    return num*num;str = eval(input(&quot;请随机输入任意个数(以逗号分割)：&quot;))sum = 0for i in str:    sum += list_prime(i)print(&quot;你输入的数组中所有素数的平方和为：&#123;&#125;&quot;.format(sum))\n练习三题目分别定义 numlist()和 charlist()函数，numlist()功能是生成由数字 1-26 构成的列表,charlist()功能是生成由字符 A-Z 构成的列表。在此基础上编写程序实现生成一个字典，具体如下：{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’, 5: ‘e’, 6: ‘f’, 7: ‘g’, 8: ‘h’, 9: ‘i’, 10: ‘j’, 11: ‘k’, 12: ‘l’, 13: ‘m’,14: ‘n’, 15: ‘o’, 16: ‘p’, 17: ‘q’, 18: ‘r’, 19: ‘s’, 20: ‘t’, 21: ‘u’, 22: ‘v’, 23: ‘w’, 24: ‘x’, 25: ‘y’,26: ‘z’}遍历字典，输出所有键值为偶数的元素。代码def numlist():    num= []    for i in range(1,27):        num.append(i)    return numdef charlist():    char = []    for i in range(26):        char.append(chr(ord(&#x27;A&#x27;)+i))    return chardictionary = dict(zip(numlist(),charlist()))# print(dictionary)for key in dictionary:    if key%2 ==0:        print(dictionary[key])\n练习四题目绘制科赫雪花，效果如下：￼代码import turtledef koch(size,n):    if n==0:        turtle.fd(size)    else:        for angle in [0,60,-120,60]:            turtle.left(angle)            koch(size/3,n-1)def main():    turtle.setup(600,600)    turtle.speed(0)    turtle.penup()    turtle.goto(-200,100)    turtle.pendown()    turtle.pensize(2)    level = 5    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()    turtle.exitonclick()main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验九 文件与数据格式化","url":"/2021/04/05/python-experiment-9/","content":"实验目的\n掌握文件的基本操作\n理解一、二维和高维数据的格式化过程\n掌握 csv 和 json 格式的相互转换\n综合应用组合数据类型与 CSV 和 JSON 数据格式编写简单的应用程序实验内容练习一题目将提供的 test.csv 文件，具体内容如下：￼编程读入该文件，转换成 JSON 格式文件，并以文件名 out.json 输出。转换后的结果如下所示：[ {  &quot;同比&quot;: &quot;120.7&quot;,\n  &quot;城市&quot;: &quot;北京&quot;,\n  &quot;定基&quot;: &quot;121.4&quot;,\n  &quot;环比&quot;: &quot;101.5&quot;\n\n  },  {  &quot;同比&quot;: &quot;127.3&quot;,\n  &quot;城市&quot;: &quot;上海&quot;,\n  &quot;定基&quot;: &quot;127.8&quot;,\n  &quot;环比&quot;: &quot;101.2&quot;\n\n  } ….]代码#方法一：import jsonfr = open(&quot;test.csv&quot;,&quot;r&quot;)ls = []for line in fr:    line = line.replace(&quot;\\n&quot;,&quot;&quot;)    ls.append(line.split(&#x27;,&#x27;))fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()#方法二：import jsonwith open(&quot;test.csv&quot;,&quot;r&quot;) as fr:    ls = []    for line in fr:        line = line.replace(&quot;\\n&quot;, &quot;&quot;)        ls.append(line.split(&#x27;,&#x27;))    fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()\n练习二题目编写程序制作英文学习字典，词典基本功能如下：(1) 程序读取源文件路径下的 txt 格式词典文件，若没有就创建一个。 词典文件存储方式为 “英文单词 中文单词”,每行仅有一对中英文释义；(2) 程序有添加功能，输入英文单词，如果没有可以添加中文释义，如果有就显示”已经存在，不能添加”；(3) 程序有查询功能，如果存在，则显示其中文释义，不存在就显示不存在；(4) 程序有正常退出的操作。代码import oskeys = []dic = &#123;&#125;def readdict():    if os.path.exists(&quot;dictionary.txt&quot;):        fr = open(&#x27;dictionary.txt&#x27;,&#x27;r&#x27;)    else:        fr = open(&#x27;dictionary.txt&#x27;,&#x27;w+&#x27;)    for line in fr:        line = line.replace(&quot;\\n&quot;,&quot;&quot;)        v = line.split(&#x27;:&#x27;)        dic[v[0]]= v[1]        keys.append(v[0])    fr.close()def writedict(key,value):    with open(&#x27;dictionary.txt&#x27;,&#x27;a&#x27;)as fw:        fw.write(key+&#x27;:&#x27;+value+&#x27;\\n&#x27;)def mydict():    n = input(&quot;请输入进入相应模块（添加，查询，退出）&quot;)    if n == &quot;添加&quot;:        key = input(&quot;请输入英文单词：&quot;)        if key not in keys:            value =input(&quot;字典中未找到单词&#x27;&#123;&#125;&#x27;的中文释义，请输入该单词的中文意思，添加进字典中！&quot;.format(key))            dic[key] = value            keys.append(key)            writedict(key,value)        else:            print(&quot;单词&#x27;&#123;&#125;&#x27;已存在，不能添加&quot;.format(key))        return 0    elif n == &quot;查询&quot;:        key = input(&quot;请输入英文单词:&quot;)        if key not in keys:            print(&quot;英文单词&#x27;&#123;&#125;&#x27;不在字典内&quot;.format(key))        else:            print(dic[key])        return 0    elif n == &quot;退出&quot;:        return 1    else:        print(&quot;输入有误&quot;)        return 0def main():    readdict()    while True:        n = mydict()        if n == 1:            break        if n == 0:            continuemain()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"数据库实验（一）建立数据库","url":"/2021/04/07/Database-experiment-1/","content":"实验类型设计性实验\n实验目的\n熟悉oracle环境。\n熟练掌握和使用PL-SQL建立数据库基本表。\n使用PL/SQL developer操作数据库。\n熟练掌握SQL 建立关系，及增删改数据。\n\n实验内容\n了解SQL PLUS的使用\n使用PL/SQL developer的图形界面，建立图书管理数据库orcl中的读者关系，要求创建主键约束，用户定义的完整性约束（电话号码、身份证号）。\n在建立的读者关系中输入有效数据。\n删除读者关系。\n在PL/SQL developer用SQL代码建立orcl数据库中各关系。\n用SQL 代码完成数据增、删、改。\n\n实验步骤登录数据库\n以SYSTEM登录数据库\n\n\n输入口令为你创建数据库时设置的密码\n\n\n\n\n注册用户、重新以新用户登录数据库\n\n\n\n图形化界面建表\n图书分类（图书分类号，类名）\n\n\n\n\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n\n\n预约（预约流水号，借书证号，ISBN，日期）\n\n\n\n\n\n建立数据库表：打开tables文件夹。建立以下各关系：\n图书分类（图书分类号，类名）\n\n\n\n\n图书分类号\n类名\n\n\n\n100\n文学\n\n\n200\n科技\n\n\n300\n哲学\n\n\ncreate table 图书分类(  图书分类号 NUMBER primary key,  类名    VARCHAR2(4))insert into 图书分类 (图书分类号,类名) values (100,&#x27;文学&#x27;);insert into 图书分类 values (200,&#x27;科技&#x27;);insert into 图书分类 (图书分类号,类名) values (300,&#x27;哲学&#x27;);\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\nISBN\n书名\n作者\n出版单位\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n33.80\n300\n\n\ncreate table 书目(  isbn  NUMBER primary key  书名    VARCHAR2(14),  作者    VARCHAR2(6),  出版单位  VARCHAR2(14),  单价    NUMBER,  图书分类号 NUMBER,  出版年份  NUMBER,  foreign key(图书分类号) references 图书分类(图书分类号))insert into 书目 values (7040195836,&#x27;数据库系统概论&#x27;,&#x27;王珊&#x27;,&#x27;高等教育出社&#x27;,39.00,&#x27;200&#x27;);insert into 书目 values (9787508040110,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;人民出版社&#x27;,20.00,&#x27;100&#x27;);insert into 书目 values (9787506336239,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;作家出版社&#x27;,34.30,&#x27;100&#x27;);insert into 书目 values (9787010073750,&#x27;心学之路&#x27;,&#x27;王珊&#x27;,&#x27;人民出版社&#x27;,33.80,&#x27;300&#x27;);\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n图书编号\nISBN\n是否借出\n备注\n\n\n\n2001231\n7040195836\n否\n\n\n\n2001232\n7040195836\n是\n\n\n\n1005050\n9787506336239\n否\n\n\n\n1005063\n9787508040110\n是\n\n\n\n3007071\n9787010073750\n是\n\n\n\ncreate table 图书(  图书编号 NUMBER primary key,,  isbn NUMBER,  是否借出 VARCHAR2(2),  备注   VARCHAR2(24),  foreign key(ISBN) references 书目(ISBN))insert into 图书 values (2001231,&#x27;7040195836&#x27;,&#x27;否&#x27;,null);insert into 图书 values (2001232,&#x27;7040195836&#x27;,&#x27;是&#x27;,null);insert into 图书 values (1005050,&#x27;9787506336239&#x27;,&#x27;否&#x27;,null);insert into 图书 values (1005063,&#x27;9787508040110&#x27;,&#x27;是&#x27;,null);insert into 图书 values (3007071,&#x27;9787010073750&#x27;,&#x27;是&#x27;,null);\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n借书证号\n姓名\n单位\n性别\n地址\n联系电话\n身份证编号\n\n\n\n20051001\n王菲\n四川绵阳西科大计算机学院\n女\n…\n…\n..\n\n\n20062001\n张江\n四川绵阳中心医院\n男\n…\n…\n..\n\n\n20061234\n郭敬明\n四川江油305\n男\n..\n..\n..\n\n\n20071235\n李晓明\n四川成都工商银行\n男\n..\n..\n..\n\n\n20081237\n赵鑫\n四川广元广元中学\n女\n..\n..\n..\n\n\ncreate table 读者(  借书证号  VARCHAR2(10) primary key,  姓名    VARCHAR2(10),  单位    VARCHAR2(25),  性别    VARCHAR2(2),  地址    VARCHAR2(16),  联系电话  VARCHAR2(16),  身份证编号 VARCHAR2(16))insert into 读者 values (&#x27;20051001&#x27;,&#x27;王菲&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;女&#x27;,null,null,null);insert into 读者 values (&#x27;20062001&#x27;,&#x27;张江&#x27;,&#x27;四川绵阳中心医院&#x27;,&#x27;男&#x27;,&#x27;绵阳&#x27;,null,null,null);insert into 读者 values (&#x27;20061234&#x27;,&#x27;郭敬明&#x27;,&#x27;四川江油305&#x27;,&#x27;男&#x27;,&#x27;四川&#x27;,null,null,null);insert into 读者 values (&#x27;20071235&#x27;,&#x27;李晓明&#x27;,&#x27;四川成都工商银行&#x27;,&#x27;男&#x27;,&#x27;成都&#x27;,null,null,null);insert into 读者 values (&#x27;20081237&#x27;,&#x27;赵鑫&#x27;,&#x27;四川广元广元中学&#x27;,&#x27;女&#x27;,&#x27;广元&#x27;,null,null,null);\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n借书证号\n图书编号\n借书日期\n归还日期\n罚款分类号\n备注\n\n\n\n20081237\n3007071\n2010/09/19\n2010/09/20\n\n\n\n\n20071235\n1005063\n2010/10/20\n2011/02/20\n1\n\n\n\n20071235\n2001232\n2011/09/01\n\n\n\n\n\n20061234\n1005063\n2011/9/20\n\n\n\n\n\n20051001\n3007071\n2011/9/10\n\n\n\n\n\n20071235\n1005050\n2011/10/20\n2012/02/20\n1\n\n\n\ncreate table 借阅(  借阅流水号 NUMBER primary key,  借书证号  VARCHAR2(16),  图书编号  NUMBER(10),  借书日期  DATE,  归还日期  DATE,  罚款分类号 NUMBER,  备注    VARCHAR2(20),  foreign key(借书证号) references 读者(借书证号)  foreign key(图书编号) references 图书(图书编号)  foreign key(罚款分类号) references 罚款分类(罚款分类号))insert into 借阅 values (1,&#x27;20081237&#x27;,3007071,to_date(&#x27;2010-09-19&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2010-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null);insert into 借阅 values (2,&#x27;20071235&#x27;,1005063,to_date(&#x27;2010-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2011-02-20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);insert into 借阅 values (3,&#x27;20071235&#x27;,2001232,to_date(&#x27;2011-09-01&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (4,&#x27;20061234&#x27;,1005063,to_date(&#x27;2011-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (5,&#x27;20051001&#x27;,3007071,to_date(&#x27;2011-09-10&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (6,&#x27;20071235&#x27;,1005050,to_date(&#x27;2011-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2012/02/20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n罚款分类号\n罚款名称\n罚金\n\n\n\n1\n延期\n10\n\n\n2\n损坏\n20\n\n\n3\n丢失\n50\n\n\ncreate table 罚款分类(  罚款分类号 NUMBER primary key,  罚款名称  VARCHAR2(10),  罚金    NUMBER(3))insert into 罚款分类 values (1,&#x27;延期&#x27;,10);insert into 罚款分类 values (2,&#x27;损坏&#x27;,20);insert into 罚款分类 values (3,&#x27;丢失&#x27;,50);\n\n\n预约 （预约流水号，借书证号，ISBN，预约时间）\n\n\n\n\n预约流水号\n借书证号\nISBN\n预约时间\n\n\n\n1\n20081237\n9787508040110\n2011/09/11\n\n\ncreate table 预约(  预约流水号  NUMBER primary key,  借书证号   VARCHAR2(16),  isbn   NUMBER,  s_date DATE)insert into 预约 values (1,&#x27;20081237&#x27;,&#x27;9787508040110&#x27;,&#x27;2011/09/11&#x27;,&#x27;yyyy/mm/dd&#x27;);\n\n使用SQL语句练习表的创建、删除、修改操作select * from 图书;alter table 图书 add 图书分类号 number;alter table 图书 drop column 图书分类号;update 图书 set 是否借出=&#x27;否&#x27; where 图书分类号=&#x27;2002141&#x27;;\n\n试根据下面的完整性约束要求，用SQL对上面已经建立好的数据库表进行完整性约束定义。读者关系中属性  联系电话  取值为11位数字身份证编号  取值为18位，并且满足身份证编号规则\nalter table 读者 add constraint PhoneNumber check(regexp_like(联系电话,&#x27;1[3|4|5|7|8][0-9]&#123;9&#125;&#x27;));alter table 读者 add constraint IDENTITYNUM check(regexp_like(身份证号,&#x27;[1-9\\d&#123;5&#125;(19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|([1-3]0)|31)\\d&#123;3&#125;[0-9Xx]&#x27;))","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验三、四","url":"/2021/04/28/Database-experiment-3/","content":"实验类型验证型实验\n实验目的\n了解存储过程的概念、优点\n熟练掌握创建存储过程的创建方法\n熟练掌握存储过程的调用方法\n\n实验内容\n建立存储过程\n调用存储过程\n\n实验步骤\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\n\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n修改实验三借书功能的存储过程。该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n该存储过程主体部分只有insert into语句。\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n修改实验三还书功能的存储过程。该存储过程要求：（1）还书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）还书时，还书日期为系统时间。\n\n\n该存储过程主体部分只有一条UPDATE语句。\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\n实验结果实验三\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\ncreate or replace procedure Procedure_借书(vis_借阅流水号 in 借阅.借阅流水号%type,vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)asbegin  insert into 借阅  values(vis_借阅流水号,vis_借书证号,vis_图书编号,sysdate,null,null,null);  update 图书  set 图书.是否借出 = &#x27;是&#x27;  where 图书.图书编号 = vis_图书编号;end;\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\ncreate or replace procedure Procedure_预约(vis_预约流水号 in 预约.预约流水号%type,vis_借书证号 in 预约.借书证号%type,vis_ISBN in 预约.ISBN%type)asvis_数量 number;begin  select count(*) into vis_数量 from 图书  where 图书.ISBN=vis_ISBN  and 图书.是否借出=&#x27;否&#x27;;  if vis_数量= 0 then    insert into 预约 values(vis_预约流水号,vis_借书证号,vis_ISBN,sysdate);    commit;  else    dbms_output.put_line(&#x27;该书目有可借图书，请查找！&#x27;);  end if;end;\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\ncreate or replace procedure Procedure_还书(vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type,vis_罚款分类号 in 借阅.罚款分类号%type)asbegin  update 借阅  set 借阅.归还日期=sysdate,借阅.罚款分类号=vis_罚款分类号  where 借阅.借书证号=vis_借书证号  and 借阅.图书编号=vis_图书编号;  update 图书 set 图书.是否借出=&#x27;否&#x27;  where 图书.图书编号=vis_图书编号;end;\n\n实验四\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n\ncreate sequence SEQ_序列minvalue 1maxvalue 1.0E28start with 1increment by 1cache 20;create or replace trigger TR_借阅流水号自增       before insert on 借阅       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.借阅流水号  from dual;end;\n\n\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n\ncreate or replace trigger TR_预约流水号自增       before insert on 预约       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.预约流水号  from dual;end;\n\n3、 修改实验三借书功能的存储过程，该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n\n该存储过程主体部分只有insert into语句。\n\ncreate or replace procedure Processed_借书   (  vis_借书证号 in 借阅.借书证号%type,  vis_图书编号 in 借阅.图书编号%type  )  as vis_是否借出 图书.是否借出%type;begin  select 是否借出 into vis_是否借出 from 图书 where vis_图书编号 = 图书.图书编号;  if vis_是否借出=&#x27;是&#x27; then   dbms_output.put_line(&#x27;该书已经被借走了！&#x27;);  else     select 图书.是否借出     into vis_是否借出     from 图书     where 图书.图书编号=vis_图书编号;    insert into 借阅(借书证号,图书编号,借书日期)     values(vis_借书证号,vis_图书编号,sysdate);   commit;    end if;   end;\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n\ncreate or replace trigger TR_借书       after insert on 借阅       for each rowbegin  update 图书 set 是否借出 = &#x27;是&#x27; where 图书编号 = :new.图书编号;end;\n\n5、 修改实验三还书功能的存储过程，该存储过程要求：（1）还书时输入借书证号，图书编号，罚款分类号。（即该函数有3个输入参数）（2）还书时，还书日期为系统时间。\n\n该存储过程主体部分只有一条UPDATE语句。\n\ncreate or replace procedure Processed_还书 (vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)as vis_是否借出 图书.是否借出%type;begin  update 借阅 set 借阅.归还日期 = sysdate()  where 借阅.借书证号 = vis_借书证号  and 借阅.图书编号 = vis_图书编号  and 借阅.归还日期 is null;end;\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\ncreate or replace trigger TR_还书after update on 借阅for each row  begin    update 图书 set 是否借出 = &#x27;否&#x27;    where 图书编号 = :new.图书编号;end;","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验（二）数据查询","url":"/2021/04/28/Database-experiment-2/","content":"实验类型验证型实验\n实验目的\n掌握查询语句的一般格式；\n熟练掌握单表查询、连接查询、集合查询、统计查询和嵌套查询。\n\n实验内容\n单表查询\n连接查询\n嵌套查询\n集合查询\n\n实验步骤\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n查询学号“20061234”号借书证借阅未还的图书的信息。\n查询各个出版社的图书最高单价、平均单价。\n要查询借阅了两本和两本以上图书的读者的个人信息。\n查询“王菲”的单位、所借图书的书名和借阅日期。\n查询每类图书的册数和平均单价。\n统计从未借书的读者人数。\n统计参与借书的人数。\n找出所有借书未还的读者的信息及所借图书编号及名称。\n检索书名是以“红”开头的所有图书的书名和作者。\n查询各图书的罚款总数。\n查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空（左外连接）\n查询借阅了所有“文学”类书目的读者的姓名、单位。\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n求总藏书量、藏书总金额，总库存册数、最高价、最低价。\n\n列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\n\n列出年份最久远的书?\n\n目前实际已借出多少册书？\n\n哪一年的图书最多？\n\n哪本借书证未归还的图书最多？\n\n平均每本借书证的借书册数。\n\n哪个单位的读者平均借书册数最多？\n\n最近两年都未被借过的书。注意：Oracle 系统日期时间 sysdate，更多关于oracle日期函数请自行查阅。\n\n今年未借过书的借书证。\n\n\n实验结果实验内容\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n\nselect *from 书目,图书where 书目.ISBN=图书.ISBNand 书名=&#x27;红楼梦&#x27;and 是否借出=&#x27;否&#x27;\n\n\n   查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n\nselect *from 书目where 出版单位=&#x27;高等教育出版社&#x27;order by 单价 desc;\n\n\n   统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n\nselect count(ISBN),ISBNfrom 书目where 书名=&#x27;红楼梦&#x27;group by ISBN;\n\n\n   查询学号“20061234”号借书证借阅未还的图书的信息。\n\nselect 借书证号,书名,书目.ISBN ,出版单位,作者,单价,    图书分类号from 书目,借阅,图书where 书目.ISBN=图书.ISBNand 借阅.图书编号=图书.图书编号 and 是否借出=&#x27;是&#x27;and  归还日期 is NULLand 借书证号=20061234;\n\n\n   查询各个出版社的图书最高单价、平均单价。（同上）\n\nselect 出版单位,max(单价),avg(单价)from 书目group by 出版单位;\n\n\n   要查询借阅了两本和两本以上图书的读者的个人信息。\n\nselect * from 读者 where 借书证号 in(select 借书证号from 借阅group by 借书证号 having count(借书证号)&gt;=2);\n\n\n   查询“王菲”的单位、所借图书的书名和借阅日期。\n\nselect 单位,书名,借书日期from 读者,借阅,书目,图书where  姓名=&#x27;王菲&#x27;and 读者.借书证号=借阅.借书证号and 借阅.图书编号=图书.图书编号and 图书.ISBN=书目.ISBN ;\n\n\n   查询每类图书的册数和平均单价。\n\nselect count(图书分类号),avg(单价)from 书目group by 图书分类号;\n\n\n   统计从未借书的读者人数。\n\nselect count(姓名)from 读者where not exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   统计参与借书的人数。\n\nselect count(姓名)from 读者where exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   找出所有借书未还的读者的信息及所借图书编号及名称。\n\nselect distinct 借阅.借书证号,姓名,单位,性别,地址,联系电话,身份证编号,借阅.图书编号,书名from 借阅,书目,读者,图书where 借阅.借书证号=读者.借书证号and 借阅.图书编号=图书.图书编号and 书目.ISBN=图书.ISBNand 归还日期 is null;\n\n\n   检索书名是以“红”开头的所有图书的书名和作者。\n\nselect 书名,作者from 书目where 书名 like &#x27;红%&#x27;;\n\n\n   查询各图书的罚款总数。（分组，图书编号+罚款总数）\n\nselect 书目.ISBN,sum(罚金)from 借阅,罚款分类,书目,图书where 借阅.罚款分类号=罚款分类.罚款分类号and 借阅.图书编号=图书.图书编号group by 书目.ISBN\n\n\n   查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空\n\nselect * from 借阅  left outer join 罚款分类 on(借阅.罚款分类号=罚款分类.罚款分类号)\n\n\n   查询借阅了所有“文学”类书目的读者的姓名、单位。（判断条件）\n\nselect 读者.姓名,读者.单位from 读者where not exists(      select *      from 书目,图书分类      where 书目.图书分类号=图书分类.图书分类号 and 图书分类.类名=&#x27;文学&#x27; and not exists      (            select *            from 借阅,图书            where 借阅.图书编号=图书.图书编号 and 借阅.借书证号=读者.借书证号 and 书目.ISBN=图书.ISBN      ))\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n\nalter table 书目add 出版年份 number;update 书目 set 出版年份=2005 where ISBN=7040195836;update 书目 set 出版年份=1983 where ISBN=9787508040110;update 书目 set 出版年份=2008 where ISBN=9787506336239;update 书目 set 出版年份=2009 where ISBN=9787010073750;\n\n2、求总藏书量、藏书总金额，总库存册数、最高价、最低价。\nselect count(图书编号),sum(单价),max(单价),min(单价)from 书目,图书where 书目.ISBN=图书.ISBN;\n\n3、列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\nselect 书名,作者,出版单位,出版年份from 书目where 书目.ISBN in(select 图书.ISBNfrom 图书group by 图书.ISBN having count( 图书.ISBN)&gt;5);\n\n4、列出年份最久远的书?\nselect 书名,作者,出版单位,出版年份from 书目where 书目.出版年份 in(select min(书目.出版年份)from 书目)\n\n5、目前实际已借出多少册书？\nselect count(借阅.借阅流水号) 借出数量from 借阅where 归还日期 is null;\n\n6、哪一年的图书最多？\nselect * from (select 出版年份,count(出版年份) 数量 from 图书,书目 where 图书.ISBN = 书目.ISBNgroup by 出版年份 order by count(出版年份) desc ) where rownum=1;\n\n7、 哪本借书证未归还的图书最多？\nselect * from (select 借书证号from 借阅where 归还日期 is nullgroup by 借书证号order by count(借书证号) desc) where rownum=1\n\n8、平均每本借书证的借书册数。\nselect 借书证号,count(借书证号)from 借阅 group by 借书证号;\n\n9、哪个单位的读者平均借书册数最多？\nselect 读者.单位from 读者where 读者.借书证号 in (select 借书证号 from (select 借书证号, count(借书证号)from 借阅group by 借书证号order by  count(借书证号) desc ) where rownum=1);\n\n10、最近两年都未被借过的书。\nselect distinct(书目.ISBN),书目.书名,书目.出版单位from 图书,书目,借阅where 图书.图书编号=借阅.图书编号and 书目.ISBN=图书.ISBNand 借阅.借书日期not between to_date(&#x27;20180101&#x27;,&#x27;yyyy/mm/dd&#x27;)and to_date(&#x27;20191231&#x27;,&#x27;yyyy/mm/dd&#x27;);","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验五、六","url":"/2021/04/28/Database-experiment-4/","content":"实验类型验证型实验\n实验目的\n了解数据库恢复技术的原理\n了解oracle各类故障的数据恢复方法\n了解oracle的物理备份\n掌握oracle数据库逻辑备份方法\n掌握oracle数据库恢复的方法\n学会使用exp备份数据库、使用imp恢复数据库\n了解flashback 的使用\n学会使用PLSQL/developer工具完成导入导出\n理解数据库的安全性保护\n掌握ORACLE中有关用户创建的方法\n理解数据库存取控制机制\n熟练掌握PL-SQL的数据控制语言，能通过自主存取控制进行权限管理\n熟悉用户资源文件的使用\n熟悉ORACLE中角色管理\n熟悉视图机制在自主存取控制上的应用\n\n实验内容\n查看归档模式\n使用exp导出数据库\n使用imp导入数据库\n使用flashback 闪回表\n使用PLSQL/developer工具完成导出\n使用PLSQL/developer工具完成导入\n\n实验步骤实验五\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。\n热备份和冷备份，分别使用什么归档模式？\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n客户端可以使用RMAN进行热备份吗？\n逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl按照提示进行导出（2）删除自己表空间中的“预约”表（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl按照提示进行导入（4）查询导入的“预约”表中的信息。（5）导出数据库（以全库方式导出）。\n\n\n必须是DBA才能执行完整数据库或表空间导出操作。\n\n\n使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE   ROW  MOVEMENT（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE   读者 TO TIMESTAMP   TO_ TIMESTAMP(….)\n使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签SQL 插入（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导入表，利用SQL插入导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer（3）浏览或者输入输出文件，然后点击导出。（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n\n实验六\n同学之间相互授权访问对方“读者”表并能进行查询。\n以SYS登录数据库 为你的账号增加系统角色DBA.\n重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。\n建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）\n创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。\n建立视图VIEW_READER, 该视图包含书目（ISBN, 书名，作者，出版单位，图书分类名称）（注：所有属性来自关系书目和图书分类）\n创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。\n\n实验结果\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。使用SYS登录，由于是超级管理员所以要使用： “口令+ as sysdba”登录\n\n\n\n输入archive log list\n\n\n\n热备份和冷备份，分别使用什么归档模式？热备份针对归档模式的数据库，在数据库仍旧处于工作状态时进行备份。而冷备份是指在数据库关闭后，进行备份，适用于所有模式的数据库，热备份的优点在于当备份时，数据库仍旧可以被使用并且可以将数据库恢复到任意一个时间点。冷备份的优点在于他的备份和回复操作相当简单，并且由于冷备份的数据可以工作在非归档模式下，数据库性能会比归档模式稍好。\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n\n1)正常关闭数据库2)备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）3)完成备份后启动数据库4. 客户端可以使用RMAN进行热备份吗？ 可以5. 逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl 按照提示进行导出\n\n\n（2）删除自己表空间中的“预约”表\n\n\n\n（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl，按照提示进行导入\n\n\n\n（4）查询导入的“预约”表中的信息。\n\n\n（5）导出数据库（以全库方式导出）。exp S5120188039/yyk1776572104@orcl FULL=Y\n\n\n\n\n6、使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE ROW MOVEMENT\n\n\n（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。插入数据：\nINSERT INTO 读者 VALUES(&#x27;20181452&#x27;,&#x27;胡晋源&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20186666&#x27;,&#x27;吕硕&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20188039&#x27;,&#x27;姚永坤&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null); \n\n（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE 读者 TO TIMESTAMP TO_ TIMESTAMP(….)代码：\nFLASHBACK TABLE 读者 TO TIMESTAMP TO_TIMESTAMP(&#x27;2020/11/15 16:30:00&#x27;,&#x27;YYYY/MM/DD HH24:MI:SS&#x27;);\n\n7、使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具”导出表\n\n\n（2）点击你要导出的表，然后选择标签SQL插入\n\n\n（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出\n\n\n（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导入表，利用SQL插入导入数据库预约表。\n\n\n\n（8）查询导入的预约表，检查导出是否正确。\n\n\n8、使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer\n\n\n（3）浏览或者输入输出文件，然后点击导出。\n\n\n（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。\n\n\n（8）查询导入的预约表，检查导出是否正确\n\n\n实验六1、同学之间相互授权访问对方“读者”表并能进行查询。2、以SYS登录数据库 为你的账号增加系统角色DBA.\n\n\n使用 “GRANT DBA TO + 用户名”给自己的账号增加系统角色DBA：\n\n\n3、 重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。（1）登录\n\n\n（2）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER1 IDENTIFIED BY ORCL;\n\n\n\n（3）使用GRANT CONNECT TO S5120188039_USER1;\nGRANT RESOURCE TO S5120188039_USER1;GRANT DBA TO S5120188039_USER1;\n\n\n4、 建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）（1）创建角色\nCREATE ROLE S5120188039_OPER;\n\n（2）授权\nGRANT EXECUTE ON PROCESSED_借书 TO S5120188039_OPER;GRANT EXECUTE ON PROCESSED_还书 TO S5120188039_OPER;GRANT EXECUTE ON PROCEDURE_预约 TO S5120188039_OPER;\n\nGRANT SELECT ON 读者 TO S5120188039_OPER;GRANT SELECT ON 书目 TO S5120188039_OPER;GRANT SELECT ON 图书 TO S5120188039_OPER;GRANT SELECT ON 借阅 TO S5120188039_OPER;GRANT SELECT ON 预约 TO S5120188039_OPER;\n\n\n5、创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。（1）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER2 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT S5120188039_OPER TO S5120188039_USER2;\n\n（3）重新登录并且实现借书过程\n\nCALL S5120188039.PROCESSED_借书(20051001,1005050);\n\n（4）查询结果\n\n\n7、 创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。（1）创建数据库用户\nCREATE USER S5120188039_USER3 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT CONNECT TO S5120188039_USER3;\n\nGRANT SELECT ON VIEW_READER TO S5120188039_USER3;\n\n（3）创建概要文件\nCREATE PROFILE LOCK_USER LIMITFAILED_LOGIN_ATTEMPTS 3PASSWORD_LOCK_TIME 10;\n\n（4）分配概要文件\nALTER USER S5120188039_USER3 PROFILE LOCK_USER;\n\n（5）测试输入错误，锁定用户\n\n\n（6）账户锁定进行解锁\nALTER USER S5120188039_USER3 ACCOUNT UNLOCK;\n\n（7）再次测试\n","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"HTML语义化","url":"/2021/05/28/Html-study-1/","content":"定义\nHTML语义化就是根据具体内容，选择合适的标签进行代码的编写。便于开发者阅读和写出更优雅的代码，同时让搜索引擎的爬虫能更好的识别。\n\n简单来讲就是：用正确的标签做正确的事\n\n\n举例说明比如说：\n\n段落用&lt;p&gt;标签\n标题用h1~h6标签\n文章就用article\n\n为什么要使用语义化标签1、 CSS文件读取失败的准备：万一CSS文件挂了，语义化的HTML也能呈现较好的内容结构与代码结构。2、 提高：    - 可访问性：简单来讲，便于其他设备的解析，比如：移动端设备，盲人阅读器等；    - 可检索性：提高搜索引擎的有效爬取，提高网站流量；    - 国际化：让各国开发者容易弄懂网页结构；    - 互用性：减少网页间的差异性，便于团队开发和维护。\n","categories":["HTML学习笔记"],"tags":["HTML","HTML学习笔记"]},{"title":"Http和Https","url":"/2021/04/28/Front-end-basic-learning-1/","content":"Http和Https基本概念\nHttp\n超文本传输协议，是互联网上应用最为广泛的一种网络协议\n是一个客户端和服务器端请求和应答的标准，即TCP\n用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少\nHTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response。\n\n\nHttps\n以安全为目标的http通道/http的安全版\nhttp下加入SSL层\n安全基础为SSL，加密内容需要SSL\n主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n优点：使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n缺点：\nhttps 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\nhttps 缓存不如 http 高效，会增加数据开销。\nSSL 证书需要钱，功能越强大的证书费用越高。\nSSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。\n\n\n\n\n\ntips：\n\nSSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。\nSSL协议可分为两层：  ① SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。  ② SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。\n\n区别\nhttp传输的数据是未加密的，连接很简单，是无状态的；https由SSL协议来对http协议传输的数据进行加密，安全性更高\nHttps 协议需要 ca 证书，费用较高。\n使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443\n\ntips：\n\nCA是证书的签发机构，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。\nCA是负责签发证书、认证证书、管理已颁发证书的机关。\nCA 拥有一个证书（内含公钥和私钥）。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。\n\nhttps协议工作原理① 客户使用 https url 访问服务器，web 服务器建立 ssl 链接② web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。③ 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。④ 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。⑤ web 服务器通过自己的私钥解密⑥ web 服务器通过会话密钥加密与客户端之间的通信。\nhttp 请求的方式\n1、OPTIONS&emsp;&emsp;返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD&emsp;&emsp;向服务器索取与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET&emsp;&emsp;向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url4、POST&emsp;&emsp;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form5、PUT&emsp;&emsp;向指定资源位置上传其最新内容6、DELETE&emsp;&emsp;请求服务器删除Request-URL所标识的资源7、TRACE&emsp;&emsp;回显服务器收到的请求，主要用于测试或诊断8、CONNECT&emsp;&emsp;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n","categories":["前端学习笔记"],"tags":["前端","Http","Https"]},{"title":"TCP和UDP","url":"/2021/07/20/tcp-ip/","content":"TCP 三次握手\n\n\nC 发起请求连接 S 确认，也发起连接 C 确认① 第一次握手：S确认可以接收C发送的报文段② 第二次握手：C确认S收到了自己发送的报文段，然后确认接受到了S发送的报文段③ 第三次握手：S确认C接受到了自己发送的报文段\n\nTCP和UDP的区别\n\n\n比较项\nTCP\nUDP\n\n\n\n首部\n首部为20字节\n只有8个字节\n\n\n连接上\n面向连接，可靠性传输\n发送数据前不需要先建立链接，不可靠\n\n\n传输上\n无差错，不丢失，不重复，且按序到达\n尽最大努力交付，不保证可靠交付\n\n\n对象上\n面向字节流，网络出现拥塞发送率会降低\n面向报文，网络出现拥塞会出现丢包情况\n\n\n服务对象数量\n仅支持1对1\n支持1对1，1对多\n\n\n","categories":["前端学习笔记"],"tags":["TCP","UDP"]}]