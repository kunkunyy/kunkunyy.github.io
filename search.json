[{"title":"Hello World","url":"/2021/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Markdown学习笔记","url":"/2021/03/12/markdown-study-notes/","content":" 之前只是用markdown写过博客并没有系统的去了markdown语法，现在将创建博客后的第一篇文章用来记录我学习markdown的经历以及对于知识点的理解。\nmarkdown官方介绍和个人理解菜鸟教程介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n个人理解\nMarkdown是一种纯文本标记语言\n语法简单，容易上手\n按照语法，自动排版，格式易操作\n……\n\n语法学习标题标题有两种书写格式，推荐使用第一种。\n# 号标识标题\n用法：使用 # 号可表示 1-6 级标题，每升一级添加一个 # 号\n易错点：最后一个 # 号后空一格\n示例：# 一级标题## 二级标题\n结果\n  \n\n\n= 和 - 标记标题\n用法：在对应文字下方输入 = （-）即可\n示例：一级标题=二级标题-\n结果\n\n\n\n段落格式换行\n实现方式：\n句子末尾空两格然后回车\n空一行实现换行\n\n\n\n字体斜体*猫猫头*_猫猫头_\n粗体**猫猫头**__猫猫头__\n粗斜体***猫猫头***___猫猫头___\n\n分割线\n实现方式：\n在一行中用三个以上的星号、减号、底线来建立一个分隔线。\n行内不能有其他东西。\n可以在星号或是减号中间插入空格。\n\n\n\n删除线（在文字上添加删除线）\n实现方式：~~猫猫头的小窝~~\n效果展示：猫猫头的小窝\n\n下划线\n实现方式：&lt;u&gt;猫猫头的小窝&lt;/u&gt;\n效果展示：猫猫头的小窝\n\n脚注\n补充说明词语或者句子内容。\n可用于标注出处，翻译等。\n实现方式：“[^情不知所起，一往而深。]”[^情不知所起，一往而深。]:感情不知道什么时候就开始了，而且愈来愈深厚。\n效果展示：“情不知所起，一往而深。”\n\n列表有序、无序列表\n实现方式：\n有序：数字并加上 . 号来表示。\n无序：星号(*)、加号(+)或是减号(-)作为列表标记，且标记后面要添加一个空格。\n\n\n\n列表嵌套\n实现方式：在子列表中的选项前面添加四个空格（或者一个Tab键）\n例子：1. 猫猫头：    - 猫猫头的代码库    - 猫猫头的图片库\n\n\n\n\n区块\n实现方式：在段落开头使用 &gt; 符号，后面紧跟一个空格符号。\n嵌套使用：\n区块嵌套：每增加一个 &gt; 符号增加一层。\n区块嵌套列表：&gt; + 猫猫头的代码库&gt; + 猫猫头的图片库\n\n\n猫猫头的代码库\n猫猫头的图片库\n\n\n\n列表嵌套区块：1. 猫猫头    &gt; 猫猫头的图片库    &gt; 猫猫头的代码库\n\n\n猫猫头\n猫猫头的图片库猫猫头的代码库\n\n\n\n\n\n代码\n实现方式：\n代码区块：\n使用 4 个空格或者一个制表符（Tab 键）。\n用 ``` 包裹一段代码，并指定一种语言，也可以不指定（推荐）。\n\n\n\n\n\n链接\n实现方法：[链接名称](链接地址)或者&lt;链接地址&gt;\n例子：[百度](www.baidu.com)\n\n图片\n实现方式：![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n\n补充：可以使用&lt;img&gt;标签，用于指定图片的高度与宽度。\n\n表格\n实现方式：\n使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n\n示例：| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n总结这里就暂时总结了markdown一些基本用法，能够满足用来写博客就可以了，后面继续加油吧！有什么问题可以留言哦！\n","categories":["markdown"],"tags":["markdown","study notes"]},{"title":"Python max函数不同参数结果比较","url":"/2021/03/15/python-skill-max/","content":"前言&emsp; &emsp; 在菜鸟教程中对于max函数描述是这样的：max() 方法返回给定参数的最大值，参数可以为序列。这个描述只是客观的将这个函数的功能给描述出来了，但这只是一个模糊的定义。由于没有指定可传入参数的类型，所以说这就带给了这个函数无限种可能。现在就来讨论讨论吧！如果有哪些地方表述不是很正确希望大家在评论区指出来哦！\n数字类型&emsp; &emsp; 首先我们来看看最简单大数字类型。毋庸置疑，当参数是数字的时候，直接返回最大的数就好了。但是要注意的是这里的数字指的是一系列数，返回其中最大的。下面来看一个简单的例子。\n&gt;&gt;&gt; max(1,2,3,4,5,6,7,8,9)9\n\n字符串类型&emsp; &emsp; 我们知道python中字符串是由单引号双引号括起来的一个字符序列。那么当输入max的变量为一个字符串它会返回给我们什么结果呢？\n&emsp; &emsp; 我们先看下面这个例子：\n&gt;&gt;&gt;a=&#x27;1,6,0,4,5&#x27;&gt;&gt;&gt;max(a)&#x27;6&#x27;\n我们输入一个由单个数字组成的字符串，穿入max函数后返回了其中的 ‘6’ 这个字符。难道是将字符转化为数字然后再比较大小吗？那字符串中的 ‘,’ 又去哪了呢？那如果是字母又如何进行比较呢？来看下一个例子：\n&gt;&gt;&gt;b=&#x27;fabced&#x27;&gt;&gt;&gt;max(b)&#x27;f&#x27;\n这里变量b为一个字母组成的字符串，结果返回给我们的是字符 ‘f’ ，这里我们大致应该可以判断出来：当max函数的输入变量为一个字符串的时候，则返回字符串中字符所对应的ASCII码最大的那个字符。\n&emsp; &emsp; 为了验证这一结论我们利用下面这个例子进行验证：\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;max(c)&#x27;c&#x27;\n&emsp; &emsp; 从这个例子我们就可以验证刚刚的结论了：c这个字符串中字符’1’’a’’2’’c’对应的ASCII码的大小分别为49，97，50，99，所以字符’c’所对应的ASCII码值最大固返回字符’c’。那么字符’,’去哪了呢？实际上字符’,’也是参与了比较，由于它所对应的ASCII码为44最小，所以看似跟舍弃了一样。\n&gt;&gt;&gt;c=&#x27;1,a,2,c&#x27;&gt;&gt;&gt;min(c)&#x27;,&#x27;\n\n另外，max函数还可以对于传入的可迭代对象找出元素中的最大值。这里可迭代的对象主要是列表和字典\n列表同样对于列表，它满足可迭代这样一个特点，这里我们主要分四种情况来讨论：\n\n元素全为数字&gt;&gt;&gt;a=[1,2,3,4,5]&gt;&gt;&gt;max(a)5\n元素全为字符&gt;&gt;&gt;b=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]&gt;&gt;&gt;max(b)&#x27;e&#x27;\n&gt;&gt;&gt;c=[&#x27;ab&#x27;,&#x27;ac&#x27;,&#x27;ad&#x27;,&#x27;ae&#x27;]&gt;&gt;&gt;max(c)&#x27;ae&#x27;\n&gt;&gt;&gt;d=[&#x27;1a&#x27;,&#x27;1b&#x27;,&#x27;2a&#x27;,&#x27;2b&#x27;]&gt;&gt;&gt;max(d)&#x27;2b&#x27;\n通过以上几个例子我们不难发现：\n列表中元素类型需一致；（前提条件）\n若列表中元素数字类型值，则返回列表中元素的最大值；\n若列表中元素为字符，字符转换为对应ASCII码值输出最大的；\n若列表中元素为字符串，将组成字符串的每个字符的ASCII码相加，然后输出最大的。\n\n列表（元组）刚刚我们讨论了简单元素组成的列表作为参数的情况，接下来我们看一看由元组组成的列表：我们还是按照上面的步骤来。\n\n全为数字\n&gt;&gt;&gt;a=[(1,3),(2,2),(1,4),(3,0)]&gt;&gt;&gt;max(a)(3,0)\n对应位置元素类型相同\n&gt;&gt;&gt;b=[(&#x27;a&#x27;,1),(&#x27;b&#x27;,5),(&#x27;a&#x27;,6)]&gt;&gt;&gt;max(b)(&#x27;b&#x27;,5)\n&gt;&gt;&gt;c=[(&#x27;a&#x27;,&#x27;A&#x27;),(&#x27;a&#x27;,&#x27;B&#x27;)]&gt;&gt;&gt;max(c)(&#x27;a&#x27;,&#x27;B&#x27;)\n元组大小不一致\n&gt;&gt;&gt;d=[(1,4),(3,1,5),(3,1)]&gt;&gt;&gt;max(d)(3,1,5)\n对应位置元素不同\n&gt;&gt;&gt;e=[(6,4),(6,1,5),(3,&#x27;a&#x27;)]&gt;&gt;&gt;max(e)(6,4)\n&gt;&gt;&gt;f=[(1,4),(&#x27;a&#x27;,2),(3,1)]&gt;&gt;&gt;max(e)TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;\n通过以上几个例子对比分析我们不难发现：\n\n按照元组内部排列顺序从前到后对应位置进行比较，如果对应位置元素类型和大小相同，则比较下一个位置的元素，按照此规则进行比较直至找到最大值或者出错。\n\n类型不匹配：列表元组中当比较到对应位置发现存在相比较的两个元素类型不相同时报错；\n\n当比较位置不存在元素时，默认为NUL；\n\n当比较的元素为数字类型值，则返回列表中元素的最大值；\n\n当比较的元素为字符，字符转换为对应ASCII码值返回；\n\n当比较的元素为字符串，将组成字符串的每个字符的ASCII码相加返回。\n\n\n字典\n对于字典类型来说相比较容易一些，只需要比较字典的键值，输出最大的键值；\n键值的比较同上。\n\n&gt;&gt;&gt;a=&#123;1:1,2:19,3:100,4:1&#125;&gt;&gt;&gt;max(a)4&gt;&gt;&gt;b=&#123;20:21,5:20,13:14&#125;&gt;&gt;&gt;max(b)20","categories":["python"],"tags":["Skill","python"]},{"title":"Python 字符串连接方法","url":"/2021/03/16/python-skill-string-concatenation/","content":"之前在学习Python的时候对于字符串的连接并没有过多的研究，能应付考试就好啦。最近在写博客遇到相关内容去查了查，发现字符串连接的方法还是非常多的，这篇博客就来记录一下方便以后查看。\n字符串连接方法总结假设’str1’，’str2’为两个字符串。\n‘+’ 连接a = str1b = str2print(a+b)&gt;&gt;&gt;str1str2\n\n模式串”%s”方法print（&#x27;%s%s&#x27; %(str1,str2)）&gt;&gt;&gt;str1str2\nformat 方法print(&quot;&#123;&#125;&#123;&#125;&quot;.format(str1，str2))print(&quot;&#123;0&#125;&#123;1&#125;&quot;.format(str1，str2))print(&quot;&#123;c&#125;&#123;d&#125;&quot;.format(c=str1，d=str2))&gt;&gt;&gt;str1str2\n‘f-string’方法print(f&#x27;&#123;str1&#125;&#123;str2&#125;&#x27;) &gt;&gt;&gt;str1str2\njoin方法\n列表print(&#x27;&#x27;.join([str1,str2])) &gt;&gt;&gt;str1str2\n字典：只有键和值均为字符串时才可使用。a=&#123;&#x27;20&#x27;:&#x27;20&#x27;,&#x27;520&#x27;:&#x27;1314&#x27;&#125;print(&#x27;&#x27;.join(a))print(&#x27;&#x27;.join(a.value（））) &gt;&gt;&gt; &#x27;20520&gt;&gt;&gt; &#x27;201314&#x27;\n通过() 多行拼接s = (    &#x27;Hello&#x27;    &#x27; &#x27;    &#x27;World&#x27;    &#x27;!&#x27;)print(s)&gt;&gt;&gt; Hello World! \n通过string模块中的Template对象拼接\n实现原理：通过Template初始化一个字符串。这些字符串中包含了一个个key。通过调用substitute或safe_subsititute，将key值与方法中传递过来的参数对应上，从而实现在指定的位置导入字符串。from string import Templates = Template(&#x27;$&#123;s1&#125; $&#123;s2&#125;!&#x27;)print(s.safe_substitute(s1=&#x27;Hello&#x27;,s2=&#x27;World&#x27;))&gt;&gt;&gt; Hello World\n空格自动连接&gt;&gt;&gt; &quot;Hello&quot; &quot;Nasus&quot;&#x27;HelloNasus&#x27;\n\n","categories":["python"],"tags":["Skill","python"]},{"title":"python学习笔记（一）","url":"/2021/03/15/python-study-note/","content":"本科学习python课程笔记，之前使用的有道云笔记记载，现在将它搬运到博客中。\n第一章是一些基本概念，所以从第二章开始记的。所以，一起加油咯！\n\n第二章主要是turtle库的使用，然后简单介绍了python中的字符串的使用，第三章会详细讲字符串。\n字符串简单介绍字符串的两种序号表达\n假设字符串长度为L：\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n\n\n\n字符串截取范围\nTempStr[0:-1]    从0到-1，但不包括-1\n口诀：前取后不取\n\nturtle库介绍&emsp; &emsp; 实际上我们使用turtle库来绘制图形就是：在操纵“小海龟”在我们所定义的画布（canvas）（或者叫做窗体也可以）上进行爬行，它行动留下的痕迹就是我们所要绘制图形的轮廓。&emsp; &emsp; 在了解绘制原理后我们就对于这个必不可少的画布进行了解和学习。\n画布坐标轴&emsp; &emsp; 一般情况下，当你创建了一个画布它就会对应的生成坐标轴，一方面是为了方便我们绘制图形；另一方面也是为了避免造成歧义导致出错。&emsp; &emsp; 下图是对应坐标系的规定：\n\n\n\n画布（窗体）的创建\nturtle.screensize(canvwidth=None,canvheight=None,bg=None)\n参数：画布宽、高、背景色\n\n\nturtle.setup(width, height, startx, starty)\n参数：窗体宽、高、窗体左上角顶点的横纵坐标\n输入宽和高为整数时,表示像素;为小数时,表示占据电脑屏幕的比例\n\n\n\n画笔&emsp; &emsp;默认情况下，我们的“画笔”是一个位于坐标原点面朝正向的小海龟，我们通过控制小海龟来完成图形的绘制。\n画笔的属性\nturtle.pensize/width(width)\n用于设置画笔宽度\n\n\nturtle.pencolor()\n用于设置画笔颜色\n\n\nturtle.speed(x)\n用于设置画笔速度，0≤x≤10\n\n\n\n画笔移动状态\nturtle.forward/backward(d)\n向前/向后移动距离为d\n\n\nturtle.right/left(r)\n向左/右转动度数\n\n\nturtle.down/up()\n画笔落下/抬起\n\n\nturtle.fillcolor()\n给绘制的图形填充颜色\n\n\nturtle.circle(r,angle)\n绘制圆，半径正负均可，angle为角度\n\n\n\n\nturtle.done()\n结束程序\n\n\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"python学习笔记（二）","url":"/2021/03/15/python-study-notes-2/","content":"第三章这一章主要是对基本数据类型的学习，包括数字和字符串类型以及对应的操作。\n数字类型\n类型：整数、浮点数、复数\n\n浮点数\n浮点数间运算存在不确定尾数，如下图所示：\n\n\n原因：浮点数是小数的一种二进制表示方法，由于浮点数存在精度限制，在使用浮点数做运算时就可能会产生不确定尾数。\n解决方法：round(x,d)对x四舍五入，d是小数截取位数。\n\n\n科学计数法\n\n\n复数\n实、虚部获取方法：z为一复数\n实部：z.real\n虚部：z.imag\n\n\n\n数字类型关系\n不同类型间可进行混合运算，生成结果为”最宽”类型\n整数 &gt; 浮点数 &gt; 复数\n\n数值运算函数常用函数abs(x)\n对于x取绝对值\n\nsqrt(x)\nx的平方根\n\npow(x,y)\nx的y次幂\n\nround(x,[d])\n对于数x，四舍五入保留d位\n\nmax()/min()\n返回给定参数的最大值\n参数可以为：数字、字符串、列表、元组\n不同参数返回结果请参考这篇文章：max不同参数比较\n\nint(x)\n将x变成整数，直接舍弃小数部分；\n参数：数字，字符\n\nfloat(x)\n将x变成浮点数，增加小数部分\n参数：数字，字符\n\n字符串字符串表示方法\n一对单、双或三引号构成\n多行字符串表示方法：\n三引号\n小括号\n\n\n单、双、三引号的使用：  &#x27;这里有个&quot;双引号&quot;哦&#x27; &quot;这里有个&#x27;单引号&#x27;嘎&quot;&#x27;&#x27;&#x27; 这里既有&#x27;单引号&#x27;嘎，又有&quot;双引号&quot;哦  &#x27;&#x27;&#x27;\n\n字符串排序\n正向递增序号以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；\n反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。\n\n字符串字符的获取\n假设变量name为一字符串，其中N、M均为索引号：\n获取单个字符：name[N];\n获取一段字符串：name[N:M];\n根据步长K切片：name[N:M:K];\n\n\n\n字符串的操作符、处理函数和方法字符串的操作符\nx+y\n连接两个字符串x和y\n字符串连接方法\n\n\nx*n\n复制n次字符串x\n\n\nx in s\n判断x是否是s的子串，，是返回true，否返回false\n\n\n\n字符串常用处理函数和方法\nlen(x)：返回字符串长度\nstr(x)：任意类型x对应的字符串形式\nstr.lower()/upper()\n返回新的字符串，全部字符小写/大写\n\n\nstr.split(sep)\n返回的是一个列表，将源字符串按照sep进行分割\n\n\nstr.count(sub)\n返回字串sub在str中出现的次数\n\n\nstr.replace(old,new)\n返回新的字符串，将str中所有old子串替换为new\n\n\nstr.center(width[,fillchart])\n字符串str根据宽度width居中，fillchart为剩余区域的填充字符\n\n\nstr.join(item)\n在item除最后一个元素外增加一个str\n多用于字符串分割\n\n\n\n字符串类型格式化\n&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)\n槽：\n槽内部对格式化的配置方式\n\n&gt;&gt;&gt; &quot;&#123;0:=^20&#125;.format(&quot;python&quot;)&quot;&#x27;=======PYTHON======&#x27;\n\n","categories":["python"],"tags":["study notes","python"]},{"title":"Python学习笔记（三）","url":"/2021/03/22/python-study-notes-3/","content":"程序控制结构是每一种程序设计语言都会涉及到的一块，这边文章就来讲讲python中的程序设计结构。\n条件语句用于条件组合的三个保留字设x，y为两个条件：\n\n\n\n操作符\n描述\n\n\n\nx and y\n逻辑与\n\n\nx or y\n逻辑或\n\n\nnot x\n逻辑非\n\n\n单分支结构\n单分支结构的定义想必大家也比较清楚了。条件语句中单分支结构写法如下：if 判断条件:    执行语句\n当条件符合时，执行相应的语句；不符合时则跳过。*\n\n二分支结构\n二分支增添了else这个保留字，和if一起使用，及满足判断条件执行if中的内容，不满足就执行else中内容：\nif 判断条件:    执行语句else：    执行语句\n多分支结构\n多分支结构在二分支的结构上引入了elif这个保留字，实际上等价于C语言中的else if：\nif 判断条件:    执行语句elif 判断条件:    执行语句......else:    执行语句\n\n循环语句for循环\npython中的for循环需要和保留字in进行搭配使用，即：for 元素 in 迭代对象:    执行语句\n这里我们要注意的是for语句是从可迭代的对象中依次取出每一个元素，然后再进行操作。\n\n\n和range()函数一起使用：\nrange()用于生成一个可迭代的对象\nrange(start, stop[, step])for i in range(3):    print(i)012----------------------------for i in range(1,3):    print(i)12----------------------------for i in range(1,5,2):    print(i)13\n\n\n列表，元组，集合，字符串#遍历列表a = [1,2,3]for i in a:    print(i)123----------------------------#遍历元组b = (&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;)for i in b:    print(i)helloworld!----------------------------#遍历集合c = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;&#125;for i in c:    print(i)helloworld!----------------------------#遍历字符串d = &quot;python&quot;for i in d:    print(i)python\n字典e = &#123;&#x27;name&#x27;:&#x27;sun&#x27;,&#x27;habit&#x27;:&#x27;sunshine&#x27;&#125;#遍历键值对for i,j in e.items():    print(i,j)name sunhabit sunshine----------------------------#遍历键for i in e.keys():    print(i)namehabit----------------------------#遍历值for i in e.values():    print(i)sunsunshine\n文件\n\n\nfi是一个文件标识符，遍历其每行，产生循环\nfor line in fi:    &lt;语句块&gt;\nwhile循环\n使用方法：\n\n当条件判断为True时，执行语句块；\n当条件判断为False时，循环终止。while &lt;条件&gt;：    &lt;语句块&gt;\n\n\n与else同用：\n\n当while语句条件为true时，执行语句块内容，为false时执行else语句中的内容。while &lt;条件&gt;:    &lt;语句块&gt;else:    &lt;语句块&gt;\n\n\n\n循环保留字：continue和breakcontinue\n被用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环\n\nbreak\n可以跳出 for 和 while 的循环体\nbreak仅跳出当前最内层循环\n示例：for i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        continue    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)PYTHON正常退出\nfor i in &quot;PYTHON&quot;:    if i == &quot;T&quot;:        break    print(i,end=&quot;&quot;)    else:        print(&quot;正常退出&quot;)\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python学习笔记（四）","url":"/2021/03/27/python-study-notes-4/","content":"函数的使用函数定义在Python中我们时常会使用函数来提高代码的效率和复用性，函数的定义如下：\ndef &lt;函数名&gt;(&lt;参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n\n这里def保留字用于声明函数，必须填写。\n\n参数设置\n参数设置主要有四类：必选参数、默认参数、可选参数、关键字参数\n\ndef &lt;函数名&gt;(&lt;必选参数&gt;,&lt;默认参数&gt;&lt;可选参数&gt;&lt;关键字参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n下面以计算n!这个函数为例子来介绍这些参数：\n必选参数传递\n当函数只有一个参数时默认该参数为必选参数\n\n默认参数传递\n优势：减低函数的难度\ntips：默认参数必须指向不变对象\n下面例子当中的参数m就是可选参数，def fact(n,m=1):    s = 1    for i in range(1,n+1):        s *= i    return s//m\n\n可变参数传递\n传入参数的个数是可变的。\n在参数前面加上*就是可变参数。\n在函数内部，参数numbers接收得到的是一个tuple，调用该函数时，可以传入任意个参数，包括0个参数def num(*fail):    total = 0    for i in fail:        total += i    return total\n这里fail可以接受多个参数的传递，如下所示：print(num(1,2))3print(num(4,5,6))15\n\n关键字参数传递\n使用**表示关键字参数def action(time,person,**job):    print(&quot;At&quot;,time,person,&quot;wants to&quot;,job)action(&#x27;7:00&#x27;,&#x27;Mom&#x27;,job = &#x27;clean house&#x27;)At 7:00 Mom wants to &#123;&#x27;job&#x27;: &#x27;clean house&#x27;&#125;\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"大数据分析实验（一）","url":"/2021/04/01/Big-data-analysis-experiment-1/","content":"Python 快速开发实验目的和要求\n熟悉 Python 开发环境；\n掌握项目和文件的建立；\n掌握 Python 的基本语法；\n\n实验内容和分析题目一：自定义函数，设置固定次数的登陆题目内容\n由键盘输入密码；\n若密码正确则屏幕显示：“Login success!”\n若密码错误则显示：“Wrong password or invalid input”，并显示剩余输入机会次数；\n共 3 次机会，用完则屏幕显示：“Your account has been suspended”，并退出程序。\n\n解题思路① 首先创建一个文件模拟数据库用于存储用户的账户和密码② 通过读取用户的输入来和文件中的账户密码进行比较③ 如果存在则显示登陆成功，否则显示登陆失败④ 定义一个变量用于存储用户失败次数，当失败次数大于3后，显示账户已被锁定然后结束程序。\n实验设计① 定义一个函数其参数为用户输入的用户名和密码，该函数将数据库文件打开然后按照存储形式进行比较，如果存在就返回True否则返回False② 主函数定义变量frequency用于标记用户登陆失败次数③ 利用while语句实现失败重新登陆这一过程；当匹配成功跳出循环，当超过三次也跳出循环结束程序。\n考察知识\n函数定义\n文件操作\nwhile语句\n\n实验代码#定义账号密码文件#读取文件，验证用户输入的账号密码是否在文件内#存在返回true，不存在返回falsedef Login_authentication(user, pwd):    f = open(&quot;information.txt&quot;, mode=&quot;r&quot;, encoding=&quot;UTF-8&quot;)    for line in f:        #按照你在文件中对字符串的存储方式来进行字符串比较        if line.strip() == user + &quot;-&quot; + pwd:            f.close()            return True    else:        f.close()        return False#存储错误次数frequency = 0while frequency &lt; 3:    #读取用户输入调用验证函数    user_name = input(&quot;Please enter user name：&quot;)    user_password = input(&quot;Please enter user password:&quot;)    ret = Login_authentication(user_name,user_password)    if ret:        print(&quot;Login success!&quot;)        break    else:        frequency += 1        if frequency == 3:            print(&quot;Your account has been suspended&quot;)        else:            print(&quot;Wrong password or invalid input,remaining times:&#123;&#125;&quot;.format(3-frequency))            print(end=&quot;\\n&quot;)\n\n实验结果\n运行结果：\n数据库文件：\n\n题目二：自定义函数, 将敏感词过滤后的文本写入指定位置的 txt题目内容\n自定义函数 texcreat(name,text),将 text 写入“name.txt”文件中\n自定义函数 Repalce,将某些敏感词(比如“暴力”)替换成“**”\n自定义函数将敏感词过滤后的文本写入指定 txt 文档中。\n\n解题思路① 创建一个文件用于存储定义敏感词；② 将用户输入的一句话作为参数传到敏感词过滤函数当中；③ 遍历该函数通过敏感词读取函数返回的由敏感词组成的列表比较该句话中是否存在敏感词，如果存在则将对应敏感词的字符长度存储下来然后用*来替代；④ 最后再将过滤完成的句子存放到以用户输入的文件名而创建的文件当中。\n实验设计① 创建一个存放敏感词的文件sensitive_word，输入一些敏感词存入到里面；② 定义一个函数read_sensitive_word函数用于读取文件中的敏感词然后将其存放在列表中，将存储敏感词的列表当作值进行返回；③ 创建一个函数texcreat用于接收用户输入的文件名然后创建这个文件，并将过滤敏感词后的句子存到该文件中；④ 定义一个函数Replace用于过滤敏感词；⑤ 主函数通过接受用户输入，先后调用过滤函数、读取敏感词函数、创建文件函数，然后结束程序。\n考察知识\n函数\n文件操作\n字符串操作\n\n实验代码#读取敏感词语文件def read_sensitive_word():    with open(&#x27;sensitive_word.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as file_to_read:        lines = list()        for line in file_to_read.readlines():            if line is not None:                #去除字符串前后的空格，然后将字符串写入列表中                lines.append(line.strip(&#x27;\\n&#x27;))    return lines#创建文件，将过滤后的内容写入def texcreat(name,text):    file = open(name+&#x27;.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)    file.write(text)    file.close()#过滤敏感词def Replace(word):    sensitive_word = read_sensitive_word()    for line in sensitive_word:        if line in word:            #获取对应敏感词长度            word_length = len(line)            #将敏感词进行替换            word = word.replace(line, &#x27;*&#x27; * word_length)    return wordname = input(&quot;请输入文件名：&quot;)sentence = input(&quot;请输入你想说的话：&quot;)texcreat(name,Replace(sentence))\n\n实验结果\n运行结果：\n敏感词文件：\n\n题目三：电子抽奖器模拟题目内容&emsp;&emsp;商店街上新开了一家超市，经营各种生活用品、食品、电器等。经营者是一对年轻夫妇， 为了纪念开业，他们举行了为期一个周的抽奖活动，并到处广告宣传，说这次抽奖平均 100 人就能有 1 人获得一等奖。首次宣传，促销期间门庭若市。 但最近商业街一些老店主跑来告状，说那家店在抽奖促销期间每天客流明显超过 100 人，然而一周过去了，抽中开业纪念大奖的只有 5 个人。请你模拟一下电子抽奖器，分析一下一周 5 个人中奖是否正常？\n解题思路① 利用random函数来随机生成数用于模拟中奖情况；② 循环多次来代替随机抽样，最后以数值型呈现出最终概率。\n实验设计① 定义一个“抽奖函数”利用random库中的randint方法在0-9之间随机生成一个数，当数小于1时为真，大于1时为假，用于实现中奖概率为1%的条件；② 在主函数中利用for循环循环多次实现模拟情况然后每次循环都调用“抽奖函数”，以其返回值作为判断依据然后统计最终的中奖次数。\n考察知识\n函数\nrandom库\n\n实验代码import random# 判断中奖函数def lottery():    flag = random.randint(0, 9)    if flag &lt; 1:        return True    else:        return Falseif __name__ == &#x27;__main__&#x27;:    # 中奖次数    a = 0    # 没有中奖次数    b = 0    for i in range(1000000):        if (lottery()):            a += 1        else:            b += 1print(&#x27;共计中奖：&#x27;, a, &#x27;，未中奖：&#x27;, b)\n\n实验结果\n运行结果：\n\n题目四：小说《Walden》单词词频统计题目内容&emsp;&emsp;Walden 中文译名《瓦尔登湖》，是美国作家梭罗独居瓦尔登湖畔的记录，描绘了他两年多时间里的所见、所闻和所思。该书崇尚简朴生活，热爱大自然的风光，内容丰厚，意义深远，语言生动。请用 Python 统计小说 Walden 中各单词出现的频次，并按频次由高到低排序。\n解题思路① 读取文件；② 为了避免因为大小写情况导致统计出错，先将所有大写字母转为小写字母；③ 截取字符串，然后将单词和出现次数以键值对的形式存储在字典中然后输出。\n考察知识\n字符串\n文件操作\n字典\n\n实验代码import re#读取文件file = open(&#x27;Walden.txt&#x27;,&#x27;r&#x27;)text = file.read()file.close()#将所有英文字母变成小写text = text.lower()#使用正则表达式用空格替换标点符号text = re.sub(&#x27;[,.?:;&quot;\\&#x27;]&#x27;,&#x27;&#x27;,text)#以空格为分隔符截取字符串words = text.split(&quot; &quot;)#创建统计单词的字典word_sq = &#123;&#125;#统计单词出现个数存入字典中for i in words:    if i not in word_sq.keys():        word_sq[i] = 1    else:        word_sq[i] += 1#按照字典的值进行排序res = sorted(word_sq.items(),key=lambda x:x[1], reverse=True)print(&quot;单词 出现次数&quot;)for i in res:    print(i[0],i[1])\n\n实验结果\n运行结果：\n\n","categories":["experiment"],"tags":["big data analysis experiment","experiment"]},{"title":"Python学习笔记（五）","url":"/2021/04/03/python-study-notes-5/","content":"组合数据类型集合基本内容\n定义：包含0个或多个数据项的无序组合\n特点：\n元素之间无序，每个元素唯一，不存在相同元素\n元素不可更改，不能是可变数据类型\n用大括号 {} 表示，元素间用逗号分隔\n\n\n创建方式：建立集合类型用 {} 或 set()\ntips：空集合必须用set()创建&gt;&gt;&gt; A = &#123;&quot;python&quot;, 123, (&quot;python&quot;,123)&#125;&#123;123, &#x27;python&#x27;, (&#x27;python&#x27;, 123)&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; C = &#123;&quot;python&quot;, 123, &quot;python&quot;,123&#125;&#123;&#x27;python&#x27;, 123&#125;\n\n集合间操作\n\n\n操作符\n描述\n\n\n\nS\nT\n\n\nS - T\n返回一个新集合，包括在集合S但不在T中的元素\n\n\nS &amp; T\n返回一个新集合，包括同时在集合S和T中的元素\n\n\nS ^ T\n返回一个新集合，包括集合S和T中的非相同元素\n\n\nS &lt;= T 或 S &lt; T\n返回True/False，判断S和T的子集关系\n\n\ns &gt;= T 或 S &gt; T\n返回True/False，判断S和T的包含关系\n\n\nS -= T\n更新集合S，包括在集合S但不在T中的元素\n\n\nS &amp;= T\n更新集合S，包括同时在集合S和T中的元素\n\n\nS ^= T\n更新集合S，包括集合S和T中的非相同元素\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; B = set(&quot;pypy123&quot;)#并运算&gt;&gt;&gt; A|B&#123;&#x27;1&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;y&#x27;, &#x27;3&#x27;, 123&#125;#交运算&gt;&gt;&gt; A&amp;B&#123;&#x27;p&#x27;, &#x27;y&#x27;&#125;#非相同元素&gt;&gt;&gt; A^B&#123;&#x27;2&#x27;, 123, &#x27;3&#x27;, &#x27;1&#x27;&#125;#差运算&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;&#x27;3&#x27;, &#x27;1&#x27;, &#x27;2&#x27;&#125;\n\n集合处理方法\n\n\n操作函数\n描述\n\n\n\nS.add(x)\n如果x不在集合S中，将x增加到S\n\n\nS.discard(x)\n移除S中元素x，如果x不在集合S中，不报错\n\n\nS.remove(x)\n移除S中元素x，如果x不在集合S中，产生KeyError异常\n\n\nS.clear()\n移除S中所有元素\n\n\nS.pop()\n随机返回S的一个元素，更新S，若S为空产生KeyError异常\n\n\nS.copy()\n返回集合S的一个副本\n\n\nlen(S)\n返回集合S的元素个数\n\n\nx in S\n判断S中元素x，x在集合S中，返回True，否则返回False\n\n\nx not in S\n判断S中元素x，x不在集合S中，返回False，否则返回True\n\n\nset(x)\n将其他类型变量x转变为集合类型\n\n\n&gt;&gt;&gt; A = &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;&gt;&gt;&gt; for item in A:        print(item, end=&quot;&quot;)p123y&gt;&gt;&gt; A&#123;&#x27;p&#x27;, 123, &#x27;y&#x27;&#125;&gt;&gt;&gt; try:        while True:            print(A.pop(), end=&quot;&quot;))    except:        passp123y&gt;&gt;&gt; Aset()\n\n应用场景\n包含关系比较：&gt;&gt;&gt; &quot;p&quot; in &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;True&gt;&gt;&gt; &#123;&quot;p&quot;, &quot;y&quot;&#125; &gt;= &#123;&quot;p&quot;, &quot;y&quot; , 123&#125;False\n数据去重：&gt;&gt;&gt; ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, 123]&gt;&gt;&gt; s = set(ls)&#123;&#x27;p&#x27;, &#x27;y&#x27;, 123&#125;&gt;&gt;&gt; lt = list(s) [&#x27;p&#x27;, &#x27;y&#x27;, 123]\n\n总结\n集合使用{}和set()函数创建\n集合间操作：交(&amp;)、并(|)、差(-)、补(^)、比较(&gt;=&lt;)\n集合类型方法：.add()、.discard()、.pop()等\n集合类型主要应用于：包含关系比较、数据去重\n\n序列类型序列类型及操作序列类型定义\n序列是具有先后关系的一组元素。\ntips：\n序列是一维元素向量，元素类型可以不同\n类似数学元素序列： s0, s1,    … ,    sn-1\n元素间由序号引导，通过下标访问序列的特定元素\n\n\n序列是一个基类类型包括：\n字符串类型\n元组类型\n列表类型\n\n\n\n操作符\n\n\n操作符及应用\n描述\n\n\n\nx in s\n如果x是序列s的元素，返回True，否则返回False\n\n\nx not in s\n如果x是序列s的元素，返回False，否则返回True\n\n\ns + t\n连接两个序列s和t\n\n\ns * n 或 n * s\n将序列s复制n次\n\n\ns[i]\n索引，返回s中的第i个元素，i是序列的序号\n\n\ns[i: j] 或 s[i: j: k]\n切片，返回序列s中第i到j以k为步长的元素子序列\n\n\n函数和方法\n\n\n函数和方法\n描述\n\n\n\nlen(s)\n返回序列s的长度\n\n\nmin(s)\n返回序列s的最小元素，s中元素需要可比较\n\n\nmax(s)\n返回序列s的最大元素，s中元素需要可比较\n\n\ns.index(x) 或 s.index(x, i, j)\n返回序列s从i开始到j位置中第一次出现元素x的位置\n\n\ns.count(x)\n返回序列s中出现x的总次数\n\n\n元组类型定义\n元组是序列类型的一种扩展\n元组是一种序列类型，一旦创建就不能被修改\n使用小括号 () 或 tuple() 创建，元素间用逗号 , 分隔\n可以使用或不使用小括号\n\n&gt;&gt;&gt; creature = &quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, &quot;human&quot;&gt;&gt;&gt; creature(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;)&gt;&gt;&gt; color = (0x001100,\t&quot;blue&quot;, creature)&gt;&gt;&gt; color(4352, &#x27;blue&#x27;, (&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;))\n\n操作\n元组继承了序列类型的全部通用操作\n元组因为创建后不能修改，因此没有特殊操作\n使用或不使用小括号\n\n列表类型定义\n列表是一种序列类型，创建后可以随意被修改\n使用方括号 [] 或list() 创建，元素间用逗号 , 分隔\n列表中各元素类型可以不同，无长度限制\n\n操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nls[i] = x\n替换列表ls第i元素为x\n\n\nls[i: j: k] = lt\n用列表lt替换ls切片后所对应元素子列表\n\n\ndel ls[i]\n删除列表ls中第i元素\n\n\ndel ls[i: j: k]\n删除列表ls中第i到第j以k为步长的元素\n\n\nls += lt\n更新列表ls，将列表lt元素增加到列表ls中\n\n\nls *= n\n更新列表ls，其元素重复n次\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls[1:2] = [1, 2, 3, 4][&#x27;cat&#x27;, 1, 2, 3, 4, &#x27;tiger&#x27;, 1024]&gt;&gt;&gt; del ls[::3] [1, 2, 4, &#x27;tiger&#x27;]&gt;&gt;&gt; ls*2[1, 2, 4, &#x27;tiger&#x27;, 1, 2, 4, &#x27;tiger&#x27;]\n\n\n\n\n函数或方法\n描述\n\n\n\nls.append(x)\n在列表ls最后增加一个元素x\n\n\nls.clear()\n删除列表ls中所有元素\n\n\nls.copy()\n生成一个新列表，赋值ls中所有元素\n\n\nls.insert(i,x)\n在列表ls的第i位置增加元素x\n\n\nls.pop(i)\n将列表ls中第i位置元素取出并删除该元素\n\n\nls.remove(x)\n将列表ls中出现的第一个元素x删除\n\n\nls.reverse()\n将列表ls中的元素反转\n\n\n&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; ls.append(1234)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024, 1234]&gt;&gt;&gt; ls.insert(3, &quot;human&quot;)[&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, &#x27;human&#x27;, 1024, 1234]&gt;&gt;&gt; ls.reverse()[1234, 1024, &#x27;human&#x27;, &#x27;tiger&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;]\n\n应用场景\n元组用于元素不改变的应用场景，更多用于固定搭配场景\n列表更加灵活，它是最常用的序列类型\n最主要作用：表示一组有序数据，进而操作它们\n元素遍历:for item in ls :    &lt;语句块&gt;\n数据保护：如果不希望数据被程序所改变，转换成元组类型&gt;&gt;&gt; ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&gt;&gt;&gt; lt = tuple(ls)&gt;&gt;&gt; lt(&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;tiger&#x27;, 1024)\n\n小结\n序列是基类类型，扩展类型包括：字符串、元组和列表\n元组用()和tuple()创建，列表用[]创建\n元组操作与序列操作基本相同\n列表操作在序列操作基础上，增加了更多的灵活性\n\n字典类型字典类型定义\n字典类型是“映射的体现”\n键值对：键是数据索引的扩展\n字典是键值对的集合，键值对之间无序\n采用大括号{}和dict()创建，键值对用冒号表示\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d&#123;&#x27;中国&#x27;: &#x27;北京&#x27;, &#x27;美国&#x27;: &#x27;华盛顿&#x27;, &#x27;法国&#x27;: &#x27;巴黎&#x27;&#125;&gt;&gt;&gt; d[&quot;中国&quot;]&#x27;北京&#x27;&gt;&gt;&gt; de = &#123;&#125; &gt;&gt;&gt; type(de)&lt;class &#x27;dict&#x27;&gt;\n\n字典类型操作方法\n\n\n函数或方法\n描述\n\n\n\ndel d[k]\n删除字典d中键k对应的数据值\n\n\nk in d\n判断键k是否在字典d中，如果在返回True，否则False\n\n\nd.keys()\n返回字典d中所有的键信息\n\n\nd.values()\n返回字典d中所有的值信息\n\n\nd.items()\n返回字典d中所有的键值对信息，以元组形式返回\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; &quot;中国&quot; in dTrue&gt;&gt;&gt; d.keys()dict_keys([&#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;法国&#x27;])&gt;&gt;&gt; d.values()dict_values([&#x27;北京&#x27;, &#x27;华盛顿&#x27;, &#x27;巴黎&#x27;])\n\n字典类型操作函数和方法\n\n\n函数或方法\n描述\n\n\n\nd.get(k, )\n键k存在，则返回相应值，不在则返回值\n\n\nd.pop(k, )\n键k存在，则取出相应值，不在则返回值\n\n\nd.popitem()\n随机从字典d中取出一个键值对，以元组形式返回\n\n\nd.clear()\n删除所有的键值对\n\n\nlen(d)\n返回字典d中元素的个数\n\n\n&gt;&gt;&gt; d = &#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; d.get(&quot;中国&quot;,&quot;伊斯兰堡&quot;)&#x27;北京&#x27;&gt;&gt;&gt; d.get(&quot;巴基斯坦&quot;,&quot;伊斯兰堡&quot;)&#x27;伊斯兰堡&#x27;&gt;&gt;&gt; d.popitem()(&#x27;美国&#x27;, &#x27;华盛顿&#x27;)\n\n小结\n映射关系采用键值对表达\n字典类型使用{}和dict()创建，键值对之间用 : 分隔\nd[key] 方式既可以索引，也可以赋值\n字典类型有一批操作方法和函数，例如.get()\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 学习笔记（六）","url":"/2021/04/05/python-study-notes-6/","content":"文件操作文件概述定义和分类\n定义：文件是一个存储在辅助存储器上的数据序列，可以包含任何数据内容。\n概念上:文件是数据的集合和抽象。\n优点：组织和表达数据更有效、更灵活。\n分类：文本文件和二进制文件。\n\n文本文件和二进制文件\n\n\n比较项\n文本文件\n二进制文件\n\n\n\n定义\n由文本字符为内容的文件\n直接由比特0和1组成\n\n\n字符编码\n是\n否\n\n\n读取方式\n文件经编码形成字符串，打印出含有意义的字符\n文件被解析为字节（比特）流\n\n\n表示形式\n一个字符由2个字节表示\n单一字节表示\n\n\ntextFile = open(&quot;7.1.txt&quot;,&quot;rt&quot;) #t表示文本文件方式print(textFile.readline())textFile.close()binFile = open(&quot;7-1.txt&quot;,&quot;rb&quot;)\t#r表示二进制文件方式print(binFile.readline())binFile.close()\n&gt;&gt;&gt;中国是个伟大的国家！ b&#x27;\\xd6\\xd0\\xb9\\xfa\\xca\\xc7\\xb8\\xf6\\xce\\xb0\\xb4\\xf3\\xb5\\xc4\\xb9\\xfa\\xbc\\xd2\\xa3\\xa1&#x27;\n\n文件操作文件打开和关闭\n文件打开函数: open()\n表示方法：\n&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)\n文件名可以是文件的实际名字，也可以是包含完整路径的名字。\n\n\n打开模式举例：\n\n\n\n\n打开模式\n含义\n\n\n\n‘r’\n只读模式，如果文件不存在，返回异常FileNotFoundError，默认值\n\n\n‘w’\n覆盖写模式，文件不存在则创建，存在则完全覆盖源文件\n\n\n‘x’\n创建写模式，文件不存在则创建，存在则返回异常FileExistsError\n\n\n‘a’\n追加写模式，文件不存在则创建，存在则在原文件最后追加内容\n\n\n‘b’\n二进制文件模式\n\n\n‘t’\n文本文件模式，默认值\n\n\n‘+’\n与r/w/x/a一同使用，在原功能基础上增加同时读写功能\n\n\n文件读写定义a为一文件：\n\n文件读取：\n\n\n\n\n方法\n含义\n\n\n\na.readall()\n读入整个文件内容，返回一个字符串或字节流*\n\n\na.read(size=-1)\n从文件中读入整个文件内容，如果给出参数，读入前size长度的字符串或字节流\n\n\na.readline(size = -1)\n从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流\n\n\na.readlines(hint=-1)\n从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行\n\n\n\n文件写入：\n\n\n\n\n方法\n含义\n\n\n\na.write(s)\n向文件写入一个字符串或字节流\n\n\na.writelines(lines)\n将一个元素为字符串的列表写入文件\n\n\na.seek(offset)\n改变当前文件操作指针的位置，offset的值： 0：文件开头； 1: 当前位置； 2: 文件结尾\n\n\n","categories":["python"],"tags":["python","study-notes"]},{"title":"Python 实验一 Python运行环境搭建及使用","url":"/2021/04/05/python-experiment-1/","content":"实验目的\n熟悉 Python 开发环境的使用\n熟悉 Python 应用程序的创建与运行\n掌握 Python 输入与输出实验内容练习一题目分别用交互模式和批量模式完成以下代码的练习。str1=input(&quot;请输入一个人的名字：&quot;)str2=input(&quot;请输入一个国家的名字：&quot;)print(&quot;世界这么大，&#123;&#125;想去&#123;&#125;看看&quot;.format(str1,str2))\n练习二题目整数序列求和：用户输入一个正整数 N,计算从 1 到 N(包含 1 和 N)相加之后的结果。代码N = input(&quot;请输入一个正整数N：&quot;)sum = 0for i in range (int(N)):    sum += i + 1print(&quot;1到N相加后的结果为：&quot;,sum)\n练习三题目健康食谱输出：列出 5 种不同的食材，输出它们可能组成的所有菜式名称。代码array = [&#x27;土豆&#x27;,&#x27;豇豆&#x27;,&#x27;辣椒&#x27;,&#x27;五花肉&#x27;,&#x27;豆腐&#x27;]for i in range(0,5):    for j in range(0,5):        if not(i==j):            print(&quot;&#123;&#125;&#123;&#125;&quot;.format(array[i],array[j]))\n练习四题目太阳花的绘制：使用 turtle 库绘制一个太阳花的图形，如下图所示。￼代码from turtle import *color(&#x27;red&#x27;,&#x27;yellow&#x27;)begin_fill()while True:    forward(200)    left(170)    if abs(pos())&lt;1:        breakend_fill()done()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十 Tkinter的使用（1）","url":"/2021/04/05/python-experiment-10/","content":"实验目的\n掌握 tkinter 的使用\n熟悉可视化界面的设计方法实验内容题目完成以下代码，熟悉 tkinter 各个部件的使用代码#(1) 创建主窗口及 Label 部件（标签）创建使用import tkinter as tk# SY11-1window = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)l = tk.Label(window,text =&#x27;你好！欢迎使用Python tkinter!&#x27;,bg = &#x27;AliceBlue&#x27;,font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()window.mainloop()#（2）Button 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;First Example&#x27;)window.geometry(&#x27;500x300&#x27;)var = tk.StringVar()l = tk.Label(window,textvariable = var,bg = &#x27;AliceBlue&#x27;,    font = (&#x27;Arial&#x27;,12), width=30, height=2)l.pack()on_hit = Falsedef touch():    global on_hit    if on_hit == False:        on_hit = True        var.set(&#x27;你点击了确认按钮&#x27;)    else:        on_hit = False        var.set(&#x27;&#x27;)b = tk.Button(window,text=&#x27;确认&#x27;,font=(&#x27;Arial&#x27;,12),width = 10,              height=1,command = touch)b.pack()window.mainloop()#（3）Entry 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-3&#x27;)window.geometry(&#x27;500x300&#x27;)e1 = tk.Entry(window,show=&#x27;*&#x27;,font=(&#x27;Arial&#x27;,14))e2 = tk.Entry(window,show=None,font=(&#x27;Arial&#x27;,14))e1.pack()e2.pack()window.mainloop()#（4）Text 窗口部件import tkinter as tkwindow = tk.Tk()window.title(&#x27;SY11-4&#x27;)window.geometry(&#x27;500x300&#x27;)e = tk.Entry(window,show = None)e.pack()def insert_point():    var = e.get()    t.insert(&#x27;insert&#x27;,var)def insert_end():    var = e.get()    t.insert(&#x27;end&#x27;,var)b1 = tk.Button(window,text=&#x27;insert point&#x27;,width = 10,               height = 2,command = insert_point)b1.pack()b2 = tk.Button(window,text=&#x27;insert end&#x27;,width = 10,               height = 2,command = insert_end)b2.pack()t = tk.Text(window,height = 3)t.pack()window.mainloop()#（5）Canvas 窗口部件import tkinter as tk # 使用 Tkinter 前需要先导入window = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)canvas = tk.Canvas(window, bg=&#x27;AliceBlue&#x27;, height=200, width=500)image_file = tk.PhotoImage(file=&#x27;123.gif&#x27;)image = canvas.create_image(250, 0, anchor=&#x27;n&#x27;,image=image_file)x0, y0, x1, y1 = 100, 100, 150, 150line = canvas.create_line(x0-50, y0-50, x1-50, y1-50)oval = canvas.create_oval(x0+120, y0+50, x1+120, y1+50, fill=&#x27;yellow&#x27;)arc = canvas.create_arc(x0, y0+50, x1, y1+50, start=0, extent=180)rect = canvas.create_rectangle(330, 30, 330+20, 30+20)canvas.pack()def moveit():    canvas.move(rect, 2, 2)b = tk.Button(window, text=&#x27;move item&#x27;,command=moveit).pack()window.mainloop()#（6）messageBox 窗口部件import tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)def hit_me(): tkinter.messagebox.showinfo(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;) # tkinter.messagebox.showwarning(title=&#x27;Hi&#x27;, message=&#x27;有警告！&#x27;) # 提出 # tkinter.messagebox.showerror(title=&#x27;Hi&#x27;, message=&#x27;出错了！&#x27;) # 提出错 # print(tkinter.messagebox.askquestion(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # 询问选择对话窗 return &#x27;yes&#x27;, &#x27;no&#x27; # print(tkinter.messagebox.askyesno(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27; # print(tkinter.messagebox.askokcancel(title=&#x27;Hi&#x27;, message=&#x27;你好！&#x27;)) # return&#x27;True&#x27;, &#x27;False&#x27;tk.Button(window, text=&#x27;hit me&#x27;, bg=&#x27;green&#x27;, font=(&#x27;Arial&#x27;, 14), command=hit_me).pack()window.mainloop()#（7）窗口部件三种放置方式 pack/grid/place#7-1import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)for i in range(3):    for j in range(3):        tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10,ipadx=10, ipady=10)window.mainloop()#7-2import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;top&#x27;) # 上tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;bottom&#x27;) # 下tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;left&#x27;) # 左tk.Label(window, text=&#x27;P&#x27;, fg=&#x27;red&#x27;).pack(side=&#x27;right&#x27;) # 右window.mainloop()#7-3import tkinter as tkwindow = tk.Tk()window.title(&#x27;My Window&#x27;)window.geometry(&#x27;500x300&#x27;)tk.Label(window, text=&#x27;Pl&#x27;, font=(&#x27;Arial&#x27;, 20), ).place(x=50, y=100, anchor=&#x27;nw&#x27;)window.mainloop()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十二 数据分析与可视化（1）","url":"/2021/04/05/python-experiment-12/","content":"实验目的1、 熟悉 numpy 库常用方法的使用2、 熟悉 pandas 库的基本使用3、 能够利用 matplotlib 库进行简单的图形绘制\n实验内容题目根据某商品近 5 年的销售流水，做数据分析和可视化。模拟产生数据代码如下：￼\n（1）编写程序生成某商品(2014-01-01 到 2018-12-31)的销售流水，模拟数据文件名为 data.csv，数据格式如下：（说明：日期是连续的，销量是随机数，单价范围为[101，105]的随机值）￼\n代码import randomimport datetimeimport csvfn = &#x27;data.csv&#x27;with open(fn,&#x27;w&#x27;) as fp:    wr = csv.writer(fp)    wr.writerow([&#x27;日期&#x27;,&#x27;销量&#x27;,&#x27;单价&#x27;])    startDate = datetime.date(2014,1,1)    for i in range(1825):        amount = 300+i*5+random.randrange(100)        price = 100+random.randint(1,5)        wr.writerow([str(startDate),amount,price])        startDate = startDate+datetime.timedelta(days=1)\n（2）使用 pandas 读取文件 data.csv 中的数据，创建 DataFrame 对象，并删除其中所有缺失值；代码import pandas as pddf = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()\n（3）使用 matplotlib 生成折线图，反映每月的销量情况，并把图形保存为本地文件 one.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:7])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot()plt.savefig(&#x27;one.jpg&#x27;)plt.show()\n结果￼\n（4）按年进行统计，使用 matplotlib 绘制柱状图显示每年的营业额，并把图形保存为本地文件 two.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;two.jpg&#x27;)plt.show()\n结果￼\n（5）按年进行统计，使用 matplotlib 绘制柱状图显示每年销售量最大的月份及销售额，并把图形保存为本地文件 three.jpg；代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).max()# print(group_month_quantity)group_month_quantity.plot.bar()plt.savefig(&#x27;three.jpg&#x27;)plt.show()\n结果￼\n（6）按年度统计该商品的营业额数据，使用 matplotlib 生成饼状图显示每年都的营业额分布情况，并把图形保存为本地文件 four.jpg。代码import matplotlib.pyplot as pltimport pandas as pdplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;df = pd.DataFrame(pd.read_csv(&#x27;data.csv&#x27;,encoding=&#x27;gbk&#x27;))df.dropna()df[&#x27;日期&#x27;] = df[&#x27;日期&#x27;].apply(lambda x: x[:4])# print(df[&#x27;日期&#x27;])data_quantity = df.iloc[:,0:2]# print(data_quantity)group_month_quantity = data_quantity.groupby(&#x27;日期&#x27;).sum()# print(group_month_quantity)group_month_quantity.plot.pie(subplots=True)plt.savefig(&#x27;four.jpg&#x27;)plt.show()\n结果￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十一 Tkinter的使用（2）","url":"/2021/04/05/python-experiment-11/","content":"实验目的掌握界面程序的设计\n实验内容练习一题目：用户登陆界面程序编写一个用户登录界面，用户可以登录账户信息，如果账户已经存在，可以直接登录，登录名或者登录密码输入错误会提示，如果账户不存在，提示用户注册，点击注册进去注册页面，输入注册信息，确定后便可以返回登录界面进行登录。\n代码import pickleimport tkinter as tkimport tkinter.messageboxwindow = tk.Tk()window.title(&#x27;登 录&#x27;)window.geometry(&#x27;500x400&#x27;)l1 = tk.Label(window,text=&#x27;用户名：&#x27;,font= 12).place(x=100,y=82)l2 = tk.Label(window,text=&#x27;密  码：&#x27;,font= 12).place(x=100,y=152)var_user_name = tk.StringVar()entry_user_name = tk.Entry(window,textvariable=var_user_name,font= 18,width=30,bd =5)entry_user_name.place(x=180,y=80)var_user_password = tk.StringVar()entry_user_password = tk.Entry(window,textvariable=var_user_password,show=&#x27;*&#x27;,font= 18,width=30,bd =5)entry_user_password.place(x=180,y=150)def user_login_in():    user_name = var_user_name.get()    user_password = var_user_password.get()    try:        with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:            user_info = pickle.load(user_file)    except FileNotFoundError:        with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:            user_info = &#123;&#x27;admin&#x27;:&#x27;admin&#x27;&#125;            pickle.dump(user_info,user_file)    if user_name ==&#x27; &#x27; or user_password == &#x27; &#x27;:        tk.messagebox.showerror(message=&#x27;用户名或密码不能为空！&#x27;)    elif user_name in user_info:        if user_password == user_info[user_name]:            tk.messagebox.showinfo(title=&#x27;welcome&#x27;,message=&#x27;欢迎您：&#x27;+user_name)        else:            tk.messagebox.showerror(message=&#x27;密码错误！&#x27;)    else:        is_signup = tk.messagebox.askyesno(&#x27;欢迎&#x27;,&#x27;您还没有注册，是否现在注册&#x27;)        if is_signup:            user_sign_up()def user_sign_up():    def registration():        input_name = new_name.get()        input_password = new_password.get()        input_password_confirm =new_password_confirm.get()        try:            with open(&#x27;user_info.pickle&#x27;,&#x27;rb&#x27;) as user_file:                exist_user_info = pickle.load((user_file))        except FileNotFoundError:            exist_user_info = &#123;&#125;        if input_name in exist_user_info:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名已存在！&#x27;)        elif input_password ==&#x27;&#x27; or input_name ==&#x27;&#x27;:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;用户名或密码不能为空！&#x27;)        elif input_password != input_password_confirm:            tk.messagebox.showerror(&#x27;错误&#x27;,&#x27;密码前后不一致！&#x27;)        else:            exist_user_info[input_name] = input_password            with open(&#x27;user_info.pickle&#x27;,&#x27;wb&#x27;) as user_file:                pickle.dump(exist_user_info,user_file)            tk.messagebox.showinfo(&#x27;欢迎&#x27;,&#x27;注册成功！&#x27;)            window_sign_up.destroy()    window_sign_up = tk.Toplevel(window)    window_sign_up.geometry(&#x27;350x200&#x27;)    window_sign_up.title(&#x27;注册&#x27;)    new_name = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;用户名：&#x27;).place(x=10,y=10)    tk.Entry(window_sign_up,textvariable=new_name).place(x=150,y=10)    new_password = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请输入密码：&#x27;).place(x=10,y=50)    tk.Entry(window_sign_up,textvariable=new_password,show=&#x27;*&#x27;).place(x=150,y=50)    new_password_confirm = tk.StringVar()    tk.Label(window_sign_up,text=&#x27;请再次确认密码：&#x27;).place(x=10,y=90)    tk.Entry(window_sign_up,textvariable=new_password_confirm,show=&#x27;*&#x27;).place(x=150,y=90)    bt_confirm_sign_up = tk.Button(window_sign_up,text=&#x27;确认注册&#x27;,command=registration)    bt_confirm_sign_up.place(x=150,y=130)def user_sign_out():    window.destroy()bt_login = tk.Button(window,text=&#x27;登    录&#x27;,width=30,font= 18,bg=&#x27;DarkTurquoise&#x27;,activebackground=&#x27;Turquoise&#x27;,command=user_login_in)bt_login.place(x=150,y=210)bt_register = tk.Button(window,text=&#x27;注册&#x27;,width=25,command= user_sign_up)bt_register.place(x=150,y=270)bt_exit = tk.Button(window,text=&#x27;退出&#x27;,width=5,command = user_sign_out)bt_exit.place(x=350,y=270)window.mainloop()\n练习二题目：tkinter 版猜数游戏使用 Python 标准库 tkinter 编写 GUI 版本的猜数游戏。 每次猜数之前要启动游戏并设置猜数范围和最大猜测次数等参数， 退出游戏时显示战绩（共玩几次， 猜对几次） 信息。\n代码import tkinter as tkimport randomnumber = random.randint(0,1024)running = Truenum = 0num_max = 1024num_min = 0def eBtnClose(event):    root.destory()def eBtnGuess(evnet):    global num_max    global num_min    global num    global running    if running:        val_a = int(entry_a.get())        if val_a ==number:            labelqval(&quot;恭喜你答对啦！&quot;)            num +=1            running =False            numGuess()        elif val_a &lt;number:            if val_a &gt;num_min:                num_min = val_a                num +=1                label_tip_min.config(label_tip_min,text=num_min)            labelqval(&quot;小了哦&quot;)        else:            if val_a &lt; num_max:                num_max = val_a                num +=1                label_tip_max.config(label_tip_max,text=num_max)            labelqval(&quot;大了哦&quot;)    else:        labelqval(&#x27;你已经答对了&#x27;)def numGuess():    if num ==1:        labelqval(&#x27;居然一次就答对了&#x27;)    elif num&lt;10:        labelqval(&#x27;十次以内就答对了，继续加油！尝试次数为：&#x27;+str(num))    elif num&lt;50:        labelqval(&#x27;很不错！尝试次数为：&#x27;+str(num))def labelqval(vText):    label_val_q.config(label_val_q,text=vText)root = tk.Tk(className=&quot;猜数游戏&quot;)root.geometry(&quot;400x50&quot;)line_a_tip = tk.Frame(root)label_tip_max = tk.Label(line_a_tip,text=num_max)label_tip_min = tk.Label(line_a_tip,text=num_min)label_tip_max.pack(side=&quot;top&quot;,fill=&quot;x&quot;)label_tip_min.pack(side=&quot;bottom&quot;,fill=&quot;x&quot;)line_a_tip.pack(side=&quot;left&quot;,fill=&quot;y&quot;)line_question = tk.Frame(root)label_val_q = tk.Label(line_question,width=&quot;80&quot;)label_val_q.pack(side=&quot;left&quot;)line_question.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_input = tk.Frame(root)entry_a =tk.Entry(line_input,width=&quot;40&quot;)btnGuess = tk.Button(line_input,text = &quot;猜&quot;)entry_a.pack(side=&quot;left&quot;)entry_a.bind(&#x27;&lt;Return&gt;&#x27;,eBtnGuess)btnGuess.bind((&#x27;&lt;Button-1&gt;&#x27;),eBtnGuess)btnGuess.pack(side=&quot;left&quot;)line_input.pack(side=&quot;top&quot;,fill=&quot;x&quot;)line_btn = tk.Frame(root)btnClose = tk.Button(line_btn,text=&quot;关闭&quot;)btnClose.bind(&#x27;&lt;Button-1&gt;&#x27;,eBtnClose)btnClose.pack(side=&quot;left&quot;)line_btn.pack(side=&quot;top&quot;)labelqval(&quot;请输入0到1024之间任意整数：&quot;)entry_a.focus_set()root.mainloop()\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十三 数据分析与可视化（2）","url":"/2021/04/05/python-experiment-13/","content":"实验目的1、 掌握第三方库 TuShare 的数据获取方法2、 能够利用 pandas 库进行简单的数据分析3、 能够利用 matplotlib 库进行数据可视化4、 综合应用上述第三方库解决问题的能力\n实验内容一、读取 stock_hist_data.csv 中招商银行（股票代码 600036）2018 年下半年的股票数据并完成如下数据处理和分析任务：(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。(2) 输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；(3) 列出成交量（volume）在 1000000 以上的记录；(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 数据只保留 date、open、high、close、low 和 volume 这几个属性，并按时间先后顺序对数据进行排序；使用 matplotlib 绘制出收盘价（close）的走势折线图。data_frame = pd.DataFrame(pd.read_csv(&#x27;stock_hist_data.csv&#x27;).iloc[:,:6])data_frame = data_frame.sort_values(&#x27;date&#x27;,ascending=True)data_frame.close.plot()plt.title(&quot;收盘价(close)的走势图&quot;)plt.savefig(&#x27;收盘价(close)的走势图.jpg&#x27;)plt.show()#（2）输出这半年内成交量（volume）最低和最高那两天的日期和分别的成交量；data_volume_max_index = data_frame.volume.idxmax()data_volume_max = data_frame.loc[data_volume_max_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].values# print(data_volume_max_index)data_volume_min_index = data_frame.volume.idxmin()data_volume_min = data_frame.loc[data_volume_min_index][[&#x27;date&#x27;,&#x27;volume&#x27;]].valuesprint(&quot;半年成交量中&#123;&#125;这一天最高，为&#123;&#125;。\\n&quot;.format(data_volume_max[0],data_volume_max[1]))print(&quot;半年成交量中&#123;&#125;这一天最低，为&#123;&#125;。\\n&quot;.format(data_volume_min[0],data_volume_min[1]))#(3) 列出成交量（volume）在 1000000 以上的记录；data_volume_more_than_1000000 = data_frame[data_frame.volume &gt; 1000000]print(&quot;成交量在1000000以上的记录为：\\n&quot;,data_volume_more_than_1000000)#(4) 计算这半年中收盘价（close）高于开盘价（open）的天数；data_frame_count = data_frame[data_frame.close &gt; data_frame.open][&#x27;date&#x27;].count()print(&quot;收盘价高于开盘价的天数共有：&#123;&#125;天\\n&quot;.format(data_frame_count))#(5) 计算每月收盘价的平均值，并使用 matplotlib 绘制出柱状图。data_frame_5 = data_frame.loc[:,[&#x27;date&#x27;,&#x27;close&#x27;]]data_frame_5[&#x27;date&#x27;] = data_frame_5[&#x27;date&#x27;].apply(lambda x:x[:7])data_frame_5_close_average = data_frame_5.groupby(&#x27;date&#x27;).mean()# print(data_frame_5_close_average)data_frame_5_close_average.plot.bar()plt.title(&quot;每月收盘价(close)的平均值&quot;)plt.savefig(&#x27;average.jpg&#x27;)plt.show()\n结果（1）（5）\n二、读取“2018 世界杯球队数据.csv”，实现如下功能：(1) 输出净胜球大于 0 的球队；(2) 输出被罚红牌的球队；(3) 输出进球成功率超过 10%的球队以及进球数和射门数；(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；(5) 按照进球数降序输出所有球队及进球信息；(6) 按照所属区进行分组，按升序统计输出每个区的进球数；(7) 按照所属区进行分组，绘制每个区进球数的条形图；(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。代码import pandas as pdimport matplotlib.pyplot as pltplt.rcParams[&#x27;font.family&#x27;] = &#x27;SimHei&#x27;#(1) 输出净胜球大于 0 的球队；data_frame = pd.DataFrame(pd.read_csv(&#x27;2018世界杯球队数据.csv&#x27;,encoding=&#x27;gbk&#x27;))data_frame_1 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;失球&#x27;]]data_frame_1_win_goal = data_frame_1[&#x27;进球&#x27;] - data_frame_1[&#x27;失球&#x27;]data_frame_1[&#x27;净胜球&#x27;] = data_frame_1_win_goaldata_frame_1 = data_frame_1[data_frame_1.净胜球 &gt;0]data_frame_1_final = data_frame_1.loc[:,[&#x27;球队&#x27;,&#x27;净胜球&#x27;]]data_frame_1_name = data_frame_1_final[&#x27;球队&#x27;].valuesprint(&#x27;净胜球大于0的球队有：&#x27;,end=&#x27;&#x27;)for i in data_frame_1_name:    print(i,end=&#x27; &#x27;)#(2) 输出被罚红牌的球队；data_frame_2 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;红牌&#x27;]]data_frame_2 = data_frame_2[data_frame_2.红牌 &gt; 0].valuesprint(&#x27;被罚红牌的队伍有:&#x27;)for i in data_frame_2:    print(i[0],end=&#x27; &#x27;)#（3）输出进球成功率超过 10%的球队以及进球数和射门数；data_frame_3 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;射门&#x27;]]data_frame_3_goalrate = data_frame_3[&#x27;进球&#x27;] / data_frame_3[&#x27;射门&#x27;]*100data_frame_3[&#x27;进球率&#x27;] = data_frame_3_goalratedata_frame_3 = data_frame_3[data_frame_3.进球率 &gt; 10]data_frame_3.drop(labels=&#x27;进球率&#x27;,axis=1,inplace=True)print(data_frame_3)#(4) 输出进球数超过进球平均数且被罚黄牌少于 5 张的球队及其进球数和黄牌数；data_frame_4 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;黄牌&#x27;]]data_frame_4_TotalGoalAverage = data_frame_4[&#x27;进球&#x27;].mean()# print(data_frame_4_TotalGoalAverage)data_frame_4 = data_frame_4[(data_frame_4.进球 &gt; data_frame_4_TotalGoalAverage) &amp; (data_frame_4.黄牌 &lt; 5)]print(data_frame_4)#(5) 按照进球数降序输出所有球队及进球信息；data_frame_5 = data_frame.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_5.sort_values(by=&#x27;进球&#x27;,ascending=False,inplace=True)print(data_frame_5)#(6) 按照所属区进行分组，按升序统计输出每个区的进球数；data_frame_6 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_6_final = data_frame_6.groupby(&#x27;所属洲&#x27;).sum()data_frame_6_final.sort_values(by=&#x27;进球&#x27;,inplace=True)print(data_frame_6_final)#(7) 按照所属区进行分组，绘制每个区进球数的条形图；data_frame_7 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;进球&#x27;]]data_frame_7_final = data_frame_7.groupby(&#x27;所属洲&#x27;).sum()data_frame_7_final.plot.bar()plt.title(&#x27;各大洲进球数&#x27;)plt.show()#(8) 自选角度，根据各个球队的相关数据，绘制一个其他类型的图形，并增加一些必要的元素（如标签、标题等）。data_frame_8 = data_frame.loc[:,[&#x27;所属洲&#x27;,&#x27;球队&#x27;,&#x27;进球&#x27;,&#x27;抢断&#x27;,&#x27;射门&#x27;]]data_frame_8 = data_frame_8[data_frame_8.所属洲 == &#x27;欧洲&#x27;]data_frame_8_bar = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;进球&#x27;]]data_frame_8_pie = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;抢断&#x27;]]data_frame_8_plot = data_frame_8.loc[:,[&#x27;球队&#x27;,&#x27;射门&#x27;]]# print(data_frame_8_bar)plt.subplot(221)plt.title(&#x27;欧洲球队抢断数&#x27;)plt.scatter(data_frame_8_pie[&#x27;抢断&#x27;],data_frame_8_pie[&#x27;球队&#x27;])plt.subplot(222)plt.title(&#x27;欧洲球队射门次数占比&#x27;)plt.pie(data_frame_8_plot[&#x27;射门&#x27;],labels=data_frame_8_plot[&#x27;球队&#x27;])plt.subplot(212)plt.title(&#x27;欧洲球队进球数&#x27;)plt.bar(data_frame_8_bar[&#x27;球队&#x27;],data_frame_8_bar[&#x27;进球&#x27;])plt.show()\n结果（6）（7）￼\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验十四 网络爬虫基础（1）","url":"/2021/04/05/python-experiment-14/","content":"实验目的1、网络爬虫的基本原理与规范。2、掌握使用 Requests 库获取静态网页信息。3、掌握使用 BeautifulSoup4 库解析网页信息。4、掌握正则表达式的基本用法。\n实验内容题目 中国大学排名定向爬虫(1) 查看 https://www.shanghairanking.cn/rankings/bcur/2020 网页中关于各大学排名的信息组织(F12 快捷键查阅 html 代码)(2)使用 requests、beautifulsoup4 或 re 库抓取并解析排名，输出各大学的排名信息，如下图所示。￼\n代码import requestsfrom bs4 import BeautifulSoupimport  bs4def getHTMLText(url):    try:        r = requests.get(url,timeout=30)        r.raise_for_status()        r.encoding = &#x27;utf-8&#x27;        return r.text    except:        return &quot;&quot;def fillUniviList(ulist,html):    soup = BeautifulSoup(html,&quot;html.parser&quot;)    for tr in soup.find(&#x27;tbody&#x27;).children:        if isinstance(tr,bs4.element.Tag):            tds = tr(&#x27;td&#x27;)            ulist.append([tds[0].text,tds[1].text,tds[4].text])def printUnivList(ulist,num):    tplt = &quot;&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;&quot;    print(tplt.format(&quot;排名&quot;,&quot;学校排名&quot;,&quot;总分&quot;,chr(12288)))    for i in range(num):        u = ulist[i]        print(tplt.format(u[0].strip(),u[1].strip(),u[2].strip(),chr(12288)))def main():    uinfo = []    url = &#x27;https://www.shanghairanking.cn/rankings/bcur/2020&#x27;    html = getHTMLText(url)    fillUniviList(uinfo,html)    printUnivList(uinfo,20)main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验二 字符串及基本数据类型操作","url":"/2021/04/05/python-experiment-2/","content":"实验目的1．掌握字符串编码、索引方式2．掌握字符串的操作3．掌握字符串格式化4．掌握基本数据类型的运算操作\n实验内容练习一题目完成以下代码练习，熟悉字符串的相关使用。\n略\n练习二题目输出由任意字符串堆积的 10 行等腰三角形。其中，str.center()方法用于字符串两边填充：str.rjust(width[,fillchar])方法用于字符串右填充。\n代码width = 2*10-1for i in range(1,11):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width,&#x27; &#x27;))\n运行结果￼\n练习三题目能力值的计算：一年 365 天，以第 1 天的能力值为基数，记为 1.0，当每天好好学习时能力值相比前一天提高 1‰，当没有学习时由于遗忘等原因能力值相比前一天下降 1‰，完成下列能力值的计算：(1) 每天努力和每天放任，一年下来的能力值分别多少？(2) 一周 5 个工作日，如果每个工作日都好好学习，在周末放任一下，计算 1 年后的能力值。\n代码#（1）dayfactor = 0.0001dayup = pow(1+dayfactor,365)daydown = pow(1-dayfactor,365)print(&quot;每天努力：&#123;:.3f&#125;,每天放任：&#123;:.3f&#125;&quot;.format(dayup,daydown))#（2）dayfactor = 0.0001dayup = 1.0for i in range(365):    if i%7 in [6,0]:        dayup = dayup*(1-dayfactor)    else:        dayup = dayup*(1+dayfactor)print(&quot;1年后的能力值&#123;:.2f&#125;&quot;.format(dayup))\n练习四题目凯撒密码：设想在某些情况下给朋友传递字条信息，但又不希望传递中途被第三方看懂这些信息，因此需要对字条信息进行加密处理。凯撒密码采用了替换算法对信息中的每一个英文字符循环替换为该字符后面第三个字符，对应关系如下：原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C其它字符保持不变。编程实现：程序接收用户输入待加密的信息，输出加密后的密文。\n代码enter_code = input(&quot;请输入一段信息：&quot;)encode = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;output_code = &quot;&quot;for c in enter_code:    if c in enter_code:        index = encode.index(c)        index += 3        index %= len(encode)        output_code += encode[index]    else:        output_code += cprint(&quot;加密后的密文为：&quot;,output_code)\n练习五题目文本进度条：参考教材，使用字符串完成进度条的设计。要求：(1) 显示当前进度的百分比；(2) 动态刷新显示当前的进度。\n代码import timescale = 50print(&quot;执行开始&quot;.center(scale//2,&#x27;-&#x27;))t = time.clock()for i in range(scale+1):    a = &#x27;*&#x27; * i    b = &#x27;.&#x27; * (scale-i)    c = (i/scale) * 100    t -= time.clock()    print(&quot;\\r&#123;:^.3f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,-t),end=&#x27;&#x27;)    time.sleep(0.05)print(&quot;\\n&quot;+&quot;执行结束&quot;.center(scale//2,&#x27;-&#x27;))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验三 程序的控制结构（分支）","url":"/2021/04/05/python-experiment-3/","content":"实验目的1、掌握程序的单分支结构2、掌握程序的双分支结构3、掌握程序的多分支结构4、掌握 if 的嵌套\n实验内容练习一题目：身体质量指数 BMIBMI 值可以“客观的”衡量个人的肥胖程度或者说健康程度。世界卫生组织（WHO）根据对全球人口体重的统计认为，BMI 值低于 18.5 kg/m2 时属于“过轻”，表明个体可能营养不良或者饮食无法保障；BMI 值高于 25 kg/m2 时属于“过重”。根据下表所示指标编程测试自己的身体指数状况。￼\n代码height ,weight = eval(input(&quot;请输入身高（米）和体重（公斤）[逗号隔开]：&quot;))bmi = weight / pow(height,2)print(&quot;BMI 指数为：&#123;:.2f&#125;&quot;.format(bmi))who,dom=&quot;&quot;,&quot;&quot;if bmi &lt; 18.5:\twho,dom = &quot;偏瘦&quot;,&quot;偏瘦&quot;elif 18.5&lt;= bmi &lt; 24:\twho, dom = &quot;正常&quot;, &quot;正常&quot;elif 24&lt;= bmi &lt; 25:\twho, dom = &quot;正常&quot;, &quot;偏胖&quot;elif 25&lt;= bmi &lt; 28:\twho, dom = &quot;偏胖&quot;, &quot;偏胖&quot;elif 28&lt;= bmi &lt; 30:\twho, dom = &quot;偏胖&quot;, &quot;肥胖&quot;else:\twho, dom = &quot;肥胖&quot;, &quot;肥胖&quot;print(&quot;BMI 指标为：国际&#x27;&#123;0&#125;&#x27;，国内&#x27;&#123;1&#125;&#x27;&quot;.format(who,dom))\n练习二题目：学生成绩等级判断编程实现输入学生成绩 score，得出其等级状况 grade,其对应关系如下：100&gt;=Score&gt;=85 grade=”A”70&lt;=Score&lt;85 grade=”B”60&lt;=Score&lt;70 grade=”C”0&lt;Score&lt;60 grade=”D”Score&gt;100 或 Score&lt;0 给出出错提示\n代码score = input(&quot;请输入你的成绩：&quot;)try:\tscore = eval(score)\tif score &lt; 0 or score &gt; 100: 5. print(&quot;成绩输入有误，请重新输入&quot;)\telse:\t\tif 0 &lt;= score &lt; 60:\t\t\tgrade = &quot;D&quot;\t\telif 60 &lt;= score &lt; 70:\t\t\tgrade = &quot;C&quot;\t\telif 70 &lt;= score &lt; 85:\t\t\tgrade = &quot;B&quot;\t\telif 85 &lt;= score &lt;= 100:\t\t\tgrade = &quot;A&quot; 15. print(&quot;你的成绩属于&#123;&#125;级别&quot;.format(grade))except NameError:\tprint(&quot;输入错误，请输入一个整数！&quot;)\n练习三题目：猜数游戏在程序中预设一个 0-9 之间的整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\t    print(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\t    exit()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验四 程序的控制结构（循环）","url":"/2021/04/05/python-experiment-4/","content":"实验目的1、掌握程序的几种循环结构及扩展用法2、掌握 break 和 continue 的用法3、掌握 random 库的用法4、了解程序的异常处理及用法\n实验内容练习一题目：统计不同字符个数用户从键盘输入一行字符，编写一个程序，统计并输出其中英文字符、数字、空格和其它字符的个数。\n代码charts = input(&quot;请输入一行字符：&quot;)english = num = space = other = 0for i in charts:\tif &#x27;0&#x27;&lt;= i &lt;= &#x27;9&#x27;:\t\tnum += 1\telif (&#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;) or (&#x27;A&#x27; &lt;= i &lt;=&#x27;Z&#x27;):\t\tenglish += 1\telif i == &#x27; &#x27;:\t\tspace += 1\telse:\t\tother += 1print(&quot;在你输入的字符串中：英文字符有&#123;&#125;个，数字有&#123;&#125;个，空格有&#123;&#125;个，其他字符有&#123;&#125;个&quot;.format(english,num,space,other))\n练习二题目：猜数游戏续在上一次猜游戏实验题目的基础上，完善程序，实现如下的功能：系统自动生成 1-100 以内的随机整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测 N 次，你猜中了！”，其中 N 是用户输入的数字次数。如果用户输入的不是整数，而是小数，则提示用户“输入错误，必须输入整数！”，并让用户重新输入。如果用户输入的不是数字，则给出出错提示“输入格式错误，结束程序！”\n代码import random as rand;flag = rand.randint(0,9)count = 0while True:\tnum = input(&quot;请输入你猜想的数：&quot;)\ttry: 8. num = eval(num)\t\tif num &lt; flag :\t\t\tprint(&quot;遗憾，太小了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num &gt; flag:\t\t\tprint(&quot;遗憾，太大了！&quot;)\t\t\tcount += 1\t\t\tcontinue\t\telif num == flag:\t\t\tcount += 1\t\t\tprint(&quot;预测&#123;&#125;次，你猜中了！&quot;.format(count))\t\t\tst = input(&quot;是否继续游戏!\\n 输入 1 继续，输入 0 结束：&quot;)\t\t\tif eval(st)==1:\t\t\t\tcount = 0\t\t\t\tflag =rand.randint(0,9)\t\t\t\tcontinue\t\t\telse:\t\t\t\texit()\texcept NameError:\tprint(&quot;输入类型错误，请输入一个整数，程序执行完毕！&quot;)\texit()\n练习三题目：最大公约数计算从键盘接收两个整数，编写程序求出这两个整数的最大公约数和最小公倍数（提示：用辗转相除法求最大公约数，用两数乘积除以最大公约数求得最小公倍数）\n代码num1,num2 = eval(input(&quot;请输入两个整数(逗号隔开输入)：&quot;))greatest_common_divisor = 0least_common_multiple = 0def Calculation(a,b):\tif b == 0:\t\treturn a\t\treturn Calculation(b,a%b)if num1 &lt; num2:\ttemp = num1\tnum1 = num2\tnum2 = tempgreatest_common_divisor = Calculation(num1,num2)least_common_multiple = num2 * num1 / greatest_common_divisorprint(&quot; 两 数 的 最 大 公 约 数 为 &#123;&#125; ， 最 小 公 倍 数 为&#123;:.0f&#125;&quot;.format(greatest_common_divisor,least_common_multiple))\n练习四题目请编写程序实现如下数字金字塔的显示：￼\n代码s = &#x27;&#x27;for i in range(1,10):\ts = s + str(i)\tleft_part = s[::-1]\tright_part = s[1:]\tstrs = left_part + right_part\tprint(strs.center(17,&quot; &quot;))\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验五 组合数据类型","url":"/2021/04/05/python-experiment-5/","content":"实验目的1、理解组合数据类型的概念2、掌握列表、字典与集合的定义和使用方法3、熟练 random 模块的应用\n实验内容练习一题目编写程序，在 26 个字母大小写和 10 个数字组成的列表中随机生成 10个 8 位密码。\n代码#设置的密码没有重复的元素import randomList =[]#存入字母和数字for i in range(26):\tList.append(chr(ord(&#x27;A&#x27;)+i))\tList.append(chr(ord(&#x27;a&#x27;)+i))for i in range(10):\tList.append(str(i))#随机生成 10 个 8 位数的密码for i in range(10):\tpassword_List = random.sample(List,8) #生成结果仍为列表\tpassword = &quot;&quot;.join(password_List) #将列表转化成字符串\tprint(password)\n练习二题目通过键盘输入系列整数值，输入 0 则表示输入结束，将这些值（不含 0）建立为一个列表，并按从大到小的顺序输出该列表各元素。\n代码List = []num = eval(input(&quot;请输入一个整数：&quot;))while num != 0:\tList.append(num)\tnum = eval(input(&quot;请输入一个整数：&quot;))List.sort(reverse = True)for i in range(len(List)):\tprint(List[i])\n练习三题目输入一个大于 2 的自然数， 输出小于该数字的所有素数组成的集合。\n代码import mathdef isprime(n):\tfor i in range(2,n):\t\tif n % i ==0:\t\t\treturn False\t\telse:\t\t\treturn Truenum_input = eval(input(&quot;请输入一个大于 2 的自然数：&quot;))num = math.ceil(num_input)prime_set = set()for i in range(2,num):\tif isprime(i):\t\tprime_set.add(i)\tprint(&quot;小于&#123;&#125;的所有素数集合是：&#123;&#125;&quot;.format(num_input,prime_set))\n练习四题目使用字典来创建程序，提示用户输入电话号码，并用英文单词形式显示数字。例如：输入 138 则显示“one three eight”。\n代码num = [i for i in range(10)]word = [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;]phone_list = dict(zip(num,word))phone_num = input(&quot;请输入电话号码：&quot;)result=&quot;&quot;#print(phone_num)for i in phone_num:\tphone_i = eval(i)\tfor key in phone_list:\t\tif phone_i == key:\t\t\tresult += phone_list[key] + &quot; &quot;print(result)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验六","url":"/2021/04/05/python-experiment-6/","content":"实验目的1、 培养分析问题并对进行建模的能力。2、 熟练使用组合数据类型解决实际问题。3、 熟练运用选择结构和循环结构解决实际问题。\n实验内容练习一题目统计《三国演义》中人物出场次数最多的前 20 人。\n代码import jieba as jietext = (open(&#x27;三国演义.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)).read()words = jie.lcut(text)nowords =&#123;&quot;这个&quot;,&quot;引兵&quot;,&quot;次日&quot;,&quot;人马&quot;,&quot;不知&quot;,&quot;汉中&quot;,&quot;众将&quot;,&quot;只见&quot;,&quot;大喜&quot;,&quot;天下&quot;,&quot;东吴&quot;,&quot;于是&quot;,&quot;今日&quot;,&quot;不敢&quot;,&quot;魏兵&quot;,&quot;陛下&quot;,&quot;太守&quot;,&quot;天子&quot;,&quot;一面&quot;,&quot;原来&quot;,&quot;令人&quot;,&quot;江东&quot;,&quot;喊声&quot;,&quot;下马&quot;,&quot;何不&quot;,&quot;大军&quot;,&quot;忽报&quot;,&quot;先生&quot;,&quot;百姓&quot;,&quot;然后&quot;,&quot;何故&quot;,&quot;先锋&quot;,&quot;不如&quot;,&quot;赶来&quot;,&quot;此人&quot;,&quot;夫人&quot;,&quot;先主&quot;,&quot;后人&quot;,&quot;背后&quot;,&quot;城中&quot;,&quot;蜀兵&quot;,&quot;上马&quot;,&quot;大叫&quot;,&quot;都督&quot;,&quot;一人&quot;,&quot;如何&quot;,&quot;商议&quot;,&quot;却说&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;,&quot;将军&quot;,&quot;二人&quot;,&quot;后主&quot;,&quot;荆州&quot;,&quot;如何&quot;,&quot;主公&quot;,&quot;军马&quot;,&quot;军士&quot;,&quot;左右&quot;,&quot;正是&quot;,&quot;徐州&quot;,&quot;忽然&quot;,&quot;因此&quot;,&quot;成都&quot;,&quot;未知&quot;,&quot;不见&quot;,&quot;大败&quot;,&quot;大事&quot;,&quot;之后&quot;,&quot;一军&quot;,&quot;起兵&quot;,&quot;引军&quot;,&quot;军中&quot;,&quot;接应&quot;,&quot;进兵&quot;,&quot;大惊&quot;,&quot;可以&quot;,&quot;大怒&quot;,&quot;不得&quot;,&quot;以为&quot;,&quot;心中&quot;,&quot;一声&quot;,&quot;下文&quot;,&quot;曹兵&quot;,&quot;追赶&quot;&#125;counts =&#123;&#125;for word in words:\tif len(word) == 1:\t\tcontinue\telif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:\t\trword = &quot;孔明&quot;\telif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:\t\trword = &quot;刘备&quot;\telif word == &quot;孟德&quot; or word == &quot;丞相&quot;:\t\trword = &quot;曹操&quot;\telif word == &quot;关公&quot; or word == &quot;云长&quot;:\t\trword = &quot;关羽&quot;\telse:\t\trword = word\tcounts[rword] = counts.get(rword,0) + 1for word in nowords:\tdel(counts[word])items = list(counts.items())items.sort(key=lambda x:x[1],reverse = True)for i in range(20):\tword,count = items[i]\tprint(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))\n练习二题目编写程序，模拟抓狐狸小游戏。假设一共有一排 5 个洞口，小狐狸最开始的时候在其中一个洞口，然后玩家随机打开一个洞口，如果里面有狐狸就抓到了。如果洞口里没有狐狸就第二天再来抓， 但是第二天狐狸会在玩家来抓之前跳到隔壁洞口里。\n代码import random as ranflag =ran.randint(0,4)tiao = [-1,1]while True:\ttry:\t\tinp = eval(input(&quot;请输入 0-4 中任意一个数：&quot;))\texcept:\t\tprint(&quot;输入格式有误，请重新输入！&quot;)\t\tcontinue\tif inp &lt;0 or inp &gt;4:\t\tprint(&quot;输入范围有误！&quot;)\t\tcontinue\tif inp == flag:\t\tprint(&quot;找到了，游戏结束！&quot;)\t\tbreak\telse:\t\tflag += tiao[ran.randint(0,1)]\t\tflag %= 5\t\tprint(flag)\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验七 阶段测试","url":"/2021/04/05/python-experiment-7/","content":"题目一打印输出如下字符图案。￼\n代码width_top = 2*6-1;width_di = 2*5-1;for i in range(1,7):    str = &#x27;*&#x27;*(2*i-1)    print(str.center(width_top,&#x27; &#x27;))for i in range(5,-1,-1):    str = &#x27;*&#x27; * (2 * i - 1)    print(str.center(width_top,&#x27; &#x27;))\n题目二输入一个年份，判断并输出该年份是否为闰年。。\n代码date = eval(input(&quot;请输入一个年份：&quot;))# print(date)if (date%100!=0 and date%4==0) or (date%400==0):    print(&quot;&#123;&#125;年是闰年&quot;.format(date))else:    print(&quot;&#123;&#125;年不是闰年&quot;.format(date))\n题目三编写一个程序，输入任意一行字符，并将其中的小写字母转换为大写字母，然后打印输出，注意：非小写字母不转换。\n代码str = input(&quot;请输入一行字符：&quot;)for i in str:    if 97&lt;=ord(i)&lt;=122:        i = chr(ord(i)-32)    print(i,end=&#x27;&#x27;)\n题目四使用turtle库画一个心形，例如：￼\n代码from turtle import *color(&#x27;red&#x27;,&#x27;pink&#x27;)begin_fill()left(140)fd(135)right(180)circle(60,-180)backward(35)right(100)forward(35)circle(-60,180)fd(135)end_fill()exitonclick()\n题目五编写一个程序来计算输入的一行字符串中的单词频率（单词不区分大小写），并按字母顺序对键进行排序，然后输出所有单词及其出现的次数。 提示：对一个字典counts内的单词按字母顺序排序，代码可以为：sorted_words = sorted(counts.keys())\n例如，输入：\nNew to Python or choosing between Python 2 and Python 3? Read Python 2 or Python 3.\n则输出为：￼\n代码str = input(&quot;请输入一行字符串：&quot;)word_dic=&#123;&#125;word =&quot;&quot;for i in str:    if 48&lt;=ord(i)&lt;=57 or 97&lt;=ord(i)&lt;=122:        word = word+i    elif 65&lt;=ord(i)&lt;=90:        i = chr(ord(i)+32)        word = word+i    else:        if word == &quot;&quot;:            continue        else:            word_value = &#123;word: 1&#125;            if (word in word_dic.keys()):                word_dic[word] += 1                word = &quot;&quot;            else:                word_dic.update(word_value)                word = &quot;&quot;sorted_word = sorted(word_dic.items(),key=lambda d:d[0])# print(sorted_word)for key,value in sorted_word:    print(&quot;&#123;&#125;:&#123;&#125;&quot;.format(key,value))","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验八 函数","url":"/2021/04/05/python-experiment-8/","content":"实验目的\n掌握函数的定义与调用过程\n掌握参数的传递方式和传递过程\n理解和使用匿名函数\n理解递归调用的思想和方法\n掌握变量的作用域实验内容练习一题目定义求 n!的函数 fact()和求和函数 sum(),在此基础上编程实现 1！+2！+…m!的计算。代码def fact(num):    result = 1    for i in range(1,num+1):        result *= i    return resultdef sum(num):    result = 0    for i in range(1,num+1):        result = result + fact(i)    return resultnum=eval(input(&quot;请输入一个数m：&quot;))print(&quot;1!+2!+...+&#123;&#125;!=&#123;&#125;&quot;.format(num,sum(num)))\n练习二题目定义匿名函数实现求平方，定义判素数函数 list_prime(),该函数可以实现接受任意个数的判断，并将所有素数作为返回值。在此基础上编程实现随机输入任意个数，从中挑选出所有素数，并计算所有素数平方和。代码def list_prime(num):    sum = 0    for i in range(1,num):        if (num % i==0):            sum +=1;    if sum&gt;=2:        return 0    else:        return pingfang(num)def pingfang(num):    return num*num;str = eval(input(&quot;请随机输入任意个数(以逗号分割)：&quot;))sum = 0for i in str:    sum += list_prime(i)print(&quot;你输入的数组中所有素数的平方和为：&#123;&#125;&quot;.format(sum))\n练习三题目分别定义 numlist()和 charlist()函数，numlist()功能是生成由数字 1-26 构成的列表,charlist()功能是生成由字符 A-Z 构成的列表。在此基础上编写程序实现生成一个字典，具体如下：{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’, 5: ‘e’, 6: ‘f’, 7: ‘g’, 8: ‘h’, 9: ‘i’, 10: ‘j’, 11: ‘k’, 12: ‘l’, 13: ‘m’,14: ‘n’, 15: ‘o’, 16: ‘p’, 17: ‘q’, 18: ‘r’, 19: ‘s’, 20: ‘t’, 21: ‘u’, 22: ‘v’, 23: ‘w’, 24: ‘x’, 25: ‘y’,26: ‘z’}遍历字典，输出所有键值为偶数的元素。代码def numlist():    num= []    for i in range(1,27):        num.append(i)    return numdef charlist():    char = []    for i in range(26):        char.append(chr(ord(&#x27;A&#x27;)+i))    return chardictionary = dict(zip(numlist(),charlist()))# print(dictionary)for key in dictionary:    if key%2 ==0:        print(dictionary[key])\n练习四题目绘制科赫雪花，效果如下：￼代码import turtledef koch(size,n):    if n==0:        turtle.fd(size)    else:        for angle in [0,60,-120,60]:            turtle.left(angle)            koch(size/3,n-1)def main():    turtle.setup(600,600)    turtle.speed(0)    turtle.penup()    turtle.goto(-200,100)    turtle.pendown()    turtle.pensize(2)    level = 5    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()    turtle.exitonclick()main()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"Python 实验九 文件与数据格式化","url":"/2021/04/05/python-experiment-9/","content":"实验目的\n掌握文件的基本操作\n理解一、二维和高维数据的格式化过程\n掌握 csv 和 json 格式的相互转换\n综合应用组合数据类型与 CSV 和 JSON 数据格式编写简单的应用程序实验内容练习一题目将提供的 test.csv 文件，具体内容如下：￼编程读入该文件，转换成 JSON 格式文件，并以文件名 out.json 输出。转换后的结果如下所示：[ {  &quot;同比&quot;: &quot;120.7&quot;,\n  &quot;城市&quot;: &quot;北京&quot;,\n  &quot;定基&quot;: &quot;121.4&quot;,\n  &quot;环比&quot;: &quot;101.5&quot;\n\n  },  {  &quot;同比&quot;: &quot;127.3&quot;,\n  &quot;城市&quot;: &quot;上海&quot;,\n  &quot;定基&quot;: &quot;127.8&quot;,\n  &quot;环比&quot;: &quot;101.2&quot;\n\n  } ….]代码#方法一：import jsonfr = open(&quot;test.csv&quot;,&quot;r&quot;)ls = []for line in fr:    line = line.replace(&quot;\\n&quot;,&quot;&quot;)    ls.append(line.split(&#x27;,&#x27;))fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()#方法二：import jsonwith open(&quot;test.csv&quot;,&quot;r&quot;) as fr:    ls = []    for line in fr:        line = line.replace(&quot;\\n&quot;, &quot;&quot;)        ls.append(line.split(&#x27;,&#x27;))    fr.close()fw = open(&quot;test.json&quot;,&quot;w&quot;)for i in range(1,len(ls)):    ls[i]= dict(zip(ls[0],ls[i]))json.dump(ls[1:],fw,sort_keys=True,indent=4,ensure_ascii=False)fw.close()\n练习二题目编写程序制作英文学习字典，词典基本功能如下：(1) 程序读取源文件路径下的 txt 格式词典文件，若没有就创建一个。 词典文件存储方式为 “英文单词 中文单词”,每行仅有一对中英文释义；(2) 程序有添加功能，输入英文单词，如果没有可以添加中文释义，如果有就显示”已经存在，不能添加”；(3) 程序有查询功能，如果存在，则显示其中文释义，不存在就显示不存在；(4) 程序有正常退出的操作。代码import oskeys = []dic = &#123;&#125;def readdict():    if os.path.exists(&quot;dictionary.txt&quot;):        fr = open(&#x27;dictionary.txt&#x27;,&#x27;r&#x27;)    else:        fr = open(&#x27;dictionary.txt&#x27;,&#x27;w+&#x27;)    for line in fr:        line = line.replace(&quot;\\n&quot;,&quot;&quot;)        v = line.split(&#x27;:&#x27;)        dic[v[0]]= v[1]        keys.append(v[0])    fr.close()def writedict(key,value):    with open(&#x27;dictionary.txt&#x27;,&#x27;a&#x27;)as fw:        fw.write(key+&#x27;:&#x27;+value+&#x27;\\n&#x27;)def mydict():    n = input(&quot;请输入进入相应模块（添加，查询，退出）&quot;)    if n == &quot;添加&quot;:        key = input(&quot;请输入英文单词：&quot;)        if key not in keys:            value =input(&quot;字典中未找到单词&#x27;&#123;&#125;&#x27;的中文释义，请输入该单词的中文意思，添加进字典中！&quot;.format(key))            dic[key] = value            keys.append(key)            writedict(key,value)        else:            print(&quot;单词&#x27;&#123;&#125;&#x27;已存在，不能添加&quot;.format(key))        return 0    elif n == &quot;查询&quot;:        key = input(&quot;请输入英文单词:&quot;)        if key not in keys:            print(&quot;英文单词&#x27;&#123;&#125;&#x27;不在字典内&quot;.format(key))        else:            print(dic[key])        return 0    elif n == &quot;退出&quot;:        return 1    else:        print(&quot;输入有误&quot;)        return 0def main():    readdict()    while True:        n = mydict()        if n == 1:            break        if n == 0:            continuemain()\n\n","categories":["experiment"],"tags":["experiment","python-experiment"]},{"title":"数据库实验（一）建立数据库","url":"/2021/04/07/Database-experiment-1/","content":"实验类型设计性实验\n实验目的\n熟悉oracle环境。\n熟练掌握和使用PL-SQL建立数据库基本表。\n使用PL/SQL developer操作数据库。\n熟练掌握SQL 建立关系，及增删改数据。\n\n实验内容\n了解SQL PLUS的使用\n使用PL/SQL developer的图形界面，建立图书管理数据库orcl中的读者关系，要求创建主键约束，用户定义的完整性约束（电话号码、身份证号）。\n在建立的读者关系中输入有效数据。\n删除读者关系。\n在PL/SQL developer用SQL代码建立orcl数据库中各关系。\n用SQL 代码完成数据增、删、改。\n\n实验步骤登录数据库\n以SYSTEM登录数据库\n\n\n输入口令为你创建数据库时设置的密码\n\n\n\n\n注册用户、重新以新用户登录数据库\n\n\n\n图形化界面建表\n图书分类（图书分类号，类名）\n\n\n\n\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n\n\n预约（预约流水号，借书证号，ISBN，日期）\n\n\n\n\n\n建立数据库表：打开tables文件夹。建立以下各关系：\n图书分类（图书分类号，类名）\n\n\n\n\n图书分类号\n类名\n\n\n\n100\n文学\n\n\n200\n科技\n\n\n300\n哲学\n\n\ncreate table 图书分类(  图书分类号 NUMBER primary key,  类名    VARCHAR2(4))insert into 图书分类 (图书分类号,类名) values (100,&#x27;文学&#x27;);insert into 图书分类 values (200,&#x27;科技&#x27;);insert into 图书分类 (图书分类号,类名) values (300,&#x27;哲学&#x27;);\n\n\n书目（ISBN, 书名，作者，出版单位，单价，图书分类号）\n\n\n\n\nISBN\n书名\n作者\n出版单位\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n33.80\n300\n\n\ncreate table 书目(  isbn  NUMBER primary key  书名    VARCHAR2(14),  作者    VARCHAR2(6),  出版单位  VARCHAR2(14),  单价    NUMBER,  图书分类号 NUMBER,  出版年份  NUMBER,  foreign key(图书分类号) references 图书分类(图书分类号))insert into 书目 values (7040195836,&#x27;数据库系统概论&#x27;,&#x27;王珊&#x27;,&#x27;高等教育出社&#x27;,39.00,&#x27;200&#x27;);insert into 书目 values (9787508040110,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;人民出版社&#x27;,20.00,&#x27;100&#x27;);insert into 书目 values (9787506336239,&#x27;红楼梦&#x27;,&#x27;曹雪芹&#x27;,&#x27;作家出版社&#x27;,34.30,&#x27;100&#x27;);insert into 书目 values (9787010073750,&#x27;心学之路&#x27;,&#x27;王珊&#x27;,&#x27;人民出版社&#x27;,33.80,&#x27;300&#x27;);\n\n\n图书（图书编号，ISBN，是否借出，备注）\n\n\n\n\n图书编号\nISBN\n是否借出\n备注\n\n\n\n2001231\n7040195836\n否\n\n\n\n2001232\n7040195836\n是\n\n\n\n1005050\n9787506336239\n否\n\n\n\n1005063\n9787508040110\n是\n\n\n\n3007071\n9787010073750\n是\n\n\n\ncreate table 图书(  图书编号 NUMBER primary key,,  isbn NUMBER,  是否借出 VARCHAR2(2),  备注   VARCHAR2(24),  foreign key(ISBN) references 书目(ISBN))insert into 图书 values (2001231,&#x27;7040195836&#x27;,&#x27;否&#x27;,null);insert into 图书 values (2001232,&#x27;7040195836&#x27;,&#x27;是&#x27;,null);insert into 图书 values (1005050,&#x27;9787506336239&#x27;,&#x27;否&#x27;,null);insert into 图书 values (1005063,&#x27;9787508040110&#x27;,&#x27;是&#x27;,null);insert into 图书 values (3007071,&#x27;9787010073750&#x27;,&#x27;是&#x27;,null);\n\n\n读者 （借书证号，姓名，单位，性别，地址，联系电话，身份证编号）\n\n\n\n\n借书证号\n姓名\n单位\n性别\n地址\n联系电话\n身份证编号\n\n\n\n20051001\n王菲\n四川绵阳西科大计算机学院\n女\n…\n…\n..\n\n\n20062001\n张江\n四川绵阳中心医院\n男\n…\n…\n..\n\n\n20061234\n郭敬明\n四川江油305\n男\n..\n..\n..\n\n\n20071235\n李晓明\n四川成都工商银行\n男\n..\n..\n..\n\n\n20081237\n赵鑫\n四川广元广元中学\n女\n..\n..\n..\n\n\ncreate table 读者(  借书证号  VARCHAR2(10) primary key,  姓名    VARCHAR2(10),  单位    VARCHAR2(25),  性别    VARCHAR2(2),  地址    VARCHAR2(16),  联系电话  VARCHAR2(16),  身份证编号 VARCHAR2(16))insert into 读者 values (&#x27;20051001&#x27;,&#x27;王菲&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;女&#x27;,null,null,null);insert into 读者 values (&#x27;20062001&#x27;,&#x27;张江&#x27;,&#x27;四川绵阳中心医院&#x27;,&#x27;男&#x27;,&#x27;绵阳&#x27;,null,null,null);insert into 读者 values (&#x27;20061234&#x27;,&#x27;郭敬明&#x27;,&#x27;四川江油305&#x27;,&#x27;男&#x27;,&#x27;四川&#x27;,null,null,null);insert into 读者 values (&#x27;20071235&#x27;,&#x27;李晓明&#x27;,&#x27;四川成都工商银行&#x27;,&#x27;男&#x27;,&#x27;成都&#x27;,null,null,null);insert into 读者 values (&#x27;20081237&#x27;,&#x27;赵鑫&#x27;,&#x27;四川广元广元中学&#x27;,&#x27;女&#x27;,&#x27;广元&#x27;,null,null,null);\n\n\n借阅 （借阅流水号，借书证号，图书编号，借书日期，归还日期，罚款分类号，备注）\n\n\n\n\n借书证号\n图书编号\n借书日期\n归还日期\n罚款分类号\n备注\n\n\n\n20081237\n3007071\n2010/09/19\n2010/09/20\n\n\n\n\n20071235\n1005063\n2010/10/20\n2011/02/20\n1\n\n\n\n20071235\n2001232\n2011/09/01\n\n\n\n\n\n20061234\n1005063\n2011/9/20\n\n\n\n\n\n20051001\n3007071\n2011/9/10\n\n\n\n\n\n20071235\n1005050\n2011/10/20\n2012/02/20\n1\n\n\n\ncreate table 借阅(  借阅流水号 NUMBER primary key,  借书证号  VARCHAR2(16),  图书编号  NUMBER(10),  借书日期  DATE,  归还日期  DATE,  罚款分类号 NUMBER,  备注    VARCHAR2(20),  foreign key(借书证号) references 读者(借书证号)  foreign key(图书编号) references 图书(图书编号)  foreign key(罚款分类号) references 罚款分类(罚款分类号))insert into 借阅 values (1,&#x27;20081237&#x27;,3007071,to_date(&#x27;2010-09-19&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2010-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null);insert into 借阅 values (2,&#x27;20071235&#x27;,1005063,to_date(&#x27;2010-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2011-02-20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);insert into 借阅 values (3,&#x27;20071235&#x27;,2001232,to_date(&#x27;2011-09-01&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (4,&#x27;20061234&#x27;,1005063,to_date(&#x27;2011-09-20&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (5,&#x27;20051001&#x27;,3007071,to_date(&#x27;2011-09-10&#x27;,&#x27;yyyy/mm/dd&#x27;),null,null,null);insert into 借阅 values (6,&#x27;20071235&#x27;,1005050,to_date(&#x27;2011-10-20&#x27;,&#x27;yyyy/mm/dd&#x27;),to_date(&#x27;2012/02/20&#x27;,&#x27;yyyy/mm/dd&#x27;),1,null);\n\n\n罚款分类（罚款分类号，罚款名称，罚金）\n\n\n\n\n罚款分类号\n罚款名称\n罚金\n\n\n\n1\n延期\n10\n\n\n2\n损坏\n20\n\n\n3\n丢失\n50\n\n\ncreate table 罚款分类(  罚款分类号 NUMBER primary key,  罚款名称  VARCHAR2(10),  罚金    NUMBER(3))insert into 罚款分类 values (1,&#x27;延期&#x27;,10);insert into 罚款分类 values (2,&#x27;损坏&#x27;,20);insert into 罚款分类 values (3,&#x27;丢失&#x27;,50);\n\n\n预约 （预约流水号，借书证号，ISBN，预约时间）\n\n\n\n\n预约流水号\n借书证号\nISBN\n预约时间\n\n\n\n1\n20081237\n9787508040110\n2011/09/11\n\n\ncreate table 预约(  预约流水号  NUMBER primary key,  借书证号   VARCHAR2(16),  isbn   NUMBER,  s_date DATE)insert into 预约 values (1,&#x27;20081237&#x27;,&#x27;9787508040110&#x27;,&#x27;2011/09/11&#x27;,&#x27;yyyy/mm/dd&#x27;);\n\n使用SQL语句练习表的创建、删除、修改操作select * from 图书;alter table 图书 add 图书分类号 number;alter table 图书 drop column 图书分类号;update 图书 set 是否借出=&#x27;否&#x27; where 图书分类号=&#x27;2002141&#x27;;\n\n试根据下面的完整性约束要求，用SQL对上面已经建立好的数据库表进行完整性约束定义。读者关系中属性  联系电话  取值为11位数字身份证编号  取值为18位，并且满足身份证编号规则\nalter table 读者 add constraint PhoneNumber check(regexp_like(联系电话,&#x27;1[3|4|5|7|8][0-9]&#123;9&#125;&#x27;));alter table 读者 add constraint IDENTITYNUM check(regexp_like(身份证号,&#x27;[1-9\\d&#123;5&#125;(19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|([1-3]0)|31)\\d&#123;3&#125;[0-9Xx]&#x27;))","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验三、四","url":"/2021/04/28/Database-experiment-3/","content":"实验类型验证型实验\n实验目的\n了解存储过程的概念、优点\n熟练掌握创建存储过程的创建方法\n熟练掌握存储过程的调用方法\n\n实验内容\n建立存储过程\n调用存储过程\n\n实验步骤\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\n\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n修改实验三借书功能的存储过程。该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n该存储过程主体部分只有insert into语句。\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n修改实验三还书功能的存储过程。该存储过程要求：（1）还书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）还书时，还书日期为系统时间。\n\n\n该存储过程主体部分只有一条UPDATE语句。\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\n实验结果实验三\n建立存储过程完成图书管理系统中的借书功能，功能要求：\n\n\n借书时要求输入借阅流水号，借书证号，图书编号。（即该存储过程有3个输入参数）\n借书时，借书日期为系统时间。\n图书的是否借出改为‘是’\n\ncreate or replace procedure Procedure_借书(vis_借阅流水号 in 借阅.借阅流水号%type,vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)asbegin  insert into 借阅  values(vis_借阅流水号,vis_借书证号,vis_图书编号,sysdate,null,null,null);  update 图书  set 图书.是否借出 = &#x27;是&#x27;  where 图书.图书编号 = vis_图书编号;end;\n\n\n建立存储过程完成图书管理系统中的预约功能。\n\n\n预约时要求输入预约流水号，借书证号，ISBN。（即该存储过程有3个输入参数）\n存储过程先检查输入的ISBN版本的图书是否都已借出，如果是则进行预约，否则提示“该书目有可借图书，请查找”。\n预约时间为系统时间。\n\ncreate or replace procedure Procedure_预约(vis_预约流水号 in 预约.预约流水号%type,vis_借书证号 in 预约.借书证号%type,vis_ISBN in 预约.ISBN%type)asvis_数量 number;begin  select count(*) into vis_数量 from 图书  where 图书.ISBN=vis_ISBN  and 图书.是否借出=&#x27;否&#x27;;  if vis_数量= 0 then    insert into 预约 values(vis_预约流水号,vis_借书证号,vis_ISBN,sysdate);    commit;  else    dbms_output.put_line(&#x27;该书目有可借图书，请查找！&#x27;);  end if;end;\n\n\n建立存储过程完成图书管理系统中的还书功能。\n\n\n还书时要求输入借书证号，图书编号，罚款分类号（即该存储过程有3个输入参数）。\n还书日期为系统时间。\n图书的是否借出改为‘否’。\n\ncreate or replace procedure Procedure_还书(vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type,vis_罚款分类号 in 借阅.罚款分类号%type)asbegin  update 借阅  set 借阅.归还日期=sysdate,借阅.罚款分类号=vis_罚款分类号  where 借阅.借书证号=vis_借书证号  and 借阅.图书编号=vis_图书编号;  update 图书 set 图书.是否借出=&#x27;否&#x27;  where 图书.图书编号=vis_图书编号;end;\n\n实验四\n通过序列和触发器实现借阅表中借阅流水号字段的自动递增。\n\ncreate sequence SEQ_序列minvalue 1maxvalue 1.0E28start with 1increment by 1cache 20;create or replace trigger TR_借阅流水号自增       before insert on 借阅       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.借阅流水号  from dual;end;\n\n\n通过序列和触发器实现预约表中预约流水号字段的自动递增\n\ncreate or replace trigger TR_预约流水号自增       before insert on 预约       for each rowbegin  select SEQ_序列.NEXTVAL  into :new.预约流水号  from dual;end;\n\n3、 修改实验三借书功能的存储过程，该存储过程要求：（1）借书时输入借书证号，图书编号。（即该函数有2个输入参数）（2）借书时，借书日期为系统时间。\n\n该存储过程主体部分只有insert into语句。\n\ncreate or replace procedure Processed_借书   (  vis_借书证号 in 借阅.借书证号%type,  vis_图书编号 in 借阅.图书编号%type  )  as vis_是否借出 图书.是否借出%type;begin  select 是否借出 into vis_是否借出 from 图书 where vis_图书编号 = 图书.图书编号;  if vis_是否借出=&#x27;是&#x27; then   dbms_output.put_line(&#x27;该书已经被借走了！&#x27;);  else     select 图书.是否借出     into vis_是否借出     from 图书     where 图书.图书编号=vis_图书编号;    insert into 借阅(借书证号,图书编号,借书日期)     values(vis_借书证号,vis_图书编号,sysdate);   commit;    end if;   end;\n\n\n建立与借书存储过程相对应的触发器，当借阅表中加入借阅信息时，该触发器触发，自动修改所借图书的是否借出改为‘是’。\n\ncreate or replace trigger TR_借书       after insert on 借阅       for each rowbegin  update 图书 set 是否借出 = &#x27;是&#x27; where 图书编号 = :new.图书编号;end;\n\n5、 修改实验三还书功能的存储过程，该存储过程要求：（1）还书时输入借书证号，图书编号，罚款分类号。（即该函数有3个输入参数）（2）还书时，还书日期为系统时间。\n\n该存储过程主体部分只有一条UPDATE语句。\n\ncreate or replace procedure Processed_还书 (vis_借书证号 in 借阅.借书证号%type,vis_图书编号 in 借阅.图书编号%type)as vis_是否借出 图书.是否借出%type;begin  update 借阅 set 借阅.归还日期 = sysdate()  where 借阅.借书证号 = vis_借书证号  and 借阅.图书编号 = vis_图书编号  and 借阅.归还日期 is null;end;\n\n\n建立与还书存储过程相对应的触发器，当借阅表中填入还书日期时，该触发器触发，自动修改所还图书的是否借出为‘否’。\n\ncreate or replace trigger TR_还书after update on 借阅for each row  begin    update 图书 set 是否借出 = &#x27;否&#x27;    where 图书编号 = :new.图书编号;end;","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验（二）数据查询","url":"/2021/04/28/Database-experiment-2/","content":"实验类型验证型实验\n实验目的\n掌握查询语句的一般格式；\n熟练掌握单表查询、连接查询、集合查询、统计查询和嵌套查询。\n\n实验内容\n单表查询\n连接查询\n嵌套查询\n集合查询\n\n实验步骤\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n查询学号“20061234”号借书证借阅未还的图书的信息。\n查询各个出版社的图书最高单价、平均单价。\n要查询借阅了两本和两本以上图书的读者的个人信息。\n查询“王菲”的单位、所借图书的书名和借阅日期。\n查询每类图书的册数和平均单价。\n统计从未借书的读者人数。\n统计参与借书的人数。\n找出所有借书未还的读者的信息及所借图书编号及名称。\n检索书名是以“红”开头的所有图书的书名和作者。\n查询各图书的罚款总数。\n查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空（左外连接）\n查询借阅了所有“文学”类书目的读者的姓名、单位。\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n求总藏书量、藏书总金额，总库存册数、最高价、最低价。\n\n列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\n\n列出年份最久远的书?\n\n目前实际已借出多少册书？\n\n哪一年的图书最多？\n\n哪本借书证未归还的图书最多？\n\n平均每本借书证的借书册数。\n\n哪个单位的读者平均借书册数最多？\n\n最近两年都未被借过的书。注意：Oracle 系统日期时间 sysdate，更多关于oracle日期函数请自行查阅。\n\n今年未借过书的借书证。\n\n\n实验结果实验内容\n查询“红楼梦”目前可借的各图书编号，及所属版本信息。（是否借出为‘否‘的图书）\n\nselect *from 书目,图书where 书目.ISBN=图书.ISBNand 书名=&#x27;红楼梦&#x27;and 是否借出=&#x27;否&#x27;\n\n\n   查找高等教育出版社的所有书目及单价，结果按单价降序排序。\n\nselect *from 书目where 出版单位=&#x27;高等教育出版社&#x27;order by 单价 desc;\n\n\n   统计“红楼梦”各版的藏书数量（ISBN不同则版本不同）。\n\nselect count(ISBN),ISBNfrom 书目where 书名=&#x27;红楼梦&#x27;group by ISBN;\n\n\n   查询学号“20061234”号借书证借阅未还的图书的信息。\n\nselect 借书证号,书名,书目.ISBN ,出版单位,作者,单价,    图书分类号from 书目,借阅,图书where 书目.ISBN=图书.ISBNand 借阅.图书编号=图书.图书编号 and 是否借出=&#x27;是&#x27;and  归还日期 is NULLand 借书证号=20061234;\n\n\n   查询各个出版社的图书最高单价、平均单价。（同上）\n\nselect 出版单位,max(单价),avg(单价)from 书目group by 出版单位;\n\n\n   要查询借阅了两本和两本以上图书的读者的个人信息。\n\nselect * from 读者 where 借书证号 in(select 借书证号from 借阅group by 借书证号 having count(借书证号)&gt;=2);\n\n\n   查询“王菲”的单位、所借图书的书名和借阅日期。\n\nselect 单位,书名,借书日期from 读者,借阅,书目,图书where  姓名=&#x27;王菲&#x27;and 读者.借书证号=借阅.借书证号and 借阅.图书编号=图书.图书编号and 图书.ISBN=书目.ISBN ;\n\n\n   查询每类图书的册数和平均单价。\n\nselect count(图书分类号),avg(单价)from 书目group by 图书分类号;\n\n\n   统计从未借书的读者人数。\n\nselect count(姓名)from 读者where not exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   统计参与借书的人数。\n\nselect count(姓名)from 读者where exists (select * from 借阅 where 读者.借书证号=借阅.借书证号);\n\n\n   找出所有借书未还的读者的信息及所借图书编号及名称。\n\nselect distinct 借阅.借书证号,姓名,单位,性别,地址,联系电话,身份证编号,借阅.图书编号,书名from 借阅,书目,读者,图书where 借阅.借书证号=读者.借书证号and 借阅.图书编号=图书.图书编号and 书目.ISBN=图书.ISBNand 归还日期 is null;\n\n\n   检索书名是以“红”开头的所有图书的书名和作者。\n\nselect 书名,作者from 书目where 书名 like &#x27;红%&#x27;;\n\n\n   查询各图书的罚款总数。（分组，图书编号+罚款总数）\n\nselect 书目.ISBN,sum(罚金)from 借阅,罚款分类,书目,图书where 借阅.罚款分类号=罚款分类.罚款分类号and 借阅.图书编号=图书.图书编号group by 书目.ISBN\n\n\n   查询借阅及罚款分类信息，如果有罚款则显示借阅信息及罚款名称、罚金，如果没有罚款则罚款名称、罚金显示空\n\nselect * from 借阅  left outer join 罚款分类 on(借阅.罚款分类号=罚款分类.罚款分类号)\n\n\n   查询借阅了所有“文学”类书目的读者的姓名、单位。（判断条件）\n\nselect 读者.姓名,读者.单位from 读者where not exists(      select *      from 书目,图书分类      where 书目.图书分类号=图书分类.图书分类号 and 图书分类.类名=&#x27;文学&#x27; and not exists      (            select *            from 借阅,图书            where 借阅.图书编号=图书.图书编号 and 借阅.借书证号=读者.借书证号 and 书目.ISBN=图书.ISBN      ))\n\n实验扩展\n在书目关系中新增“出版年份”，并在该属性下添加数据。（使用SQL完成）\n\n\nISBN\n书名\n作者\n出版单位\n出版年份\n单价\n图书分类号\n\n\n\n7040195836\n数据库系统概论\n王珊\n高等教育出版社\n2005\n39.00\n200\n\n\n9787508040110\n红楼梦\n曹雪芹\n人民出版社\n1983\n20.00\n100\n\n\n9787506336239\n红楼梦\n曹雪芹\n作家出版社\n2008\n34.30\n100\n\n\n9787010073750\n心学之路\n张立文\n人民出版社\n2009\n33.80\n300\n\n\n\n\nalter table 书目add 出版年份 number;update 书目 set 出版年份=2005 where ISBN=7040195836;update 书目 set 出版年份=1983 where ISBN=9787508040110;update 书目 set 出版年份=2008 where ISBN=9787506336239;update 书目 set 出版年份=2009 where ISBN=9787010073750;\n\n2、求总藏书量、藏书总金额，总库存册数、最高价、最低价。\nselect count(图书编号),sum(单价),max(单价),min(单价)from 书目,图书where 书目.ISBN=图书.ISBN;\n\n3、列出藏书在5本以上的书目（书名、作者、出版社、出版年份）。\nselect 书名,作者,出版单位,出版年份from 书目where 书目.ISBN in(select 图书.ISBNfrom 图书group by 图书.ISBN having count( 图书.ISBN)&gt;5);\n\n4、列出年份最久远的书?\nselect 书名,作者,出版单位,出版年份from 书目where 书目.出版年份 in(select min(书目.出版年份)from 书目)\n\n5、目前实际已借出多少册书？\nselect count(借阅.借阅流水号) 借出数量from 借阅where 归还日期 is null;\n\n6、哪一年的图书最多？\nselect * from (select 出版年份,count(出版年份) 数量 from 图书,书目 where 图书.ISBN = 书目.ISBNgroup by 出版年份 order by count(出版年份) desc ) where rownum=1;\n\n7、 哪本借书证未归还的图书最多？\nselect * from (select 借书证号from 借阅where 归还日期 is nullgroup by 借书证号order by count(借书证号) desc) where rownum=1\n\n8、平均每本借书证的借书册数。\nselect 借书证号,count(借书证号)from 借阅 group by 借书证号;\n\n9、哪个单位的读者平均借书册数最多？\nselect 读者.单位from 读者where 读者.借书证号 in (select 借书证号 from (select 借书证号, count(借书证号)from 借阅group by 借书证号order by  count(借书证号) desc ) where rownum=1);\n\n10、最近两年都未被借过的书。\nselect distinct(书目.ISBN),书目.书名,书目.出版单位from 图书,书目,借阅where 图书.图书编号=借阅.图书编号and 书目.ISBN=图书.ISBNand 借阅.借书日期not between to_date(&#x27;20180101&#x27;,&#x27;yyyy/mm/dd&#x27;)and to_date(&#x27;20191231&#x27;,&#x27;yyyy/mm/dd&#x27;);","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"数据库实验五、六","url":"/2021/04/28/Database-experiment-4/","content":"实验类型验证型实验\n实验目的\n了解数据库恢复技术的原理\n了解oracle各类故障的数据恢复方法\n了解oracle的物理备份\n掌握oracle数据库逻辑备份方法\n掌握oracle数据库恢复的方法\n学会使用exp备份数据库、使用imp恢复数据库\n了解flashback 的使用\n学会使用PLSQL/developer工具完成导入导出\n理解数据库的安全性保护\n掌握ORACLE中有关用户创建的方法\n理解数据库存取控制机制\n熟练掌握PL-SQL的数据控制语言，能通过自主存取控制进行权限管理\n熟悉用户资源文件的使用\n熟悉ORACLE中角色管理\n熟悉视图机制在自主存取控制上的应用\n\n实验内容\n查看归档模式\n使用exp导出数据库\n使用imp导入数据库\n使用flashback 闪回表\n使用PLSQL/developer工具完成导出\n使用PLSQL/developer工具完成导入\n\n实验步骤实验五\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。\n热备份和冷备份，分别使用什么归档模式？\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n客户端可以使用RMAN进行热备份吗？\n逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl按照提示进行导出（2）删除自己表空间中的“预约”表（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl按照提示进行导入（4）查询导入的“预约”表中的信息。（5）导出数据库（以全库方式导出）。\n\n\n必须是DBA才能执行完整数据库或表空间导出操作。\n\n\n使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE   ROW  MOVEMENT（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE   读者 TO TIMESTAMP   TO_ TIMESTAMP(….)\n使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签SQL 插入（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导入表，利用SQL插入导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer（3）浏览或者输入输出文件，然后点击导出。（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。（6）删除自己表空间中的“预约”表（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。（8）查询导入的预约表，检查导出是否正确。\n\n实验六\n同学之间相互授权访问对方“读者”表并能进行查询。\n以SYS登录数据库 为你的账号增加系统角色DBA.\n重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。\n建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）\n创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。\n建立视图VIEW_READER, 该视图包含书目（ISBN, 书名，作者，出版单位，图书分类名称）（注：所有属性来自关系书目和图书分类）\n创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。\n\n实验结果\n查看系统归档模式。（在SQLPLUS中）SQL&gt; archive log list。对各参数值进行解释。使用SYS登录，由于是超级管理员所以要使用： “口令+ as sysdba”登录\n\n\n\n输入archive log list\n\n\n\n热备份和冷备份，分别使用什么归档模式？热备份针对归档模式的数据库，在数据库仍旧处于工作状态时进行备份。而冷备份是指在数据库关闭后，进行备份，适用于所有模式的数据库，热备份的优点在于当备份时，数据库仍旧可以被使用并且可以将数据库恢复到任意一个时间点。冷备份的优点在于他的备份和回复操作相当简单，并且由于冷备份的数据可以工作在非归档模式下，数据库性能会比归档模式稍好。\n如何对WINDOWS平台服务器中的ORCL数据库进行冷备份？说明方法。\n\n1)正常关闭数据库2)备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）3)完成备份后启动数据库4. 客户端可以使用RMAN进行热备份吗？ 可以5. 逻辑备份（1）导出自己表空间中的“预约”表在运行中输入：exp 用户名/密码@orcl 按照提示进行导出\n\n\n（2）删除自己表空间中的“预约”表\n\n\n\n（3）进行导入数据库操作在运行中输入：IMP 用户名/密码@orcl，按照提示进行导入\n\n\n\n（4）查询导入的“预约”表中的信息。\n\n\n（5）导出数据库（以全库方式导出）。exp S5120188039/yyk1776572104@orcl FULL=Y\n\n\n\n\n6、使用Flashback（1）设置行可移动SQL&gt;ALTER TABLE 读者 ENABLE ROW MOVEMENT\n\n\n（2）在读者表中添加多条记录（或者删除没有借书的读者记录）。插入数据：\nINSERT INTO 读者 VALUES(&#x27;20181452&#x27;,&#x27;胡晋源&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20186666&#x27;,&#x27;吕硕&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null);INSERT INTO 读者 VALUES(&#x27;20188039&#x27;,&#x27;姚永坤&#x27;,&#x27;四川绵阳西科大计算机学院&#x27;,&#x27;男&#x27;,null,null,null); \n\n（3）闪回到改变前（TO_ TIMESTAMP函数完成对非时间戳类型数据的转换）SQL&gt;FLASHBACK TABLE 读者 TO TIMESTAMP TO_ TIMESTAMP(….)代码：\nFLASHBACK TABLE 读者 TO TIMESTAMP TO_TIMESTAMP(&#x27;2020/11/15 16:30:00&#x27;,&#x27;YYYY/MM/DD HH24:MI:SS&#x27;);\n\n7、使用PLSQL/developer 来完成SQL导出（1）打开PLSQL/developer，选择菜单“工具”导出表\n\n\n（2）点击你要导出的表，然后选择标签SQL插入\n\n\n（3）选中复选框创建表，浏览或者输入输出文件，然后点击导出\n\n\n（4）在你输入的目录下找到你的导出文件（SQL 文件）（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导入表，利用SQL插入导入数据库预约表。\n\n\n\n（8）查询导入的预约表，检查导出是否正确。\n\n\n8、使用PLSQL/developer 来完成PLSQL/developer方式导出（1）打开PLSQL/developer，选择菜单“工具“导出表（2）点击你要导出的表，然后选择标签PLSQL/developer\n\n\n（3）浏览或者输入输出文件，然后点击导出。\n\n\n（4）在你输入的目录下找到你的导出文件。（5）依次导出你账户下所有用户自定义表。\n\n\n（6）删除自己表空间中的“预约”表\ndrop table 预约;\n\n（7）通过“工具“导出表，PLSQL/developer方式导入数据库预约表。\n\n\n（8）查询导入的预约表，检查导出是否正确\n\n\n实验六1、同学之间相互授权访问对方“读者”表并能进行查询。2、以SYS登录数据库 为你的账号增加系统角色DBA.\n\n\n使用 “GRANT DBA TO + 用户名”给自己的账号增加系统角色DBA：\n\n\n3、 重新以自己的账号登录，创建一个数据库用户：账号_USER1（注：账号即学生登录数据库账号：S2009XXXX）该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。然后以该用户登录，查看该用户的所有系统权限。（1）登录\n\n\n（2）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER1 IDENTIFIED BY ORCL;\n\n\n\n（3）使用GRANT CONNECT TO S5120188039_USER1;\nGRANT RESOURCE TO S5120188039_USER1;GRANT DBA TO S5120188039_USER1;\n\n\n4、 建立角色：账号_OPER,该角色拥有调用存储过程借书、还书、预约的权限，以及查询读者，书目，图书，借阅以及预约表的权限。（注：执行存储过程的授权语句Grant execute on procedure_name  to user/role）（1）创建角色\nCREATE ROLE S5120188039_OPER;\n\n（2）授权\nGRANT EXECUTE ON PROCESSED_借书 TO S5120188039_OPER;GRANT EXECUTE ON PROCESSED_还书 TO S5120188039_OPER;GRANT EXECUTE ON PROCEDURE_预约 TO S5120188039_OPER;\n\nGRANT SELECT ON 读者 TO S5120188039_OPER;GRANT SELECT ON 书目 TO S5120188039_OPER;GRANT SELECT ON 图书 TO S5120188039_OPER;GRANT SELECT ON 借阅 TO S5120188039_OPER;GRANT SELECT ON 预约 TO S5120188039_OPER;\n\n\n5、创建一个数据库用户：账号_USER2（注：账号即：S2009XXXX）为该用户授权角色：账户_OPER。以该用户登录，完成借书功能。（1）使用CREATE USER 用户+_USER1 IDENTIFIED BY ORCL;创建用户\nCREATE USER S5120188039_USER2 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT S5120188039_OPER TO S5120188039_USER2;\n\n（3）重新登录并且实现借书过程\n\nCALL S5120188039.PROCESSED_借书(20051001,1005050);\n\n（4）查询结果\n\n\n7、 创建一个数据库用户：账号_USER3（注：账号即：S2009XXXX）该用户具有对视图VIEW_READER查询的权限。创建一个概要文件，如果 账号_USER3连续3次登录失败，则锁定该账户，10天后该账户自动解锁。以该用户登录进行权限测试。（1）创建数据库用户\nCREATE USER S5120188039_USER3 IDENTIFIED BY ORCL;\n\n（2）授权\nGRANT CONNECT TO S5120188039_USER3;\n\nGRANT SELECT ON VIEW_READER TO S5120188039_USER3;\n\n（3）创建概要文件\nCREATE PROFILE LOCK_USER LIMITFAILED_LOGIN_ATTEMPTS 3PASSWORD_LOCK_TIME 10;\n\n（4）分配概要文件\nALTER USER S5120188039_USER3 PROFILE LOCK_USER;\n\n（5）测试输入错误，锁定用户\n\n\n（6）账户锁定进行解锁\nALTER USER S5120188039_USER3 ACCOUNT UNLOCK;\n\n（7）再次测试\n","categories":["experiment","数据库实验"],"tags":["experiment","Database-experiment"]},{"title":"HTML语义化","url":"/2021/05/28/Html-study-1/","content":"定义\nHTML语义化就是根据具体内容，选择合适的标签进行代码的编写。便于开发者阅读和写出更优雅的代码，同时让搜索引擎的爬虫能更好的识别。\n\n简单来讲就是：用正确的标签做正确的事\n\n\n举例说明比如说：\n\n段落用&lt;p&gt;标签\n标题用h1~h6标签\n文章就用article\n\n为什么要使用语义化标签1、 CSS文件读取失败的准备：万一CSS文件挂了，语义化的HTML也能呈现较好的内容结构与代码结构。2、 提高：    - 可访问性：简单来讲，便于其他设备的解析，比如：移动端设备，盲人阅读器等；    - 可检索性：提高搜索引擎的有效爬取，提高网站流量；    - 国际化：让各国开发者容易弄懂网页结构；    - 互用性：减少网页间的差异性，便于团队开发和维护。\n","categories":["HTML学习笔记"],"tags":["HTML","HTML学习笔记"]},{"title":"Http和Https","url":"/2021/04/28/Front-end-basic-learning-1/","content":"Http和Https基本概念\nHttp\n超文本传输协议，是互联网上应用最为广泛的一种网络协议\n是一个客户端和服务器端请求和应答的标准，即TCP\n用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少\nHTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response。\n\n\nHttps\n以安全为目标的http通道/http的安全版\nhttp下加入SSL层\n安全基础为SSL，加密内容需要SSL\n主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n优点：使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n缺点：\nhttps 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\nhttps 缓存不如 http 高效，会增加数据开销。\nSSL 证书需要钱，功能越强大的证书费用越高。\nSSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。\n\n\n\n\n\ntips：\n\nSSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。\nSSL协议可分为两层：  ① SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。  ② SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。\n\n区别\nhttp传输的数据是未加密的，连接很简单，是无状态的；https由SSL协议来对http协议传输的数据进行加密，安全性更高\nHttps 协议需要 ca 证书，费用较高。\n使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443\n\ntips：\n\nCA是证书的签发机构，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。\nCA是负责签发证书、认证证书、管理已颁发证书的机关。\nCA 拥有一个证书（内含公钥和私钥）。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。\n\nhttps协议工作原理① 客户使用 https url 访问服务器，web 服务器建立 ssl 链接② web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。③ 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。④ 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。⑤ web 服务器通过自己的私钥解密⑥ web 服务器通过会话密钥加密与客户端之间的通信。\nhttp 请求的方式\n1、OPTIONS&emsp;&emsp;返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD&emsp;&emsp;向服务器索取与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET&emsp;&emsp;向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url4、POST&emsp;&emsp;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form5、PUT&emsp;&emsp;向指定资源位置上传其最新内容6、DELETE&emsp;&emsp;请求服务器删除Request-URL所标识的资源7、TRACE&emsp;&emsp;回显服务器收到的请求，主要用于测试或诊断8、CONNECT&emsp;&emsp;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n","categories":["前端学习笔记"],"tags":["前端","Http","Https"]},{"title":"TCP和UDP","url":"/2021/07/20/tcp-ip/","content":"TCP 三次握手\n\n\nC 发起请求连接 S 确认，也发起连接 C 确认① 第一次握手：S确认可以接收C发送的报文段② 第二次握手：C确认S收到了自己发送的报文段，然后确认接受到了S发送的报文段③ 第三次握手：S确认C接受到了自己发送的报文段\n\nTCP和UDP的区别\n\n\n比较项\nTCP\nUDP\n\n\n\n首部\n首部为20字节\n只有8个字节\n\n\n连接上\n面向连接，可靠性传输\n发送数据前不需要先建立链接，不可靠\n\n\n传输上\n无差错，不丢失，不重复，且按序到达\n尽最大努力交付，不保证可靠交付\n\n\n对象上\n面向字节流，网络出现拥塞发送率会降低\n面向报文，网络出现拥塞会出现丢包情况\n\n\n服务对象数量\n仅支持1对1\n支持1对1，1对多\n\n\n","categories":["前端学习笔记"],"tags":["TCP","UDP"]},{"title":"JavaScript学习笔记（一）JS概述","url":"/2021/07/20/js-1/","content":"JavaScript实现完整的 JavaScript 实现包含以下几个部分：\n\n核心（ECMAScript）\n文档对象模型（DOM）\n浏览器对象模型（BOM）\n\nECMAScript\nWeb 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。\nECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼。\nECMAScript符合性\n支持 ECMA-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；\n支持 Unicode 字符标准。\n增加 ECMA-262 中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。\n支持 ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。\n\n\n\nDOM\n定义：文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使用扩展的 XML。\nDOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。\n\nDOM级别\nLevel1：目标是映射文档结构\nLevel2：增加了对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）。\nLevel3：增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM Load and Save 的新模块中），还有验证文档的方法（DOM Validation）\n\nBOM\n定义：浏览器对象模型（BOM）API，用于支持访问和操作浏览器的窗口。\n是唯一一个没有相关标准的 JavaScript 实现。\nBOM 主要针对浏览器窗口和子窗口（frame）\n\n","categories":["前端学习笔记","JS","ECMAScript","DOM","BOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二）HTML中的JavaScript","url":"/2021/07/20/js-2/","content":"&lt;script&gt;元素&lt;script&gt;元素拥有的属性\n\n\n属性\n状态\n作用\n备注\n\n\n\nasync\n可选\n立即开始下载脚本，但不能阻止其他页面动作\n只对外部脚本文件有效\n\n\ncharset\n可选\n使用 src 属性指定的代码字符集\n很少使用，大多数浏览器不在乎其值\n\n\ncrossorigin\n可选\n配置相关请求的CORS（跨源资源共享）设置\n默认不使用CORS\n\n\ndefer\n可选\n表示脚本可以延迟到文档完全被解析和显示之后再执行\n只对外部脚本文件有效\n\n\nintegrity\n可选\n允许比对接收到的资源和指定的加密签名以验证子资源完整性\n用于确保内容发布网络不会提供恶意内容\n\n\nlanguage\n废弃\n用于表示代码块中的脚本语言\n\n\n\nsrc\n可选\n表示包含要执行的外部文件\n\n\n\ntype\n可选\n标识代码块中脚本语言的内容类型\n代替language\n\n\nJavaScript代码引入方式直接在网页中嵌入JavaScript代码\n示例：\n&lt;script&gt;    function message()&#123;        console.log(&quot;Hello World!&quot;)    &#125;&lt;/script&gt;\n&lt;script&gt;内的代码会被从上到下解释；\n\n在使用行内 JavaScript 代码时，要注意代码中不能出现字符串&lt;/script&gt;；\n\n浏览器解析行内脚本的方式决定了它在看到字符串&lt;/script&gt;时，会将其当成结束的&lt;/script&gt;标签。想避免这个问题，只需要转义字符“\\”。\n\n\n//错误&lt;script&gt;    function message()&#123;        console.log(&quot;&lt;/script&gt;&quot;);    &#125;&lt;/script&gt;//正确写法&lt;script&gt;    function message()&#123;        console.log(&quot;&lt;\\/script&gt;&quot;);    &#125;&lt;/script&gt;\n\n通过在网页中包含外部JS文件\n前提：在&lt;script&gt;标签中使用src属性引入外部文件。\n\n不同文档的引入方式：\n//HTML&lt;script src=&quot;message.js&quot;&gt;&lt;/script&gt;//XHTML&lt;script src=&quot;message.js&quot;/&gt;\n外部JS文件的扩展名是js，不是必须的。\n\n浏览器不会检查所包含JS文件的扩展名\n为使用服务器端脚本语言动态生成JS代码/在浏览器中将JS扩展语言转译为JS提供了可能性。\n\n\n使用src属性后&lt;script&gt;标签中不应该包含其他JS代码\n\n如果都存在，则会忽略行内代码同时下载并执行脚本文件\n\n\nsrc属性可以是完整的URL  ① src属性向指定路径发送一个GET请求  ② 获取相应资源\n\n该GET请求：\n\n不受浏览器同源策略限制\n受父页面HTTP/HTTPS协议的限制\n\n\n\n标签位置\n将所有JS引用放在&lt;body&gt;元素中&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;     &lt;title&gt;Hello World&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 这里是页面内容 --&gt;         &lt;script src=&quot;message1.js&quot;&gt;&lt;/script&gt;         &lt;script src=&quot;message2.js&quot;&gt;&lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;\n\n推迟执行脚本\n&lt;script&gt;的defer属性：表示脚本会被延迟到整个页面都解析完毕后再运行。\n只对外部脚本文件有效\nH5规范要求脚本因该按照它们出现的顺序执行\n建议：将需要推迟的脚本放在页面底部\n\n&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;     &lt;title&gt;Hello World&lt;/title&gt;    &lt;script defer src=&quot;message1.js&quot;&gt;&lt;/script&gt;    &lt;script defer src=&quot;message2.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 这里是页面内容 --&gt;     &lt;/body&gt; &lt;/html&gt;\n\n异步执行脚本\nH5为&lt;script&gt;元素定义了async属性，表示：脚本不需要等待其他脚本，同时也不阻塞文档渲染\n只适用于外部脚本\n添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本\n异步脚本不应该再加载期间修改DOM\n使用async后页面不能使用document.write\n\n动态加载脚本\n向DOM中动态添加script元素\nlet script = document.createElement(&#x27;script&#x27;);script.src = &#x27;message.js&#x27;;document.head.appendChild(script);\n默认为异步方式加载，可以设置同步加载\n\n在文档头部显式声明，进而让预加载器知道动态请求文件的存在\n&lt;link rel=&quot;preload&quot; href=&quot;message.js&quot;&gt;\n\n外部文件优点\n可维护性：用一个目录保存所有JS文件，更容易维护\n缓存：根据特定的设置缓存所有外部链接的JS文件\n适应未来\n\n文档模式作用告诉浏览器以哪种模式呈现，如何解析文档，也就是说两种模式主要影响CSS内容的呈现，某些情况下也会影响JavaScript的执行。\n类型\n混杂模式：向后兼容的解析方式\n标准模式：要求严格的DTD，根据web标准去解析页面的模式\n准标准模式：准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计\n\n模式开启方法1、 混杂模式\n混杂模式在所有浏览器中都以省略文档开头的doctype声明作为开关\n2、 标准模式\n&lt;!-- HTML 4.01 Strict --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;!-- XHTML 1.0 Strict --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; &lt;!-- HTML5 --&gt; &lt;!DOCTYPE html&gt;\n\n3、 准标准模式\n&lt;!-- HTML 4.01 Transitional --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;!-- HTML 4.01 Frameset --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; &lt;!-- XHTML 1.0 Transitional --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;!-- XHTML 1.0 Frameset --&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三）JS语法基础","url":"/2021/07/21/js-3/","content":"标识符定义&emsp;&emsp;变量、函数、属性或函数参数的名称。\n规则命名规则\n第一个字符必须是一个字母、下划线或美元符号\n剩下字符可以是字母、下划线、美元符号或数字\n\n其它\n使用小驼峰命名方式（首字母小写，后面每个单词首字母大写）\n关键字、保留字、true、false和null不能作为标识符\n\n严格模式在脚本开头加上：&quot;use strict&quot;;\nfunction message()&#123;    &quot;use strict&quot;;    //函数体&#125;\n\n关键字和保留字\n关键字：\n\n保留字：\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四）变量声明关键字","url":"/2021/07/21/js-4/","content":"var作用域\n使用var操作符定义的变量会成为包含它的函数的局部变量\n去掉var操作符，该操作符成为全局变量\n严格模式下，如果向这样给未声明的变量赋值，会导致抛出 ReferenceError。function test()&#123;    var message = &quot;Hello World!&quot;;&#125;test()console.log(message)//报错----------------------function test()&#123;    message = &quot;Hello World!&quot;;&#125;test()console.log(message)//Hello World!\n\n声明提升\n把所有变量声明都拉到函数作用域的顶部\n\nfunction test()&#123;    console.log(message);    var message = &quot;Hello World!&quot;;&#125;test()//underfined--------等价如下代码--------function test()&#123;    var message;    console.log(message);    message = &quot;Hello World!&quot;;&#125;test()//underfined\n\nlet\n块作用域：作用域仅限于该块内部。\nif(true)&#123;    let message = &quot;Hello World!&quot;;    console.log(message)//Hello World!&#125;console.log(message)//ReferenceError:message没有定义\n同一个块级作用域不能出现重复声明\n\n声明冗余报错不会因混用 let 和 var 而受影响\n\n原因：这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在var message;var message;//正常声明不会报错--------------let message;let message;//SyntaxError:标识符message已经声明过了--------------let message;var message;//SyntaxError:标识符message已经声明过了\n\n\n对于嵌套使用相同标识符，不会出错。\n//声明的变量的值被覆盖if(true)&#123;    var message = &quot;Hello&quot;;    console.log(message)//Hello    if(true)&#123;        var message = &quot;World!&quot;;        console.log(message)//World!    &#125;&#125;-----------------------------------//声明变量的作用域不同if(true)&#123;    let message = &quot;Hello&quot;;    console.log(message)//Hello    if(true)&#123;        let message = &quot;World!&quot;;        console.log(message)//World!    &#125;&#125;\n\n暂时性死区\n定义：let声明之前的执行瞬间被称为“暂时性死区”\n在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。console.log(message);//ReferenceError:message没有定义let message = &quot;Hello World!&quot;;\n\n\n\n全局声明\nlet在全局作用域中声明的变量，不会成为windows对象的属性var message = &quot;Hello World!&quot;;console.log(window.message)//Hello World!-------------------let message = &quot;Hello World!&quot;;console.log(window.message)//underfined\n\n条件声明\nlet不能依赖条件声明模式\n\nfor循环中的let声明\n对比以下实例：\n\nfor(var i=0;i&lt;5;i++)&#123;&#125;console.log(i)//5------------------for(let i=0;i&lt;5;i++)&#123;&#125;console.log(i)//ReferenceError:i未定义\n\nvar声明的迭代变量保存的是导致循环退出的值\nlet声明的迭代变量会为每一个迭代循环声明一个新的迭代变量for(var i=0;i&lt;5;i++)&#123;    setTimeout(()=&gt;console.log(i),0)&#125;//5,5,5,5,5--------------------for(let i=0;i&lt;5;i++)&#123;    setTimeout(()=&gt;console.log(i),0)&#125;//0,1,2,3,4\n\nconst声明\n与let基本相同\n声明变量时必须同时初始化变量，且初始化后不能被修改\nconst声明的限制只适用于它指向的变量的引用const message = &#123;&#125;;message.first = &quot;Hello World!&quot;;message.second = &quot;Say GoodBye!&quot;;\n对于for-of和for-in循环可以很好的使用for(const key in &#123;a:1,b:2&#125;)&#123;    console.log(key)&#125;//a,b\n\n总结比较\n\n\n比较项\nvar\nlet\nconst\n\n\n\n作用域\n全局作用域\n块级作用域\n块级作用域\n\n\n变量声明提升\n是\n否\n否\n\n\n重复声明\n是\n否\n否\n\n\n优先级\n尽量不使用\n次之\n最高\n\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（五）数据类型概述","url":"/2021/07/21/js-5/","content":"数据类型\nECMAScript有6种简单数据类型：Undefined、Null、Boolean、Number、String、Symbol。其中Symbol时ES6新增的数据类型\nObject为复杂数据类型\n\ntypeof操作符\ntypeof是一个操作符，不是函数let message = &quot;Hello World!&quot;;console.log(typeof message);//stringconsole.log(typeof(message));//string\n调用typeof null 返回的是”object”\n特殊值 null 被认为是一个对空对象的引用\n\n\n\n返回值当我们在使用typeof操作符来检测变量时会得到下列字符串之一：\n\n\n\n字符串\n意义\n\n\n\nunderfined\n未定义\n\n\nboolean\n布尔值\n\n\nstring\n字符串\n\n\nnumber\n数值\n\n\nobject\n对象或null\n\n\nfunction\n函数\n\n\nsymbol\n符号\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（六）操作符","url":"/2021/07/21/js-6/","content":"\n操作符包括：数学操作符、位操作符、关系操作符和相等操作符。\n操作符可用于各种值，包括字符串、数值、布尔值、甚至还有对象。\n在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。\n\n一元操作符定义\n只操作一个值的操作符叫一元操作符\n\n递增/递减操作符分类\n前缀版\n操作符位于待操作变量的前面\n副作用：无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变let num = 10;let other = --num + 5;let another = num + 5;console.log(num);//9console.log(other);//14console.log(another);//14\n\n\n后缀版\n操作符位于待操作变量的后面\n后缀版递增和递减在语句被求值后才发生let num = 10;let another = num-- + 5;console.log(num);//10console.log(another);//14\n\n\n前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。\n\n规则\n\n\n数据类型\n规则\n类型转换\n\n\n\n字符串\n有效数值形式，转换为数值再应用改变\n字符串→数值\n\n\n字符串\n非有效数值形式，将变量的值设置为NaN\n字符串→数值\n\n\ntrue\n转换为1再应用改变\n布尔值→数值\n\n\nfalse\n转换为0再应用改变\n布尔值→数值\n\n\n浮点数\n加1或减1\n\n\n\n对象\n调用valueOf()方法取得可以操作的值，对得到的值应用上述规则；如果是NaN，则调用toString()并再次应用其他规则\n对象→数值\n\n\n一元加和减一元加号\n如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换；\n布尔值 false和 true 转换为 0 和 1；\n字符串根据特殊规则进行解析；\n对象会调用它们的 valueOf()和/或 toString()方法以得到可以转换的值。\n\nlet s1 = &quot;01&quot;;let s2 = &quot;1.1&quot;;let s3 = &quot;z&quot;;let a = &#x27;25&#x27;;let b = false;let f = 1.1;let o = &#123;    valueOf()&#123;        return -1;    &#125;&#125;console.log(+s1);//1console.log(+s2);//1.1console.log(+s3);//NaNconsole.log(+a);//25console.log(+b);//0console.log(+f);//1.1console.log(+o);//-1\n\n一元减号\n一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值；\n在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：\n\nlet s1 = &quot;01&quot;;let s2 = &quot;1.1&quot;;let s3 = &quot;z&quot;;let a = &#x27;25&#x27;;let b = false;let f = 1.1;let o = &#123;    valueOf()&#123;        return -1;    &#125;&#125;console.log(-s1);//-1console.log(-s2);//-1.1console.log(-s3);//NaNconsole.log(-a);//-25console.log(-b);//0console.log(-f);//-1.1console.log(-o);//-1\n\n位操作符\nECMAScript中的所有数值都以 IEEE 754 64位格式存储；\n位操作并不直接应用到 64 位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位；\n有符号整数使用 32 位的前 31 位表示整数值；第 32 位表示数值的符号，如 0 表示正，1 表示负。\n负值以一种称为二补数（或补码）的二进制编码存储。\n特殊值NaN 和Infinity在位操作中都会被当成 0 处理；\n如果将位操作符应用到非数值，那么首先会使用 Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。\n\n按位非\n按位非操作符用波浪符（~）表示\n按位非的最终效果是对数值取反并减 1\n\n按位与\n按位与操作符用和号（&amp;）表示。\n真值表：a&amp;b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n0\n\n\n按位或\n按位或操作符用管道符（|）表示。\n真值表：a|b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n1\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n按位异或\n按位异或操作符用脱字符（^）表示。\n真值表：a^b\n\n\n\n\na\nb\nresult\n\n\n\n1\n1\n0\n\n\n1\n0\n1\n\n\n0\n1\n1\n\n\n0\n0\n0\n\n\n左移\n左移操作符用两个小于号（&lt;&lt;）表示\n如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000）\n\n\n\n有符号右移\n有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）\n\n\n\n无符号右移\n无符号移用 3 个大于号表示（&gt;&gt;&gt;），会将数值的所有 32 位都向右移\n对于正数，无符号右移与有符号右移结果相同。\n\n布尔操作符布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。\n逻辑非\n逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值，始终返回布尔值。\n逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。\n转化规则：\n\n\n\n\n操作数\n结果\n\n\n\n对象\nfalse\n\n\n空字符串\ntrue\n\n\n非空字符串\nfalse\n\n\n数值0\ntrue\n\n\n非0数值\nfalse\n\n\nnull\ntrue\n\n\nNaN\ntrue\n\n\nunderfined\ntrue\n\n\n\n同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。\n\n逻辑与\n逻辑与操作符由两个和号（&amp;&amp;）表示\n\n\n\n\n操作数一\n操作数二\nresult\n\n\n\ntrue\ntrue\ntrue\n\n\ntrue\nfalse\nfalse\n\n\nfalse\ntrue\nfalse\n\n\nfalse\nfalse\nfalse\n\n\n\n如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n第一个操作数是对象\n返回第二个操作数\n\n\n第二个操作数是对象\n只有第一个操作数求值为true才会返回该对象\n\n\n两个操作数都是对象\n返回第二个操作数\n\n\n有一个操作数是null\n返回null\n\n\n有一个操作数是NaN\n返回NaN\n\n\n有一个操作数是underfined\n返回underfinded\n\n\n\n逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。\n当变量未被定义则不能对它应用逻辑与操作符。\n\n逻辑或\n逻辑或操作符由两个管道符（||）表示\n\n\n\n\n操作数一\n操作数二\nresult\n\n\n\ntrue\ntrue\ntrue\n\n\ntrue\nfalse\ntrue\n\n\nfalse\ntrue\ntrue\n\n\nfalse\nfalse\nfalse\n\n\n\n如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n第一个操作数是对象\n返回第一个操作数\n\n\n第二个操作数求值为false\n返回第二个操作数\n\n\n两个操作数都是对象\n返回第一个操作数\n\n\n两个操作数是null\n返回null\n\n\n两个操作数是NaN\n返回NaN\n\n\n两个操作数是underfined\n返回underfinded\n\n\n\n逻辑或操作符也具有短路的特性，第一个操作数求值为true，第二个操作数就不会再被求值了。\n\n乘性操作符\nECMAScript 定义了 3 个乘性操作符：乘法、除法和取模。\n如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。\n\n乘法操作符（*）\n\n\n操作数\n结果\n\n\n\n都是数值\n正值相乘为正，负值相乘为正，正负不同相乘为负；如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity乘以 0\n返回 NaN\n\n\n如果是 Infinity 乘以非 0的有限数值\n根据第二个操作数的符号返回 Infinity 或-Infinity\n\n\n如果是 Infinity 乘以 Infinity\n返回 Infinity\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n除法操作符（/）\n\n\n操作数\n结果\n\n\n\n都是数值\n正值相乘为正，负值相除为正，正负不同相除为负；如果 ECMAScript 不能表示商，则返回 Infinity 或-Infinity。\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity除以 Infinity\n返回 NaN\n\n\n如果是 0除以 0\n返回 NaN\n\n\n如果是 非0的有限值除以0\n根据第一个操作数的符号返回 Infinity 或-Infinity\n\n\n如果是 Infinity 除以任何数值\n根据第二个操作数的符号返回 Infinity\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n取模操作数（%）\n\n\n操作数\n结果\n\n\n\n都是数值\n执行常规除法运算，返回余数\n\n\n如果被除数是无限值，除数是有限值\n返回 NaN\n\n\n如果被除数是有限值，除数是0\n返回 NaN\n\n\n如果是 0 除以 0\n返回 NaN\n\n\n如果是 Infinity 除以 Infinity\n返回NaN\n\n\n如果被除数是有限值，除数是无限值\n返回NaN\n\n\n如果被除数是 0 ，除数不是 0\n返回0\n\n\n如果有不是数值的操作数\n先在后台用 Number()将其转换为数值，然后再应用上述规则\n\n\n指数操作数\nES7新增了指数操作符“**”等价于Math.pow()\n指数操作符也有指数赋值操作符**=\n\n加性操作符加法操作符\n如果两个操作数都是数值，应用如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity 加 Infinity\n返回 Infinity\n\n\n如果是 -Infinity 加 -Infinity\n返回 -Infinity\n\n\n如果是 Infinity 加 -Infinity\n返回 NaN\n\n\n如果是 +0 加 +0\n返回 +0\n\n\n如果是 -0 加 +0\n返回 +0\n\n\n如果是 -0 加 -0\n返回 -0\n\n\n\n如果有一操作数是字符串，应用如下规则：\n\n\n\n\n操作数\n结果\n\n\n\n如果两个操作数都是字符串\n第二个字符串拼接到第一个字符串后面\n\n\n如果只有一个操作数是字符串\n将另一个操作数转为字符串，然后再将两个字符串拼接在一起\n\n\n\n如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。\n对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。\n\n减法操作符\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是 NaN\n返回 NaN\n\n\n如果是 Infinity 减 Infinity\n返回 NaN\n\n\n如果是 -Infinity 减 -Infinity\n返回 NaN\n\n\n如果是 Infinity 减 -Infinity\n返回 Infinity\n\n\n如果是 -Infinity 减 Infinity\n返回 -Infinity\n\n\n如果是 +0 加 +0\n返回 +0\n\n\n如果是 +0 加 -0\n返回 -0\n\n\n如果是 -0 加 -0\n返回 +0\n\n\n\n如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。\n如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。\n\n关系操作符\n关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）。\n\n\n\n\n操作数\n结果\n\n\n\n都是数值\n执行数值比较\n\n\n都是字符串\n比较字符串中对应字符的编码\n\n\n如果有任一操作数是数值\n将另一个操作数转换为数值，执行数值比较\n\n\n如果有任一操作数是对象\n调用其valueOf()方法，取得结果后再根据前面的规则执行比较;如果对象没有 valueOf()方法，则调用其 toString()方法,取得结果后再根据前面的规则执行比较\n\n\n如果有任一操作数是布尔值\n将其转换为数值再执行比较\n\n\n相等操作符等于和不等于\n等于操作符用两个等于号（==）表示\n不等于操作符用叹号和等于号（!=）表示\n这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。\n转换规则如下：\n\n\n\n\n操作数\n结果\n\n\n\n如果有任一操作数是布尔值\n将其转换为数值再比较是否相等\n\n\n如果一个操作数是字符串，另一个操作数是数值\n࠼试将字符串转换为数值，再比较是否相等\n\n\n如果一个操作数是对象，另一个操作数不是\n调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较\n\n\n\n在进行比较时，这两个操作符会遵循以下规则：\nnull和underfined相等\nnull 和 undefined 不能转换为其他类型的值再进行比较\n如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true\n如果两个操作数都是对象，则比较它们是不是同一个对象\n\n\n\n全等和不全等\n全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回回 true\n\n条件操作符variable = boolean_expression ? true_value : false_value\n赋值操作符\n简单赋值用等于号（=）表示，将左手边的值赋给右手边的变量\n复合赋值：仅仅是简写语法，使用它们不会提升性能\n\n逗号操作符\n逗号操作符可以用来在一条语句中执行多个操作\n在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值let num = (5,1,4,8,0);console.log(num);//0\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（七）语句","url":"/2021/07/21/js-7/","content":"if语句\n语法格式：\nif(condition) statement1 else statement2if(condition1)&#123;    statement1&#125; else if(condition2)&#123;    statement2&#125; else&#123;    statement3&#125;\n\n\n\ndo-while语句\n后循环语句：循环体中的代码执行后才会对推出条件进行求值\n语法格式：\n\ndo&#123;    statement&#125;while (expression);\n\nwhile语句\n语法格式：\n\nwhile(expression)&#123;    statement&#125;\n\nfor语句\n语法格式：\n\nfor(initialization;expression;post-loop-expression)&#123;    statement&#125;\n\n\n无穷循环：\n\nfor(::)&#123;    statement&#125;\n\nfor-in语句\nfor-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性\n语法格式：\n\nfor(property in expression)&#123;    statement&#125;\n\n所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异\n如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体\n\nfor-of语句\nfor-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素\n语法格式：\n\nfor(property of expression)&#123;    statement&#125;\n\n\nfor-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素\n如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误\nES2018 对 for-of 语句进行了扩展，增加了 for-await-of 循环支持生成期约的异步可迭代对象。\n\n标签语句\n语法格式：label: statement//--------举例---------start: for(let i=0;i&lt;count;i++)&#123;    console.log(i);&#125;\n\nbreak和continue语句\nbreak 语句用于立即退出循环，强制执行循环后的下一条语句\ncontinue 语句也用于立即退出循环，但会再次从循环顶部开始执行\n\nwith语句\nwith 语句的用途是将代码作用域设置为特定的对象\n语法格式：with (expression) statement;//---------举例----------let a = location.search.sustring(1);let b = location.hostname;let c = location.href;//等价于with(location)&#123;    let a = search.sustring(1);    let b = hostname;    let c = href;&#125;\n\nswitch语句\n语法格式：switch(expression)&#123;    case value1:        statement        break;    case value2:        statement        break;    case value3:        statement        break;    default:        statement&#125;\nswitch 语句可以用于所有数据类型,因此可以使用字符串甚至对象\n条件的值不需要是常量，也可以是变量或表达式\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（八）原始值与引用值","url":"/2021/07/21/js-8/","content":"什么是原始值和引用值\n原始值（primitive value）就是最简单的数据\n原始值有六种：Undefined、Null、Boolean、Number、String 和 Symbol；\n保存原始值的变量是按值（by value）访问的，直接对存储在变量中的实际值进行操作\n\n\n引用值（reference value）则是由多个值构成的对象\n引用值是保存在内存中的对象\nJavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间\n保存引用值的变量是按引用（by reference）访问的\n在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身\n\n\n\n动态属性\n动态属性实际上就是在对象被创建后给这个对象添加新的属性，该属性可以被访问使用，直至对象被销毁或者属性被显示的删除。\n原始值是不能有属性的，只有引用值可以动态添加后面可以使用的属性\n原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。let str1 = &quot;message&quot;;let str2 = new String(&quot;Matt&quot;);str1.age = 18;str2.age = 20;console.log(typeof str1);//stringconsole.log(typeof str2);//onjectconsole.log(str1.age);//underfinedconsole.log(str2.age);//20\n\n复制值对于原始值\n在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。\n两个变量可以独立使用，互不干扰。let num1 = 5;let num2 = num1;\n\n\n对于引用值\n在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;Nicholas&quot;; console.log(obj2.name); // &quot;Nicholas&quot;\n\n\n传递参数\nECMAScript 中所有函数的参数都是按值传递的\nECMAScript 中函数的参数就是局部变量\n对象保存在全局作用域的堆内存上，当对象作为参数传递给函数并在函数内部实现了操作，那么该对象会被修改\n\nfunction addFive(num)&#123;    num += 5;    return num;&#125;let count = 5;let result = addFive(count);console.log(count);//5console.log(result);//10//----------------------------function setName(obj)&#123;    obj.name = &quot;Nicholas&quot;;&#125;let person = new Object();setName(person);console.log(person.name);//&quot;Nicholas&quot;\n\n确定类型\ntypeof 操作符最适合用来判断一个变量是否为原始类型，typeof 虽然对原始值很有用，但它对引用值的用处不大。\ninstanceof可用来判断具体类型\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（九）执行上下文和作用域","url":"/2021/07/21/js-9/","content":"\n每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上\n全局上下文是最外层的上下文；\n在浏览器中，全局上下文就是我们常说的 window 对象；\n上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数；\n当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文ಖ会弹出该函数上下文，将控制权返还给之前的执行上下文；\n上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain），其决定了各级上下文中的代码在访问变量和函数时的顺序；\n活动对象最初只有一个定义变量：arguments；\n全局上下文的变量对象始终是作用域链的最后一个变量对象；\n\n作用域链增强\ntry/catch语句中的catch块\ncatch 语句而言，则会创建一个新的变量对象\n\n\nwith语句\n语句会向作用域链前端添加指定的对象\n\n\n\n变量声明\nvar作用域声明\n\n使用var声明变量时，变量会被自动添加到最接近的上下文；\n如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文\nvar 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前\n通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是Reference Errorvar name = &quot;Lacus&quot;;//等价于name = &quot;Lacus&quot;;var name;//---------------------console.log(msg);//underfinedvar msg = &quot;boy&quot;;\n\n\nlet块级作用域\n\n块级作用域由最近的一对包含花括号{}界定；\nif 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域；\nlet 在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError；\nlet 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部\nlet 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。for(var i=0;i&lt;10;i++)&#123;&#125;console.log(i);//10for(let j=0;i&lt;10;j++)&#123;&#125;console.log(j);//ReferenceError: j没有定义\n\n\nconst常量声明\n\nconst 声明的变量必须同时初始化为౼个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值\nconst 声明只应用到顶级原语或者对象\n\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十）垃圾回收","url":"/2021/07/21/js-10/","content":"\nJavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存；\n通过自动内存管理实现内存分配和闲置资源回收；\n基本思路：确定哪个变量不会再使用，然后释放它占用的内存\n这个过程是周期性的，即垃圾回收程序每隔一定时间，就会自动运行\n\n\n两种主要的标记策略：标记清理和引用计数\n\n标记清理定义当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记；当变量离开上下文时，也会被加上离开上下文的标记。\n标记方式\n当变量进入上下文时，反转某一位\n维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表\n\n引用计数设计思路\n对每个值都记录它被引用的次数；\n声明变量并给它赋一个引用值时，这个值的引用数为 1；\n如果同一个值又被赋给另一个变量，那么引用数加 1；\n如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1；\n当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。\n\n性能\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要；\n无论什么时候开始收集垃圾，都能让它尽快结束工作；\n现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行；\n在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收\n在Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序\n\n内存管理\n将内存占用量保持在一个较小的值可以让页面性能更好；\n优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据；\n解除引用：如果数据不再必要，那么把它设置为 null，从而释放其引用；\n\n通过const和let声明提升性能let和const是块级作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存\n隐藏类和删除操作内存泄漏静态分配与对象池","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Undefined、Null、Boolean）","url":"/2021/07/21/js-5-1/","content":"Undefined类型\n只含有underfined一个值\n\n变量定义但未初始化时自动赋予underfined\n\n变量定义但未初始化和未定义是不同的\nlet message;console.log(message);//underfinedconsole.log(mix)//Error\nunderfined常用于比较来确定变量是否初始化/赋值了\nlet message = underfined;console.log(message == underfined);//true\n变量无论是声明还是未声明，typeof 返回的都是字符串”undefined”\n\nundefined 是一个假值\nlet message;if(message)&#123;    console.log(&quot;变量初始化了！&quot;)&#125;else&#123;    console.log(&quot;变量未初始化！&quot;)&#125;//变量未初始化\n\nNull类型\n只有一个值：null，表示一个空对象指针\nundefined是由null派生而来的，表面上相等\nnull是一个假值\n当变量要保存对象但没有对象来保存可以用null填充\n\nBoolean类型\n有两个字面值：true和false\n布尔值不同于数值，即：true!=1,false!=0\n其它类型的值可以转化为布尔类型\n\n\n\n\n数据类型\n转为true\n转为false\n\n\n\nBoolean\ntrue\nfalse\n\n\nString\n非空字符串\n空字符串\n\n\nNumber\n非零数值（包括无穷）\n0，NaN\n\n\nObject\n任意对象\nnull\n\n\nUnderfined\nN/A（不存在）\nunderfined\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（String）","url":"/2021/07/21/js-5-3/","content":"概述定义零或多个16位Unicode字符序列。\n创建方式\n单引号、双引号、反引号标示。\n以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。\n\nlet message = &#x27;Hello World&#x27;let message1 = &quot;Hello World&quot;let message2 = `Hello World`\n\n字符字面量\n用于标识非打印字符或有其他用途的字符。\n转义序列表示一个字符，在计算字符串长度时算一个字符。\n如下表：\n\n\n\n\n字面量\n含义\n\n\n\n\\n\n换行\n\n\n\\t\n制表\n\n\n\\b\n退格\n\n\n\\r\n回车\n\n\n\\f\n换页\n\n\n\\\\\n反斜杠\n\n\n\\&#39;\n单引号\n\n\n\\&quot;\n双引号\n\n\n字符串特点\n不可变：一旦创建就不能发生变化\n如果要修改每个变量中的字符串的值，必须先销毁原始的字符串然后重新赋值\n\n转换字符串\n方法：toString()\nnull和undefined没有toString()方法，直接返回两个值的字面量文本\n数值调用toString方法可以接受一个参数，表示进制。let num = 10console.log(num.toString(2))//&quot;1010&quot;console.log(num.toString(8))//&quot;12&quot;\n\n模板字面量（ES6）\n模板字面量保留换行字符，可以跨行定义字符串let message1 = &#x27;one\\ntwo&#x27;;let message2 = `onetwo`;console.log(message1);//one//twoconsole.log(message2);//one//twoconsole.log(message1==message2);//true\n\n字符串插值\n表达式：${变量}\n模板字面量不是字符串，是一种特殊的JS语句表达式\n\nlet value = 5;let message = `$&#123;value&#125;+$&#123;value&#125;=$&#123;value*value&#125;`;console.log(message);//5+5=10\n\n\n所有插入的值都会使用toString()强制转为字符串\n\n模板字面量标签函数\n标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果\n\nlet a = 5;let b = 10;function simple(str,aVal,bVal,sum)&#123;    console.log(str);    console.log(aVal);    console.log(bVal);    console.log(sum);    return &#x27;finish&#x27;;&#125;//可使用剩余操作符收入到一个数组中function Tag(str,...exper)&#123;    console.log(str);    for(const expression of exper)&#123;        console.log(experssion)    &#125;&#125;let message = `$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;let result = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]//5//10//15let result1 = Tag`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;//[&quot;&quot;,&quot; + &quot;,&quot; = &quot;,&quot;&quot;]//5//10//15console.log(result)//&#x27;finish&#x27;\n\n原始字符串\nString.raw标签函数可用于获取原始字符串\n键盘输入的回车等不能获取到原始字符\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Number）","url":"/2021/07/21/js-5-2/","content":"Number类型概述\nNumber 类型使用 IEEE 754 格式表示整数和浮点值\n\n不同数值类型有不同的数值字面量格式\n\n八进制字面量：\n/*1、第一个数字必须是0，然后对应八进制数字2、字面量中数字超出范围就会忽略第一个0，然后当作十进制处理*/let num1 = 070;//56let num2 = 079;//十进制79let num3 = 08;//十进制8\n十六进制字面量：\n/*1、前缀为0x且区分大小写2、字母大小写均可*/let num1 = 0xa;//10let num2 = 0x1F;//31\n\n浮点数基础知识\n定义：数值中必须包含小数点，并且小数点后面必须至少有一个数字let floatNum1 = 5.20;let floatNum2 = 13.14;let floatNum3 = .20;//不推荐使用\n存储浮点值使用的内存空间是整数值的两倍\n\n科学计数法\n用于表示一个应该乘以10的给定次幂的数值\n表示方式：let num1 = 3.125e7let num2 = 31250000console.log(num1 == num2)//true\nES会将小数点后至少包含6个零的浮点值转为科学计数法\n\n精确度\n精确度可达17为小数console.log(0.05+0.25 == 0.15+0.15)//trueconsole.log(0.1+0.2 == 0.3)//false\nIEEE 754标准：\n\n\n\n值的范围\n由于内存的限制，ES并不支持所有数值\n如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity\n无法表示的负数：-Infinity（负无穷大）\n无法表示的正数：Infinity（无穷大）\n当计算返回正/负无穷时不能再进一步用于任何计算。\nisFinite()函数可用于检测值是不是有限大\nNumber.NEGATIVE_INFINITY和Number,POSIYIVE_INFINITY可以获取正/负无穷let result1 = 3+5;console.log(inFinite(result1));//true------------------let result2 = Number.MAX_VALUE + Number.MAX_VALUEconsole.log(inFinite(result2));//false\n\nNaN\n表示不是数值\nES中，0，+0，-0相除会返回NaN：console.log(0/0);//NaNconsole.log(-0/+0);//NaN\n分母是有符号或无符号0，返回正/负无穷：console.log(512/0);//Infinityconsole.log(512/-0);//-Infinity\nNaN不等于包括NaN在内的任何值console.log(NaN == NaN)//false\nisNaN()用于检测是否为NaN\n可接受任意数据类型\n任何不能转换为数值的值都会使得函数返回true\n\n\n\n\n   \n      数据类型\n      内容\n      结果\n   \n   \n      字符串\n      可以转换为数值\n      false\n   \n   \n      \n      不可以转换为数值\n      true\n   \n   \n      布尔值\n      true\n      false\n   \n   \n      \n      false\n      true\n   \n   \n      数值\n      数字\n      false\n   \n   \n      \n      NaN\n      true\n   \n   \n      \n   \n\n\n数值转换\n\n\n转换函数\nNumber()\nparseInt()\nparseFloat()\n\n\n\n布尔值\ntrue → 1false → 0\nNaN\nNaN\n\n\n数值\n直接返回\n返回对应整数\n返回对应数值\n\n\nnull\n返回0\nNaN\nNaN\n\n\nunderfined\n返回NaN\nNaN\nNaN\n\n\n字符串\n①包含有（无）符号数字字符串→对应十进制数值②包含有效浮点值→对应浮点数③包含十六进制格式→对应十进制④空字符串→返回0⑤除此之外→返回NaN\n①字符串最前面的空格会被忽略，从第一个非空格字符开始转换②如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN③如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符\n①从位置 0 开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止② 始终忽略字符串开头的零③只解析十进制值④ 如果字符串表示整数（没有小数点或者小数点后面只有一个零），则返回整数\n\n\n对象\n调用valueOf()方法，并按上述规则返回值；如果转换结果为NaN，则调用toString()方法，再按照字符串规则转换\nNaN\nNaN\n\n\n\nparseInt(str,base)有两个参数：\nstr：接受一个带转化的字符串\nbase：为一个数值，表示进制\n\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Symbol）","url":"/2021/07/21/js-5-4/","content":"基本用法\nSymbol为原始类型，可以使用typeof操作符进行检测\n\nlet mes = Symbol();console.log(typeof mes)//Symbol\n\n\nSymbol(name)\nname作为对符号的描述\n与符号定义或标识完全无关\n\n\n\nlet sys1 = Symbol(&#x27;foo&#x27;);let sys2 = Symbol(&#x27;foo&#x27;);console.log(sys1 == sys2);//false\n\n\n符号没有字面量语法\n创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性\nSymbol()不能与new关键字一起作为构造函数使用\n为了避免创建符号包装对象\n\n\n可以使用Object()函数创建符号包装对象let str = new String();console.log(typeof str);//objectlet sys = new Symbol();// TypeError: Symbol is not a constructorlet mySymbol = Symbol();let objsys = Object(mySymbol);console.log(typeof objsys);//object\n\n全局符号注册表\nSymbol.for()\n第一次使用౼个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。\n即使使用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同\n全局注册表中的符号必须使用字符串键来创建\n作为参数传给 Symbol.for()的任何值都会被转换为字符串\n注册表中使用的键同时也会被用作符号描述\n\n\n\nlet sys1 = Symbol.for(&#x27;foo&#x27;);let sys2 = Symbol.for(&#x27;foo&#x27;);let sys3 = Symbol(&#x27;foo&#x27;);let sys4 = Symbol.for();console.log(sys1 == sys2);//trueconsole.log(sys1 == sys3);//falseconsole.log(sys4);//Symbol(underfined)\n\n\nSymbol.keyFor() 来查询全局注册表\n如果查询的不是全局符号，则返回 undefined\n如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError\n\nlet sys1 = Symbol.for(&#x27;foo&#x27;);let sys3 = Symbol(&#x27;foo&#x27;);console.log(Symbol.keyFor(sys1));//fooconsole.log(Symbol.keyFor(sys3));//underfinedSymbol.for(123);//TypeError:123 is not a symbol\n\n符号作为属性\n凡是可以使用字符串或数值作为属性的地方，都可以使用符号\nObject.defineProperty(obj,prop,descriptor)\nobj：被操作的对象\nprop：目标对象需要定义或修改的属性的名称\ndescriptor：将被定义或修改的属性描述符\n\n\n\nlet s1 = Symbol(&#x27;foo&#x27;);    s2 = Symbol(&#x27;bar&#x27;);    s3 = Symbol(&#x27;baz&#x27;);    s4 = Symbol(&#x27;qux&#x27;);let o = &#123;    [s1]:&#x27;foo value&#x27;&#125;;console.log(o);//&#123;Symbol(foo):foo value&#125;Object.defineProperty(o,s2,&#123;value:&#x27;bar value&#x27;&#125;);console.log(o);//&#123;Symbol(foo):foo value,Symbol(bar):bar value&#125;Object.defineProperties(o,&#123;    [s3]:&#123;value:&#x27;baz value&#x27;&#125;,    [s4]:&#123;value:&#x27;qux value&#x27;&#125;&#125;);console.log(o);//&#123;Symbol(foo):foo value,Symbol(bar): bar value,//Symbol(baz):baz value,Symbol(qux):qux value&#125;\n\n属性Symbol.asyncIterator()\n一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用\n这个符号表示实现异步迭代器 API 的函数。\nfor-await-of 循环会利用这个函数执行异步迭代操作。\n循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。\n个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例\n\nclass Emitter&#123;    constructor(max)&#123;        this.max = max;        this.asyncIdx = 0;    &#125;    async *[Symbol.asyncIterator]()&#123;        while(this.asyncIdx &lt; this.max)&#123;            yield new Promise((resolve)=&gt;resolve(this.asyncIdex++))        &#125;    &#125;&#125;async function asyncCount()&#123;    let emitter = new Emitter(5);    for await(const x of emitter)&#123;        console.log(x);    &#125;&#125;asyncCount();//0//1//2//3//4\n\nSymbol.hasInstance\n一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用\n在 ES6 中，instanceof 操作符会使用Symbol.hasInstance 函数来确定关系\n这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用\ninstanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数。\n\nfunction Foo()&#123;&#125;let f = new Foo();console.log(f instanceof Foo);//trueconsole.log(Foo[Symbol.hasInstance](f));//trueclass Bar&#123;&#125;class Baz extends Bar&#123;    static [Symbol.hasInstance]()&#123;        return false;    &#125;&#125;let b = new Baz();console.log(Bar[Symbol.hasInstance](b));//trueconsole.log(b instanceof Bar);//trueconsole.log(Baz[Symbol.hasInstance][b]);//falseconsole.log(b instanceof Baz);//false\n\nSymbol.isConcatSpreadable\n一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素\nES6 中的 Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例\n数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾\n类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。\n其他不是类数组对象的对象在 Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。\n类数组对象是指：property（属性名）为正整数的对象let arr1 = [&#x27;foo&#x27;];let arr2 = [&#x27;bar&#x27;];console.log(arr1.concat(arr2));//[&#x27;foo&#x27;,&#x27;bar&#x27;]arr2[Symbol.isConcatSpreadable] = false;console.log(arr1.concat(arr2));//[&#x27;foo&#x27;,[&#x27;bar&#x27;]]let obj = &#123;length:1,0:&#x27;baz&#x27;&#125;;console.log(arr1.concat(obj));//[&#x27;foo&#x27;,&#123;length:1,0:&#x27;baz&#x27;&#125;]obj[Symbol.isConcatSpreadable] = true;console.log(arr1.concat(obj));//[&#x27;foo&#x27;,&#x27;baz&#x27;]let set = new Set().add(&#x27;qux&#x27;);console.log(arr1.concat(set));//[&#x27;foo&#x27;,Set(1)]\n\nSymbol.iterator\n一个方法，该方法ᤄ回对象默认的迭代器。由 for-of 语句使用\nfor-of 循环这样的语言结构会利用这个函数执行迭代操作。\n\nclass Emitter&#123;    constructor(max)&#123;        this.max = max;        this.asyncIdx = 0;    &#125;    *[Symbol.interctor]()&#123;        while(this.asyncIdx &lt; this.max)&#123;            yield this.idx++;        &#125;    &#125;&#125;function Count()&#123;    let emitter = new Emitter(5);    for await(const x of emitter)&#123;        console.log(x);    &#125;&#125;Count();//0//1//2//3//4\n\nSymbol.match\n一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\nString.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。\n\nclass FooMatcher&#123;    static [Symbol.match](target)&#123;        return target.includes(&#x27;foo&#x27;);    &#125;&#125;console.log(&#x27;foobar&#x27;.match(FooMatcher));//trueconsole.log(&#x27;barbaz&#x27;.match(Foomatcher));//falseclass StringMatcher&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.match](target)&#123;        return target.includes(this.str);    &#125;&#125;console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;foo&#x27;)));//trueconsole.log(&#x27;barbaz&#x27;.match(new StringMatcher(&#x27;quz&#x27;)));//false\n\nSymbol.replace\n一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用\nString.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\n\nclass Replace&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.replace](target,replacment)&#123;        return target.split(this.str).join(replacement);    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.replace(new Replace(&#x27;foo&#x27;),&#x27;qux&#x27;));\n\nSymbol.search\n一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用\nString.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值\n给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。\n\nclass Search &#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.search](target)&#123;        return target.indexOf(this.str);    &#125;&#125;console.log(&#x27;foobar&#x27;.search(new Search(&#x27;foo&#x27;)));//0console,log(&#x27;barfoo&#x27;.search(new Search(&#x27;foo&#x27;)));//3console.log(&#x27;barbaz&#x27;.search(new Search(&#x27;qux&#x27;))); // -1\n\nSymbol.species\n一个函数值，该函数作为创建派生对象的构造函数\n用于对内置类型实例方法的返回值暴露实例化派生对象的方法\n用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义\n\nclass Bar extends Array&#123;&#125;class Baz extends Array&#123;    static get [Symbol.species]()&#123;        return  Array;    &#125;&#125;let bar = new Bar();console.log(bar instanceof Array);//trueconsole.log(bar instanceof Bar);//truebar = bar.concat(&#x27;bar&#x27;);console.log(bar instanceof Array);//trueconsole.log(bar instanceof Bar);//truelet baz = new Baz();console.log(baz instanceof Array);//trueconsole.log(baz instanceof Baz);//truebar = bar.concat(&#x27;baz&#x27;);console.log(baz instanceof Array);//trueconsole.log(baz instanceof Baz);//false\n\nSymbol.split\n一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用\nString.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值\n\nclass Spilter&#123;    static [Symbol.split](target)&#123;        return target.split(&#x27;foo&#x27;);    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(Spliter));//[&#x27;bar&#x27;,&#x27;baz&#x27;]class Split&#123;    constructor(str)&#123;        this.str = str;    &#125;    [Symbol.split](target)&#123;        return target.split(this.str)    &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(new Split(&#x27;foo&#x27;)));//[&#x27;bar&#x27;,&#x27;baz&#x27;]\n\nSymbol.toPrimitive\n一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用\n对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为\n\nclass Foo&#123;&#125;let foo = new Foo();console.log(3+foo);//&quot;3[object Object]&quot;console.log(3-foo);//&quot;NaN&quot;console.log(String(foo));//&quot;[object Object]&quot;class Bar&#123;    constructor()&#123;        this[Symbol.toPrimitive] = function(hint)&#123;            switch (hint)&#123;                case &#x27;number&#x27;:                    return 3;                case &#x27;string&#x27;:                    return &#x27;string bar&#x27;;                case &#x27;default&#x27;:                default:                    return &#x27;default bar&#x27;;             &#125;        &#125;    &#125;&#125;let bar = new Bar();console.log(3+bar);//&quot;3default bar&quot;console.log(3-bar);//0console.log(String(bar));//&quot;&quot;string bar&quot;\n\nSymbol.toStringTag\n一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用\n通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”\n\nlet s = new Set();console.log(s);//Set(0)&#123;&#125;console.log(s.toString());//[object Object]console.log(s[Symbol.toStringTag]);//Setclass Foo&#123;&#125;let foo = new Foo();console.log(foo);//Foo&#123;&#125;console.log(foo.toString());//[object Object]console.log(foo[Symbol.toStringTag]);//underfinedclass Bar&#123;    constructor()&#123;        this[Symbol.toStringTag] = &#x27;Bar&#x27;;    &#125;&#125;let bar = new Bar();console.log(bar);//Bar()console.log(bar.toString());//[object Bar]console.log(bar[Symbol.toStringTag]);//Bar\n\nSymbol.unscopables\n一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除\n不推荐使用 with，因此也不推荐使用 Symbol.unscopables\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记-数据类型（Object）","url":"/2021/07/21/js-5-5/","content":"定义\nES中对象是一组数据和功能的集合\n对象被认为是౼个特定引用类型的实例\n\n创建和使用\n对象通过new操作符跟对象类型的名称来创建\n如果没有参数，可以省略括号\n\n属性和方法\n\n\n属性和方法\n作用\n\n\n\nconstructor\n用于创建当前对象的函数\n\n\nhasOwnProperty(propertyName)\n用于判断当前对象上是否存在给定属性\n\n\nisPrototypeOf(Object)\n用于判断当前对象是否是另一个对象的原型\n\n\npropertyIsEnumerable(propertyName)\n用于判断给定的属性是否可以使用for-in语句枚举\n\n\ntoLocaleString()\n返回对象的字符串表示，该字符串反映对象所在的本地化执行环境\n\n\ntoString()\n返回对象的字符串表示\n\n\nvalueOf()\n返回对象对应的字符串、数值或布尔值表示，通常与toString()返回值相同\n\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十一）Date","url":"/2021/08/13/js-11/","content":"基本内容\nECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。\nDate 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。\n使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。\n\n\n\n创建\n要创建日期对象，就使用 new 操作符来调用 Date 构造函数\n在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间;\n\nlet now = new Date();\n\n\n要基于其他日期和时间创建日期对象，必须传入其毫秒表示。\nECMAScript为此提供了两个辅助方法：Date.parse()和Date.UTC()\nDate.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。规则如下：\n\n\n\n\n格式\n结果\n\n\n\n月/日/年\n5/23/2021\n\n\n月名 日,年\nMay 23,2021\n\n\n周几 月名 日 年 时:分:秒 时区\nSun May 23 2021 00:00:00 GMT-0700\n\n\nYYYY-MM-DDTHH:mm:ss.sssZ\n2021-05-23T00:00:00\n\n\n\n如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN；\n如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。\nDate.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（131）、时（023）、分、秒和毫秒这些参数中，只有前两个（年和月）是必需的；\n如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。\nECMAScript 还提供了 Date.now()方法，ᤄ回表示方法执行时日期和时间的毫秒数。\n\n继承的方法\nDate 类型重写了 toLocaleString()、toString()和 valueOf()方法；\nDate 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间，这通常意։着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息；\ntoString()方法通常返回ࣛ时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的；\nDate 类型的 valueOf()方法಩本就不返回字符串，这个方法被重写后ᤄ回的是日期的毫秒表示。\n\n日期格式化方法\n\n\n方法\n结果\n\n\n\ntoDateString()\n显示日期中的周几、月、日、年（格式特定于实现）\n\n\ntoTimeString()\n显示日期中的时、分、秒和时区（格式特定于实现）\n\n\ntoLocaleDateString()\n显示日期中的周几、月、日、年（格式特定于实现和地区）\n\n\ntoLocaleTimeString()\n显示日期中的时、分、秒（格式特定于实现和地区）\n\n\ntoUTCString()\n显示完整的 UTC 日期（格式特定于实现）\n\n\n日期/时间组件方法\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十二）RegExp","url":"/2021/08/13/js-12/","content":"基础知识创建语法\n正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用；\n每个正则表达式可以ࣛ带零个或多个 flags（标记），用于控制正则表达式的行为。\n\nlet expression = /pattern/flages;\n\n\n\n\nflags\n作用\n\n\n\ng\n全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的f内容就结束\n\n\ni\n不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写\n\n\nm\n多行模式，表示查找到一行文本末尾时会继续查找\n\n\ny\n粘附模式，表示只查找从 lastIndex 开始及之后的字符串\n\n\nu\nUnicode 模式，启用 Unicode 匹配\n\n\ns\ndotAll 模式，表示元字符.匹配任何字符（包括\\n 或\\r）\n\n\n\n元字符包括：( [ { \\ ^ $ | ) ] } ? * + .\n所有元字符在模式中也必须转义\n\n// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写let pattern1 = /[bc]at/i;// 匹配第一个&quot;[bc]at&quot;，忽略大小写let pattern2 = /\\[bc\\]at/i; // 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写let pattern3 = /.at/gi; // 匹配所有&quot;.at&quot;，忽略大小写let pattern4 = /\\.at/gi;\n\nRegExp 实ׁኔᙝ\nglobal：布尔值，表示是否设置了 g 标记。\nignoreCase：布尔值，表示是否设置了 i 标记。\nunicode：布尔值，表示是否设置了 u 标记。\nsticky：布尔值，表示是否设置了 y 标记。\nlastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。\nmultiline：布尔值，表示是否设置了 m 标记。\ndotAll：布尔值，表示是否设置了 s 标记。\nsource：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。\nflags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）\n\nlet pattern1 = /\\[bc\\]at/i; console.log(pattern1.global); // false console.log(pattern1.ignoreCase); // true console.log(pattern1.multiline); // false console.log(pattern1.lastIndex); // 0 console.log(pattern1.source); // &quot;\\[bc\\]at&quot; console.log(pattern1.flags); // &quot;i&quot;\n\nRegExp 实例方法\nRegExp 实例的主要方法是 exec()，主要用于配合捕获组使用；\n这个方法只接收一个参数，即要应用模式的字符串\n如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null\n返回的数组包含两个额外的属性：index 和 input，index 是字符串中匹配模式的起始位置，input 是要查找的字符串\n\n\n如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息\n\nlet text = &quot;mom and dad and baby&quot;; let pattern = /mom( and dad( and baby)?)?/gi; let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches.input); // &quot;mom and dad and baby&quot; console.log(matches[0]); // &quot;mom and dad and baby&quot; console.log(matches[1]); // &quot; and dad and baby&quot; console.log(matches[2]); // &quot; and baby&quot;\n\nRegExp 构造函数属性\n这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化；\n\n\n\nlet text = &quot;this has been a short summer&quot;; let pattern = /(.)hort/g; if (pattern.test(text)) &#123;     console.log(RegExp.input); // this has been a short summer     console.log(RegExp.leftContext); // this has been a     console.log(RegExp.rightContext); // summer     console.log(RegExp.lastMatch); // short     console.log(RegExp.lastParen); // s &#125;//==============等价于==============let text = &quot;this has been a short summer&quot;; let pattern = /(.)hort/g; /*  * 注意：Opera 不支持简写属性名 * IE 不支持多行匹配 */ if (pattern.test(text)) &#123;     console.log(RegExp.$_); // this has been a short summer     console.log(RegExp[&quot;$`&quot;]); // this has been a     console.log(RegExp[&quot;$&#x27;&quot;]); // summer     console.log(RegExp[&quot;$&amp;&quot;]); // short     console.log(RegExp[&quot;$+&quot;]); // s &#125;\n\n以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下：\ninput 属性中包含原始的字符串。\nleftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。\nlastMatch 属性包含ӛ配整个正则表达式的上一个字符串，即”short”。 \nlastParen 属性包含捕获组的上一次匹配，即”s”。\n\n局限模式下列特性目前还没有得到 ECMAScript 的支持：\n\n\\A 和\\Z 错（分别匹配字符串的开始和末尾）\n联合及交叉类\n原子组\nx（忽略空格）匹配模式\n条件式匹配\n正则表达式注释\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十五）集合引用类型","url":"/2021/08/13/js-15/","content":"Object\nObject 的实例没有多少功能，但很适合存储和在应用程序间交换数据；\n创建 Object 的实例有两种方式：\n使用 new 操作符和 Object 构造函数；\n使用对象字面量（object literal）表示法；\n\n\n在对象字面量表示法中，属性名可以是字符串或数值，但数值属性会自动转换为字符串；\n在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。\n\n//第一种let person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29;//第二种let person = &#123;     name: &quot;Nicholas&quot;,     age: 29 &#125;;\n\n\n虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。\n在使用中括号时，要在括号内使用属性名的字符串形式；\n使用中括号的主要优势就是可以通过变量访问属性；\n点语法是首选的属性存取方式，除非访问属性时必须使用变量；\n\nArrayMapWeakMapSet","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十四）单例内置对象","url":"/2021/08/13/js-14/","content":"\n定义：任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象\n这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了；\n\nGlobalGlobal对象\n\nMathMath对象","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十三）原始值包装类型","url":"/2021/08/13/js-13/","content":"\n为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。\n每当用到౼个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。\n\nlet s1 = &quot;some text&quot;; let s2 = s1.substring(2);//========以上代码实际运行步骤===========let s1 = new String(&quot;some text&quot;); let s2 = s1.substring(2); s1 = null;\n\n\n引用类型与原始值包装类型的主要区别在于对象的生命周期；\n不能在运行时给原始值添加属性和方法；\n\nBoolean\nBoolean 是对应布尔值的引用类型；\n要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false；\nBoolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false；\ntoString()方法被调用时也会被覆盖，返回字符串”true”或”false”；\n所有对象在布尔表达式中都会自动转换为 true；\nBoolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 falselet falseObject = new Boolean(false); let result = falseObject &amp;&amp; true; console.log(result); // true let falseValue = false; result = falseValue &amp;&amp; true; console.log(result); // falseconsole.log(typeof falseObject); // object console.log(typeof falseValue); // boolean console.log(falseObject instanceof Boolean); // true console.log(falseValue instanceof Boolean); // false\n\nNumber\n创建Number对象就使用 Number 构造函数并传入一个数值\n\nlet numberObject = new Number(10);\n\n\n不建议直接实例化 Number 对象，因为在处理原始数值和引用数值时，typeof 和 instacnceof 操作符会返回不同的结果\n\nlet numberObject = new Number(10); let numberValue = 10; console.log(typeof numberObject); // &quot;object&quot; console.log(typeof numberValue); // &quot;number&quot; console.log(numberObject instanceof Number); // true console.log(numberValue instanceof Number); // false\n\n基础方法\nNumber 类型重写了 valueOf()、toLocaleString()和 toString()方法\nvalueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串\ntoString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串；\n\nlet num = 10; console.log(num.toString()); // &quot;10&quot; console.log(num.toString(2)); // &quot;1010&quot; console.log(num.toString(8)); // &quot;12&quot; console.log(num.toString(10)); // &quot;10&quot; console.log(num.toString(16)); // &quot;a&quot;\n\ntoFixed()\ntoFixed()方法返回包含指定小数点位数的数值字符串；如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的\ntoFixed()方法可以表示有 0~20 个小数位的数值\n\nlet num = 10.005; console.log(num.toFixed(2)); // &quot;10.01&quot;\n\ntoExponential()\n返回以科学记数法（也称为指数记数法）表示的数值字符串\n接收一个参数，表示结果中小数的位数\n\nlet num = 10; console.log(num.toExponential(1)); // &quot;1.0e+1&quot;\n\ntoPrecision()\n会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式\n接收一个参数，表示结果中数字的总位数（不包含指数）\n本质上，toPrecision()方法会根据数值和精度来决定调用 toFixed()还是 toExponential()\n为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入\n\nlet num = 99; console.log(num.toPrecision(1)); // &quot;1e+2&quot; console.log(num.toPrecision(2)); // &quot;99&quot; console.log(num.toPrecision(3)); // &quot;99.0&quot;\n\nString\nString 是对应字符串的引用类型；\n要创建一个 String 对象，使用 String 构造函数并传入一个数值\nString 对象的方法可以在所有字符串原始值上调用\n3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值；\n每个 String 对象都有一个 .length 属性，表示字符串中字符的数量；\n即使字符串中包含双字节字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数\n\nlet stringObject = new String(&quot;hello world&quot;);let stringValue = &quot;hello world&quot;; console.log(stringValue.length); // &quot;11&quot;\n\n字符串操作方法","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript字符串操作方法","url":"/2021/09/13/js-13-1/","content":"字符串拼接方法\nconcat()用于将一个或多个字符串拼接成一个新字符串\n\nlet stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;); console.log(result); // &quot;hello world&quot; console.log(stringValue); // &quot;hello&quot;\n\n可以接收任意多个参数，因此可以一次性拼接多个字符串；\n\nlet stringValue = &quot;hello &quot;; let result = stringValue.concat(&quot;world&quot;, &quot;!&quot;); console.log(result); // &quot;hello world!&quot; console.log(stringValue); // &quot;hello&quot;\n\n从字符串中提取子字符串的方法\nslice()、substr()和 substring()；\n这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数；\n不会修改调用它们的字符串，而只会返回提取到的原始新字符串值；\n\n\n\n\n方法\n参数一\n参数二\n\n\n\nslice()\n子字符串开始的位置\n提取结束的位置\n\n\nsubstr()\n子字符串开始的位置\n返回的子字符串数量\n\n\nsubstring()\n子字符串开始的位置\n提取结束的位置\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.slice(3)); // &quot;lo world&quot; console.log(stringValue.substring(3)); // &quot;lo world&quot; console.log(stringValue.substr(3)); // &quot;lo world&quot; console.log(stringValue.slice(3, 7)); // &quot;lo w&quot; console.log(stringValue.substring(3,7)); // &quot;lo w&quot; console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot;\n\n\n当某个参数是负值时：\nslice()方法将所有负值参数都当成字符串长度加上负参数值；\nsubstr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0；\nsubstring()方法会将所有负参数值都转换为 0;\n\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.slice(-3)); // &quot;rld&quot; console.log(stringValue.substring(-3)); // &quot;hello world&quot; console.log(stringValue.substr(-3)); // &quot;rld&quot; console.log(stringValue.slice(3, -4)); // &quot;lo w&quot; console.log(stringValue.substring(3, -4)); // &quot;hel&quot; console.log(stringValue.substr(3, -4)); // &quot;&quot; (empty string)\n\n字符串位置方法\n有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()\n\n\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;)); // 4 console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7\n\n\n这两个方法都可以接收可选的第二个参数，表示开始搜索的位置；\n\nlet stringValue = &quot;hello world&quot;; console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7 console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4\n\n字符串包含方法\nstartsWith()、endsWith()和 includes()用于判断字符串中是否包含另一个字符串的方法\nstartsWith()检查开始于索引 0 的匹配项\nendsWith()检查开始于索引(string.length - substring.length)的匹配项\nincludes()检查整个字符串\n\nlet message = &quot;foobarbaz&quot;; console.log(message.startsWith(&quot;foo&quot;)); // true console.log(message.startsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;baz&quot;)); // true console.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.includes(&quot;bar&quot;)); // true console.log(message.includes(&quot;qux&quot;)); // false\n\n\nstartsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置；\n如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符\nendsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样\n\nlet message = &quot;foobarbaz&quot;; console.log(message.startsWith(&quot;foo&quot;)); // true console.log(message.startsWith(&quot;foo&quot;, 1)); // false console.log(message.includes(&quot;bar&quot;)); // true console.log(message.includes(&quot;bar&quot;, 4)); // falseconsole.log(message.endsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;bar&quot;, 6)); // true\n\ntrim()方法\n这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果；\ntrimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符；\n\nlet stringValue = &quot; hello world &quot;; let trimmedStringValue = stringValue.trim(); console.log(stringValue); // &quot; hello world &quot; console.log(trimmedStringValue); // &quot;hello world&quot;\n\nrepeat() 方法\n这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果；\n\nlet stringValue = &quot;na &quot;; console.log(stringValue.repeat(16) + &quot;batman&quot;); // na na na na na na na na na na na na na na na na batman\n\npadStart() 和 padEnd() 方法\npadStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件；\n这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）；\n\nlet stringValue = &quot;foo&quot;; console.log(stringValue.padStart(6)); // &quot; foo&quot; console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;......foo&quot; console.log(stringValue.padEnd(6)); // &quot;foo &quot; console.log(stringValue.padEnd(9, &quot;.&quot;)); // &quot;foo......&quot;\n\n\n可选的第二个参数并不限于一个字符；\n如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度；\n如果长度小于或等于字符串长度，则会返回原始字符串；\n\nlet stringValue = &quot;foo&quot;; console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot; console.log(stringValue.padStart(2)); // &quot;foo&quot; console.log(stringValue.padEnd(8, &quot;bar&quot;)); // &quot;foobarba&quot; console.log(stringValue.padEnd(2)); // &quot;foo&quot;\n\n字符串迭代与解构\n字符串的原型上暴露了一个**@@iterator方法**，表示可以迭代字符串的每个字符；\n\nlet message = &quot;abc&quot;; let stringIterator = message[Symbol.iterator](); console.log(stringIterator.next()); // &#123;value: &quot;a&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;b&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: &quot;c&quot;, done: false&#125; console.log(stringIterator.next()); // &#123;value: undefined, done: true&#125;\n\n\n在 for-of 循环中可以通过这个迭代器按序访问每个字符\n\nfor (const c of &quot;abcde&quot;) &#123;  console.log(c); &#125; // a // b // c // d // e\n\n字符串大小写转换\ntoLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()\ntoLowerCase()和toUpperCase()方法是原来就有的方法；\ntoLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现；\n\n字符串模式匹配方法\nmatch()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同；\nmatch()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象；\n\nlet text = &quot;cat, bat, sat, fat&quot;; let pattern = /.at/; // 等价于 pattern.exec(text) let matches = text.match(pattern); console.log(matches.index); // 0 console.log(matches[0]); // &quot;cat&quot; console.log(pattern.lastIndex); // 0\n\n\nsearch()方法：唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象；\n这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。\nsearch()始终从字符串开头向后匹配模式\n\nlet text = &quot;cat, bat, sat, fat&quot;; let pos = text.search(/at/); console.log(pos); // 1\n\n\nreplace()方法：接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数\n如果第一个参数是字符串，那么只会替换第一个子字符串。\n要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记\n\nlet text = &quot;cat, bat, sat, fat&quot;; let result = text.replace(&quot;at&quot;, &quot;ond&quot;); console.log(result); // &quot;cond, bat, sat, fat&quot; result = text.replace(/at/g, &quot;ond&quot;); console.log(result); // &quot;cond, bond, sond, fond&quot;\n\n\nreplace()的第二个参数可以是一个函数。\n在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串；\n在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串；\n这个函数应该返回一个字符串，表示应该把匹配项替换成什么；\n\nfunction htmlEscape(text) &#123;     return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) &#123;     switch(match) &#123;         case &quot;&lt;&quot;:             return &quot;&amp;lt;&quot;;         case &quot;&gt;&quot;:             return &quot;&amp;gt;&quot;;         case &quot;&amp;&quot;:             return &quot;&amp;amp;&quot;;         case &quot;\\&quot;&quot;:             return &quot;&amp;quot;&quot;;         &#125;     &#125;); &#125; console.log(htmlEscape(&quot;&lt;p class=\\&quot;greeting\\&quot;&gt;Hello world!&lt;/p&gt;&quot;)); // &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;\n\nlocaleCompare()方法\n这个方法比较两个字符串，返回如下 3 个值中的一个；\n如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）\n如果字符串与字符串参数相等，则返回 0。\n如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）\n\n\n\nlet stringValue = &quot;yellow&quot;; console.log(stringValue.localeCompare(&quot;brick&quot;)); // 1 console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0 console.log(stringValue.localeCompare(&quot;zoo&quot;)); // -1","categories":["前端学习笔记","JS","字符串"],"tags":["JS学习"]},{"title":"JavaScript——Global对象","url":"/2021/09/15/js-14-1/","content":"特点\n代码不会显式地访问它；\nGlobal对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法；\n在全局作用域中定义的变量和函数都会变成 Global 对象的属性；\n\n方法URL编码方式\n\nlet uri = &quot;http://www.wrox.com/illegal value.js#start&quot;; // &quot;http://www.wrox.com/illegal%20value.js#start&quot; console.log(encodeURI(uri)); // &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; console.log(encodeURIComponent(uri));\n\n\n\nlet uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;; // http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start console.log(decodeURI(uri)); // http:// www.wrox.com/illegal value.js#start console.log(decodeURIComponent(uri));\n\neval()方法\n它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串\n\neval(&quot;console.log(&#x27;hi&#x27;)&quot;); //======等价于======console.log(&quot;hi&quot;);\n\n当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置；\n通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链；\n\nlet msg = &quot;hello world&quot;; eval(&quot;console.log(msg)&quot;); // &quot;hello world&quot;\n\n\n可以在 eval()内部定义一个函数或变量，然后在外部代码中引用：\n\neval(&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;); sayHi();\n\n\n通过 eval()定义的任何变量和函数都不会被提升，它们只是在 eval()执行的时候才会被创建\n\neval(&quot;let msg = &#x27;hello world&#x27;;&quot;); console.log(msg); // Reference Error: msg is not defined\n\nGlobal对象属性\n像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性；\n所有原生引用类型构造函数，比如 Object 和 Function，也都是 Global 对象的属性；\n\n\n\nwindow对象\nECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理；\n\nvar color = &quot;red&quot;; function sayColor() &#123;     console.log(window.color); &#125; window.sayColor(); // &quot;red&quot;\n\n\n当一个函数在没有明确（通过成为౼个对象的方法，或者通过 call()/apply()）指定 this 值的情况下执行时，this 值等于Global 对象\n\nlet global = function() &#123;  return this; &#125;();\n","categories":["前端学习笔记","JS","Global对象"],"tags":["JS学习"]},{"title":"JavaScript——Math对象","url":"/2021/09/22/js-14-2/","content":"\nMath 对象上提供的计算要比直接在JavaScript实现的快得多，因为Math对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令\n\nMath对象属性\n\nmin() 和 max()方法\nmin()和 max()方法用于确定一组数值中的最小值和最大值；\n这两个方法都接收任意多个参数；\n\nlet max = Math.max(3, 54, 32, 16); console.log(max); // 54 let min = Math.min(3, 54, 32, 16); console.log(min); // 3\n\n\n要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：\n\nlet values = [1, 2, 3, 4, 5, 6, 7, 8]; let max = Math.max(...val);\n\n舍入方法\n\nconsole.log(Math.ceil(25.9)); // 26 console.log(Math.ceil(25.5)); // 26 console.log(Math.ceil(25.1)); // 26 console.log(Math.round(25.9)); // 26 console.log(Math.round(25.5)); // 26 console.log(Math.round(25.1)); // 25 console.log(Math.fround(0.4)); // 0.4000000059604645 console.log(Math.fround(0.5)); // 0.5 console.log(Math.fround(25.9)); // 25.899999618530273 console.log(Math.floor(25.9)); // 25 console.log(Math.floor(25.5)); // 25 console.log(Math.floor(25.1)); // 25\n\nrandom()方法\nMath.random()方法ᤄ回一个 0~1 范围内的随机数\n从一组整数中随机选择一个数：\n\nnumber = Math.floor(Math.random() * total_number_of_choices + first_possible_value)\n\n//从 1~10 范围内随机选择一个数let num = Math.floor(Math.random() * 10 + 1);//从 2~10 范围内随机选择一个数function selectFrom(lowerValue, upperValue) &#123;     let choices = upperValue - lowerValue + 1;     return Math.floor(Math.random() * choices + lowerValue); &#125; let num = selectFrom(2,10); console.log(num); // 2~10 范围内的值，其中包含 2 和 10\n\n\n如果是为了加密而需要生成随机数，建议使用 window.crypto.getRandomValues()\n\n其他方法","categories":["前端学习笔记","JS","Global对象"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Set","url":"/2021/10/18/js-15-4/","content":"基本API\n创建的同时初始化实例：\n\n// 使用数组初始化集合 const s1 = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s1.size); // 3 // 使用自定义迭代器初始化集合const s2 = new Set(&#123;     [Symbol.iterator]: function*() &#123;         yield &quot;val1&quot;;         yield &quot;val2&quot;;         yield &quot;val3&quot;;     &#125; &#125;); alert(s2.size); // 3\n\n\n初始化之后，可以使用：\nadd ()增加值；\nhas()查询；\nsize取得元素数量；\ndelete()删除元素；\n\n\n\nconst s = new Set(); alert(s.has(&quot;Matt&quot;)); // false alert(s.size); // 0 s.add(&quot;Matt&quot;)  .add(&quot;Frisbie&quot;); alert(s.has(&quot;Matt&quot;)); // true alert(s.size); // 2 s.delete(&quot;Matt&quot;); alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // true alert(s.size); // 1 s.clear(); // 销毁集合实例中的所有值alert(s.has(&quot;Matt&quot;)); // false alert(s.has(&quot;Frisbie&quot;)); // false alert(s.size); // 0 \n\n\nSet 可以包含任何 JavaScript 数据类型作为值：\n\nconst s = new Set(); const functionVal = function() &#123;&#125;; const symbolVal = Symbol(); const objectVal = new Object(); s.add(functionVal); s.add(symbolVal); s.add(objectVal); alert(s.has(functionVal)); // true alert(s.has(symbolVal)); // true alert(s.has(objectVal)); // true // SameValueZero 检查意味着独立的实例不会冲突alert(s.has(function() &#123;&#125;)); // false\n\n\n用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变:\n\nconst s = new Set(); const objVal = &#123;&#125;,     arrVal = []; s.add(objVal); s.add(arrVal); objVal.bar = &quot;bar&quot;; arrVal.push(&quot;bar&quot;); alert(s.has(objVal)); // true alert(s.has(arrVal)); // true\n\n\nadd()和delete ()操作是幂等的；\ndelete()返回一个布尔值，表示集合中是否存在要删除的值:\n\nconst s = new Set(); s.add(&#x27;foo&#x27;); alert(s.size); // 1 s.add(&#x27;foo&#x27;); alert(s.size); // 1 // 集合里有这个值alert(s.delete(&#x27;foo&#x27;)); // true // 集合里没有这个值alert(s.delete(&#x27;foo&#x27;)); // false\n\n顺序与迭代\n集合实例可以提供一个迭代器( Iterator ),能以插入顺序生成集合内容。\n可以通过values()方法及其别名方法keys() (或者Symbol. iterator属性，它引用values() )取得这个迭代器:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); alert(s.values === s[Symbol.iterator]); // true alert(s.keys === s[Symbol.iterator]); // true for (let value of s.values()) &#123;  alert(value); &#125; // val1 // val2 // val3 for (let value of s[Symbol.iterator]()) &#123;  alert(value); &#125; // val1 // val2 // val3\n\n\nvalues ()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); console.log([...s]); // [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;] \n\n\n集合的entries()方法返回一个迭代器，可以按照插人顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); for (let pair of s.entries()) &#123;  console.log(pair); &#125; // [&quot;val1&quot;, &quot;val1&quot;] // [&quot;val2&quot;, &quot;val2&quot;] // [&quot;val3&quot;, &quot;val3&quot;] \n\n\n如果不使用迭代器，而是使用回调方式，则可以调用集合的forEach() 方法并传人回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值:\n\nconst s = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]); s.forEach((val, dupVal) =&gt; alert(`$&#123;val&#125; -&gt; $&#123;dupVal&#125;`)); // val1 -&gt; val1 // val2 -&gt; val2 // val3 -&gt; val3","categories":["前端学习笔记","JS","ES6","Set"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Map","url":"/2021/10/08/js-15-2/","content":"基本API\n使用 new 关键字和 Map 构造函数可以创建一个空映射；\n如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组：\n初始化之后，可以使用 set()方法再添加键/值对；\n可以使用 get()和 has()进行查询；\n可以通过 size 属性获取映射中的键/值对的数量；\n可以使用 delete()和 clear()删除值；\n\n// 使用嵌套数组初始化映射const m1 = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m1.size); // 3 const m = new Map(); alert(m.has(&quot;firstName&quot;)); // false alert(m.get(&quot;firstName&quot;)); // undefined alert(m.size); // 0 m.set(&quot;firstName&quot;, &quot;Matt&quot;)  .set(&quot;lastName&quot;, &quot;Frisbie&quot;); alert(m.has(&quot;firstName&quot;)); // true alert(m.get(&quot;firstName&quot;)); // Matt alert(m.size); // 2 m.delete(&quot;firstName&quot;); // 只删除这一个键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // true alert(m.size); // 1 m.clear(); // 清除这个映射实例中的所有键/值对alert(m.has(&quot;firstName&quot;)); // false alert(m.has(&quot;lastName&quot;)); // false alert(m.size); // 0\n\n\nMap 可以使用任何 JavaScript 数据类型作为键；\n\nconst m = new Map(); const functionKey = function() &#123;&#125;; const symbolKey = Symbol(); const objectKey = new Object(); m.set(functionKey, &quot;functionValue&quot;); m.set(symbolKey, &quot;symbolValue&quot;); m.set(objectKey, &quot;objectValue&quot;); alert(m.get(functionKey)); // functionValue alert(m.get(symbolKey)); // symbolValue alert(m.get(objectKey)); // objectValue // SameValueZero 比较意味着独立实例不冲突alert(m.get(function() &#123;&#125;)); // undefined\n\n\n在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时依然保持不变；\n\nconst m = new Map(); const objKey = &#123;&#125;,     objVal = &#123;&#125;,     arrKey = [],     arrVal = []; m.set(objKey, objVal); m.set(arrKey, arrVal); objKey.foo = &quot;foo&quot;; objVal.bar = &quot;bar&quot;; arrKey.push(&quot;foo&quot;); arrVal.push(&quot;bar&quot;); console.log(m.get(objKey)); // &#123;bar: &quot;bar&quot;&#125; console.log(m.get(arrKey)); // [&quot;bar&quot;]\n\n顺序与迭代\nMap 实例会维护键值对的插入顺序；\n映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过**entries()**方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); alert(m.entries === m[Symbol.iterator]); // true\n\n\nentries()是默认迭代器，可以直接对映射实例使用扩展操作，把映射转换为数组；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]]\n\n\nforEach(callback,opt_thisArg)方法同样可以迭代每个键/值对，第一个参数传入一个回调方法；\n第二个参数用于重写回调函数内部的this值；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); m.forEach((val, key) =&gt; alert(`$&#123;key&#125; -&gt; $&#123;val&#125;`)); // key1 -&gt; val1 // key2 -&gt; val2 // key3 -&gt; val3 \n\n\nkeys()和 values()分别返回以插入顺序生成键和值的迭代器；\n\nconst m = new Map([     [&quot;key1&quot;, &quot;val1&quot;],     [&quot;key2&quot;, &quot;val2&quot;],     [&quot;key3&quot;, &quot;val3&quot;] ]); for (let key of m.keys()) &#123;     alert(key); &#125; // key1 // key2 // key3 for (let key of m.values()) &#123;     alert(key); &#125; // value1 // value2 // value3 \n\n\n键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改；\n修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值；\n\nconst m1 = new Map([  [&quot;key1&quot;, &quot;val1&quot;] ]); for (let key of m1.keys()) &#123;     key = &quot;newKey&quot;;     alert(key); // newKey     alert(m1.get(&quot;key1&quot;)); // val1 &#125; const keyObj = &#123;id: 1&#125;; const m = new Map([     [keyObj, &quot;val1&quot;] ]); ","categories":["前端学习笔记","JS","Map"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——WeakMap","url":"/2021/10/17/js-15-3/","content":"\nWeakMap是Map 的“兄弟”类型,其API也是Map的子集。\nWeakMap中的”weak”(弱).描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。\n\n基本API\n可以使用 new 关键字实例化一个空的 WeakMap：\n\nconst wm = new WeakMap();\n\n\n弱映射中的键只能是 Object 或者继承自 Object的类型,尝试使用非对象设置键会抛出TypeError。\n值的类型没有限制。\n如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插人新实例中:\n\nconst key1 = &#123;id: 1&#125;,     key2 = &#123;id: 2&#125;,    key3 = &#123;id: 3&#125;;// 使用嵌套数组初始化弱映射const wm1 = new WeakMap([     [key1, &quot;val1&quot;],     [key2, &quot;val2&quot;],     [key3, &quot;val3&quot;] ]); alert(wm1.get(key1)); // val1 alert(wm1.get(key2)); // val2 alert(wm1.get(key3)); // val3 // 初始化是全有或全无的操作// 只要有一个键无效就会抛出错误，导致整个初始化失败const wm2 = new WeakMap([     [key1, &quot;val1&quot;],     [&quot;BADKEY&quot;, &quot;val2&quot;],     [key3, &quot;val3&quot;] ]); // TypeError: Invalid value used as WeakMap key typeof wm2; // ReferenceError: wm2 is not defined // 原始值可以先包装成对象再用作键const stringKey = new String(&quot;key1&quot;); const wm3 = new WeakMap([     stringKey, &quot;val1&quot; ]); alert(wm3.get(stringKey)); // &quot;val1&quot; \n\n\n初始化之后可以使用set ()再添加键/值对，可以使用get ()和has()查询，还可以使用delete()删除:\n\nconst wm = new WeakMap(); const key1 = &#123;id: 1&#125;,     key2 = &#123;id: 2&#125;; alert(wm.has(key1)); // false alert(wm.get(key1)); // undefined wm.set(key1, &quot;Matt&quot;)   .set(key2, &quot;Frisbie&quot;); alert(wm.has(key1)); // true alert(wm.get(key1)); // Matt wm.delete(key1); // 只删除这一个键/值对alert(wm.has(key1)); // false alert(wm.has(key2)); // true\n\n弱键\nWeakMap 中“weak”表示弱映射的键不属于正式的引用，不会阻止垃圾回收；\n只要键存在，键/值对就会存在于映射中，并被当作对值的引用；\n\nconst wm = new WeakMap(); wm.set(&#123;&#125;, &quot;val&quot;); \n\nset ()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。\n不可迭代键\n因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。\nWeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。\n\n","categories":["前端学习笔记","JS","ES6","WeakMap"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——WeakSet","url":"/2021/10/18/js-15-5/","content":"基本API\n使用new关键字实例化一个空的WeakSet:\n弱集合中的值只能是object或者继承自object的类型，尝试使用非对象设置值会抛出TypeError。\n如果想在初始化时填充弱集合，则构造函数可以接收-一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中:\n\nconst val1 = &#123;id: 1&#125;,     val2 = &#123;id: 2&#125;,     val3 = &#123;id: 3&#125;; // 使用数组初始化弱集合const ws1 = new WeakSet([val1, val2, val3]); alert(ws1.has(val1)); // true alert(ws1.has(val2)); // true alert(ws1.has(val3)); // true // 初始化是全有或全无的操作// 只要有一个值无效就会抛出错误，导致整个初始化失败const ws2 = new WeakSet([val1, &quot;BADVAL&quot;, val3]); // TypeError: Invalid value used in WeakSet typeof ws2; // ReferenceError: ws2 is not defined // 原始值可以先包装成对象再用作值const stringVal = new String(&quot;val1&quot;); const ws3 = new WeakSet([stringVal]); alert(ws3.has(stringVal)); // true \n\n\n初始化之后可以使用add()再添加新值，可以使用has()查询，还可以使用delete()删除:\n\nconst ws = new WeakSet(); const val1 = &#123;id: 1&#125;,     val2 = &#123;id: 2&#125;; alert(ws.has(val1)); // false ws.add(val1) .add(val2); alert(ws.has(val1)); // true alert(ws.has(val2)); // true ws.delete(val1); // 只删除这一个值alert(ws.has(val1)); // false alert(ws.has(val2)); // true\n\n弱值原理同WeakMap\n不可迭代值\nWeakset中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。\nWeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。\n\n","categories":["前端学习笔记","JS","ES6","WeakSet"],"tags":["JS学习"]},{"title":"Javascript——Object和Map比较分析","url":"/2021/10/17/js-tips-1/","content":"内存占用\nObject 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对;\n\n插入性能\n向object和 Map中插入新键/值对的消耗大致相当，不过插人Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。\n\n查找速度\n与插入不同，从大型object和 Map中查找键/值对的性能差异极小，但如果只包含少量键/值对,则object有时候速度更快。在把object 当成数组使用的情况下（比如使用连续整数作为属性)，浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言,查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择Obiect更好一些。\n\n删除性能\n使用delete删除object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此,出现了一些伪删除对象属性的操作，包括把属性值设置为undefined或null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map。\n\n","categories":["前端学习笔记","JS","Object","Map"],"tags":["JS学习"]},{"title":"JavaScript集合引用类型——Array","url":"/2021/09/08/js-15-1/","content":"创建数组① 使用 Array 构造函数\n在使用 Array 构造函数时，也可以省略 new 操作符；\n\nlet colors = new Array();\n\n\n如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值：\n\nlet colors = new Array(15);\n\n\n也可以给 Array 构造函数传入要保存的元素：\n\nlet colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);\n\n② 使用数组字面量（array literal）表示法：let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个元素的数组let names = []; // 创建一个空数组let values = [1,2,]; // 创建一个包含 2 个元素的数组\n\n③ from()\nfrom()用于将类数组结构转换为数组实例；\n\nArray.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构：\n// 字符串会被拆分为单字符数组console.log(Array.from(&quot;Matt&quot;)); // [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] // 可以使用 from()将集合和映射转换为一个新数组const m = new Map().set(1, 2)                     .set(3, 4); const s = new Set().add(1)                     .add(2)                     .add(3)                     .add(4); console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] // Array.from()对现有数组执行浅复制const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4] alert(a1 === a2); // false // 可以使用任何可迭代对象const iter = &#123;     *[Symbol.iterator]() &#123;         yield 1;         yield 2;         yield 3;         yield 4;     &#125; &#125;; console.log(Array.from(iter)); // [1, 2, 3, 4]// arguments 对象可以被轻松地转换为数组function getArgsArray() &#123;     return Array.from(arguments); &#125; console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] // from()也能转换带有必要属性的自定义对象const arrayLikeObject = &#123;     0: 1,     1: 2,     2: 3,     3: 4,     length: 4 &#125;; console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]\nArray.from()还接收第二个可选的映射函数参数；\n\n这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组；\n\n\n还可以接收第三个可选参数，用于指定映射函数中 this 的值；\n\n\nconst a1 = [1, 2, 3, 4]; const a2 = Array.from(a1, x =&gt; x**2); const a3 = Array.from(a1, function(x) &#123;return x**this.exponent&#125;, &#123;exponent: 2&#125;); console.log(a2); // [1, 4, 9, 16] console.log(a3); // [1, 4, 9, 16]\n\n④ of()\nArray.of()可以把一组参数转换为数组\n用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：\n\nconsole.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]console.log(Array.of(undefined)); // [undefined]\n\n数组空位\n使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）；\nECMAScript 会将逗号之间相应索引位置的值当成空位；\n\nconst options = [,,,,,]; // 创建包含 5 个元素的数组console.log(options.length); // 5 console.log(options); // [,,,,,]\n\n\nES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：\n\nconst options = [1,,,,5]; for (const option of options) &#123;  console.log(option === undefined); &#125; // false // true // true // true // falseconst a = Array.from([,,,]); // 使用 ES6 的 Array.from()创建的包含 3 个空位的数组for (const val of a) &#123;  alert(val === undefined); &#125; // true// true// truealert(Array.of(...[,,,])); // [undefined, undefined, undefined]for (const [index, value] of options.entries()) &#123;  alert(value); &#125; // 1 // undefined // undefined // undefined // 5\n\n数组索引\n要取得或设置数组的值，需要使用中括Ձ并提供相应值的数字索引：\n如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]，则数组长度会自动扩展到该索引值加 1；\n数组中最后一个元素的索引始终是 length - 1；\n数组最多可以包含 4294967295 个元素；\n\nlet colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 定义一个字符串数组alert(colors[0]); // 显示第一项colors[2] = &quot;black&quot;; // 修改第三项colors[3] = &quot;brown&quot;; // 添加第四项alert(colors.length); // 3 alert(names.length); // 0\n\n检测数组\nECMAScript 提供了 Array.isArray()方法，的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的；\n\n迭代器方法\n在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()；\nkeys()返回数组索引的迭代器；\nvalues()返回数组元素的迭代器；\nentries()返回索引/值对的迭代器；\n\nconst a = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]; // 因为这些方法都返回迭代器，所以可以将它们的内容// 通过 Array.from()直接转换为数组实例const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] console.log(aEntries); // [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]\n\n复制和填充方法\n批量复制方法 copyWithin()；\n填充数组方法 fill()；\n这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引；\n\nfill()\nfill()方法可以向一个已有的数组中插入全部或部分相同的值；\n开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾；\n负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引；\nfill()默认忽略超出数组边界、零长度及方向相反的索引范围；\n\n\n\nconst zeroes = [0, 0, 0, 0, 0]; // 用 5 填充整个数组zeroes.fill(5); console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素zeroes.fill(6, 3); console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素zeroes.fill(7, 1, 3); console.log(zeroes); // [0, 7, 7, 0, 0]; zeroes.fill(0); // 重置// 用 8 填充索引大于等于 1 且小于 4 的元素// (-4 + zeroes.length = 1) // (-1 + zeroes.length = 4) zeroes.fill(8, -4, -1); console.log(zeroes); // [0, 8, 8, 8, 0];const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略zeroes.fill(1, -10, -6); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引过高，忽略zeroes.fill(1, 10, 15); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引反向，忽略zeroes.fill(2, 4, 2); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引部分可用，填充可用部分zeroes.fill(4, 3, 10) console.log(zeroes); // [0, 0, 0, 4, 4]\n\ncopyWithin()\ncopyWithin()会按照指定范围ุ复制数组中的部分内容，然后将它们插入到指定索引开始的位置；\ncopyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：\n\nlet ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置// 在源索引或目标索引到达数组边界时停止ints.copyWithin(5); console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); // 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置ints.copyWithin(0, 5); console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]reset(); // 从 ints 中复制索引 0 开始到索引 3 结束的内容// 插入到索引 4 开始的位置ints.copyWithin(4, 0, 3); alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); // JavaScript 引擎在插值前会完整复制范围内的值// 因此复制期间不存在重写的风险ints.copyWithin(2, 0, 6); alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset(); // 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的ints.copyWithin(-4, -7, -3); alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] let ints, reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引过低，忽略ints.copyWithin(1, -15, -12); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset() // 索引过高，忽略ints.copyWithin(1, 12, 15); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引反向，忽略ints.copyWithin(2, 4, 2); alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];reset(); // 索引部分可用，复制、填充可用部分ints.copyWithin(4, 7, 10) alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];\n\n转换方法\n所有对象都有 toLocaleString()、toString()和 valueOf()方法；\n在调用数组的 toLocaleString()方法时，会得到一个以逗号分隔的数组值的字符串；\n\nlet colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,green alert(colors.valueOf()); // red,blue,green alert(colors); // red,blue,green\n\n\n首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果；\n\n\n\nlet person1 = &#123;     toLocaleString() &#123;         return &quot;Nikolaos&quot;;     &#125;,     toString() &#123;         return &quot;Nicholas&quot;;     &#125; &#125;; let person2 = &#123;     toLocaleString() &#123;         return &quot;Grigorios&quot;;     &#125;,     toString() &#123;         return &quot;Greg&quot;;     &#125; &#125;; let people = [person1, person2]; alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg alert(people.toLocaleString()); // Nikolaos,Grigorios\n\n\n如果数组中某一项是null或undefined，则在join()、toLocaleString()、toString()、valueOf()返回的结果中会以空字符串表示\n\n栈方法\n\nlet colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // black alert(colors.length); // 2\n\n队列方法\n\n\n使用shift()和 push()，可以把数组当成队列来使用：\n\nlet colors = new Array(); // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项alert(count); // 2 count = colors.push(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.shift(); // 取得第一项alert(item); // red alert(colors.length); // 2\n\n\n使用 unshift()和 pop()，可以在相反方向上模拟队列：\n\nlet colors = new Array(); // 创建一个数组let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项alert(count); // 2 count = colors.unshift(&quot;black&quot;); // 再推入一项alert(count); // 3 let item = colors.pop(); // 取得最后一项alert(item); // green alert(colors.length); // 2\n\n排序方法\n\nlet values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); // 5,4,3,2,1 \n\nsort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。\n即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。\n\n//一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。let values = [0, 1, 5, 10, 15]; values.sort(); alert(values); // 0,1,10,15,5\n\n\nsort()方法可以接收一个比较函数\n比较函数接收两个参数：\n如果第一个参数应该排在第二个参数前面，就返回负值；* 如果两个参数相等，就返回 0；\n如果第一个参数应该排在第二个参数后面，就返回正值；\n\n\n\nfunction compare(value1, value2) &#123;     if (value1 &lt; value2) &#123;         return -1;     &#125; else if (value1 &gt; value2) &#123;         return 1;     &#125; else &#123;         return 0;     &#125; &#125;let values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); // 0,1,5,10,15 \n\n\n比较函数还可简写为一个箭头函数：\n\nlet values = [0, 1, 5, 10, 15]; values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0); alert(values); // 15,10,5,1,0 \n\n操作方法concat()方法\n可以在现有数组全部元素基础上创建一个新数组；\n原理：它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾,最后返回这个新构建的数组；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]); console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]\n\n\n打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let newColors = [&quot;black&quot;, &quot;brown&quot;]; let moreNewColors = &#123;     [Symbol.isConcatSpreadable]: true,     length: 2,     0: &quot;pink&quot;,     1: &quot;cyan&quot; &#125;; newColors[Symbol.isConcatSpreadable] = false; // 强制不打平数组let colors2 = colors.concat(&quot;yellow&quot;, newColors); // 强制打平类数组对象let colors3 = colors.concat(moreNewColors); console.log(colors); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] console.log(colors3); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]\n\nslice()方法\n用于创建一个包含原有数组中一个或多个元素的新数组，操作不影响原始数组；\n接收一个或两个参数：返回元素的开始索引和结束索引；\n如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素；\n如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素；\n\n\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; let colors2 = colors.slice(1); let colors3 = colors.slice(1, 4); alert(colors2); // green,blue,yellow,purple alert(colors3); // green,blue,yellow \n\nsplice()方法\n在数组中间插入元素；\n删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量；\n插入：需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素，第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素；\n替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素；\n\nlet colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let removed = colors.splice(0,1); // 删除第一项alert(colors); // green,blue alert(removed); // red，只有一个元素的数组removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 在位置 1 插入两个元素alert(colors); // green,yellow,orange,blue alert(removed); // 空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，只有一个元素的数组\n\n搜索和位置方法\nECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索；\n\n严格相等\n\nlet numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; alert(numbers.indexOf(4)); // 3 alert(numbers.lastIndexOf(4)); // 5 alert(numbers.includes(4)); // true alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.includes(4, 7)); // false let person = &#123; name: &quot;Nicholas&quot; &#125;; let people = [&#123; name: &quot;Nicholas&quot; &#125;]; let morePeople = [person]; alert(people.indexOf(person)); // -1 alert(morePeople.indexOf(person)); // 0 alert(people.includes(person)); // false alert(morePeople.includes(person)); // true \n\n断言函数\n断言函数接收 3 个参数：元素、索引和数组本身；\n\n元素是数组中当前଼索的元素；\n索引是当前元素的索引；\n数组就是正在଼索的数组\n\n\nfind()和 findIndex()方法使用了断言函数：\n\n这两个方法都从数组的最小索引开始；\nfind()返回第一个匹配的元素；\nfindIndex()返回第一个匹配元素的索引\n这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。\n\n\n\nconst people = [     &#123;         name: &quot;Matt&quot;,         age: 27     &#125;,     &#123;         name: &quot;Nicholas&quot;,         age: 29     &#125; ]; alert(people.find((element, index, array) =&gt; element.age &lt; 28)); // &#123;name: &quot;Matt&quot;, age: 27&#125; alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28)); // 0 \n\n迭代方法\n\nlet numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2); alert(everyResult); // false let someResult = numbers.some((item, index, array) =&gt; item &gt; 2); alert(someResult); // truelet filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2); alert(filterResult); // 3,4,5,4,3 let mapResult = numbers.map((item, index, array) =&gt; item * 2); alert(mapResult); // 2,4,6,8,10,8,6,4,2numbers.forEach((item, index, array) =&gt; &#123;  // 执行某些操作 &#125;); \n\n归并方法\n\nlet values = [1, 2, 3, 4, 5]; let sum1 = values.reduce((prev, cur, index, array) =&gt; prev + cur); alert(sum); // 15let sum2 = values.reduceRight(function(prev, cur, index, array)&#123;     return prev + cur; &#125;); alert(sum); // 15 ","categories":["前端学习笔记","JS","Array"],"tags":["JS学习"]},{"title":"453.最小操作次数使数组元素相等","url":"/2021/10/20/lc-453/","content":"题目给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。\n错误解题历程错误一思路\n根据题目要求找出数组中的最大值，遍历数组中每一个元素如果比最大值小那么就将该值加一，否则不变；\n当首次遇到与最大值相等的值的时候该值不变并标记，下次遇到时加一；\n遍历数组判断是否全部相等；\n\n结果当遇到的数组最大值较大或者数组长度较长时的时候循环次数较多导致代码运行超时。\n代码/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minMoves = function(nums) &#123;    let a =0;    let flag = true;    let maxN = 0;    while(flag)&#123;        maxN = Math.max(...nums);        let j=0;        for(let i=0;i&lt;nums.length;i++)&#123;            if(nums[i]==maxN)&#123;                j++;                continue;            &#125;else&#123;                a++;                break;            &#125;        &#125;        if(j==nums.length)&#123;            flag=false;            return a;        &#125;        let flag1 = 0;        nums.forEach((item,index)=&gt;&#123;            if(item&lt;maxN)&#123;                nums[index]++;            &#125;else&#123;                if(flag1==0)&#123;                    flag1=1;                &#125;else&#123;                    nums[index]++;                &#125;            &#125;        &#125;);    &#125;&#125;;\n\n解题思路反解，每次操作既可以理解为使 n-1个元素增加 1，也可以理解使 1 个元素减少 1。所以，思路如下：\n\n求出数组中的最小值；\n将数组中的每个值与最小值进行相减；\n将得到的结果累加的和就是最终结果。\n\n代码/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minMoves = function(nums) &#123;    let minN = 0;    minN = Math.min(...nums);    let result = 0;    nums.forEach((item)=&gt;&#123;        result += item-minN;    &#125;);    return result;&#125;;","categories":["JS","前端刷题"],"tags":["LeetCode刷题"]},{"title":"JavaScript学习笔记（十六）迭代器与生成器","url":"/2021/10/20/js-16/","content":"迭代与迭代器定义\n官方定义的迭代意思是：按照顺序反复多次执行一段程序,通常会有明确的终止条件。\n实际上计数循环就是最简单的迭代。\n循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。\n迭代会在一个有序集合上进行。(“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到,特别是开始和结束项有明确的定义。)数组是JavaScript 中有序集合的最典型例子。\n\n迭代器模式\n迭代器模式（特别是在 ECMAScript这个语境下)描述了一个方案，即可以把有些结构称为“可迭代对象”( iterable)，因为它们实现了正式的工terable接口，而且可以通过迭代器工terator消费。\n基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对\n\n可迭代协议\n可迭代协议指的是Iterable接口\n实现工terable接口(可迭代协议)要求同时具备两种能力:支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。\n实现可迭代协议的所有类型都会白动兼容接收可迭代对象的任何语言特性。\n接收可迭代对象的原牛语言特性句括：\nfor-of循环\n数组解构\n扩展操作符\nArray.from()\n创建集合\n创建映射\nPromise.all()\nPromise.race()\nyield*操作符，在生成器中使用\n\n\n\n迭代器协议\n迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。\n\n迭代器API使用next()方法在可迭代对象中遍历数据。\n\n每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。若不调用next ()，则无法知道迭代器的当前位置。\n\nnext()方法返回的迭代器对象IteratorResult包含两个属性: done和value：\n\ndone是一个布尔值，表示是否还可以再次调用next ()取得下一个值; \nvalue包含可迭代对象的下一个值(done为false)、或者undefined ( done为true )。\ndone: true状态称为“耗尽”。\n\n\n\n// 可迭代对象let arr = [&#x27;foo&#x27;, &#x27;bar&#x27;]; // 迭代器工厂函数console.log(arr[Symbol.iterator]); // f values() &#123; [native code] &#125; // 迭代器let iter = arr[Symbol.iterator](); console.log(iter); // ArrayIterator &#123;&#125; // 执行迭代console.log(iter.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(iter.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125;\n\n\n不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象；\n如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化；\n\nlet arr = [&#x27;foo&#x27;, &#x27;baz&#x27;]; let iter = arr[Symbol.iterator](); console.log(iter.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; // 在数组中间插入值arr.splice(1, 0, &#x27;bar&#x27;); console.log(iter.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(iter.next()); // &#123; done: false, value: &#x27;baz&#x27; &#125; console.log(iter.next()); // &#123; done: true, value: undefined &#125; \n\n自定义迭代器\n为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此可以把计数器变量放到闭包里，然后通过闭包返回迭代器:\n\nclass Counter &#123;     constructor(limit) &#123;         this.limit = limit;     &#125;     [Symbol.iterator]() &#123;         let count = 1,             limit = this.limit;         return &#123;             next() &#123;                 if (count &lt;= limit) &#123;                     return &#123; done: false, value: count++ &#125;;                 &#125; else &#123;                     return &#123; done: true, value: undefined &#125;;                 &#125;             &#125;         &#125;;     &#125; &#125; let counter = new Counter(3); for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3 for (let i of counter) &#123; console.log(i); &#125; // 1 // 2 // 3\n\n\n每个以这种方式创建的迭代器也实现了Iterable接口。Symbol.iterator属性引用的工厂函数会返回相同的迭代器；\n\n提前终止迭代器\nreturn()方法用于指定在迭代器提前关闭时执行的逻辑。\nreturn()方法必须返回一个有效的工teratorResult对象。\n\nclass Counter &#123;     constructor(limit) &#123;         this.limit = limit;     &#125;     [Symbol.iterator]() &#123;         let count = 1,             limit = this.limit;         return &#123;             next() &#123;                 if (count &lt;= limit) &#123;                     return &#123; done: false, value: count++ &#125;;                 &#125; else &#123;                     return &#123; done: true &#125;;                 &#125;             &#125;,             return() &#123;                 console.log(&#x27;Exiting early&#x27;);                 return &#123; done: true &#125;;             &#125;         &#125;;     &#125; &#125; let counter1 = new Counter(5); for (let i of counter1) &#123;     if (i &gt; 2) &#123;         break;     &#125;     console.log(i); &#125;// 1 // 2 // Exiting early let counter2 = new Counter(5); try &#123;     for (let i of counter2) &#123;         if (i &gt; 2) &#123;             throw &#x27;err&#x27;;         &#125;         console.log(i);     &#125; &#125; catch(e) &#123;&#125; // 1 // 2 // Exiting early let counter3 = new Counter(5); let [a, b] = counter3; // Exiting early \n\n\n如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。\n数组的迭代器就是不能关闭的。\n要知道某个迭代器是否可关闭,可以测试这个迭代器实例的return属性是不是函数对象。\n调用 return()不会强制迭代器进入关闭状态，但return()方法还是会被调用。\n\nlet a = [1, 2, 3, 4, 5]; let iter = a[Symbol.iterator](); iter.return = function() &#123;     console.log(&#x27;Exiting early&#x27;);     return &#123; done: true &#125;;&#125;; for (let i of iter) &#123;     console.log(i);     if (i &gt; 2) &#123;         break     &#125; &#125; // 1 // 2 // 3 // 提前退出for (let i of iter) &#123;     console.log(i); &#125; // 4 // 5\n\n生成器\n生成器是 ECMAScript 6新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。\n生成器的形式是一个函数，函数名称前面加一个星号(*)表示它是一个生成器。\n只要是可以定义丽数的地方,就可以定义生成器。\n箭头函数不能用来定义生成器函数。\n标识生成器函数的星号不受两侧空格的影响。\n\n// 生成器函数声明function* generatorFn() &#123;&#125; // 生成器函数表达式let generatorFn = function* () &#123;&#125; // 作为对象字面量方法的生成器函数let foo = &#123;     * generatorFn() &#123;&#125; &#125; // 作为类实例方法的生成器函数class Foo &#123;     * generatorFn() &#123;&#125; &#125; // 作为类静态方法的生成器函数class Bar &#123;     static * generatorFn() &#123;&#125; &#125; \n\n\n调用生成器函数会产生一个生成器对象。\n生成器对象一开始处于暂停执行( suspended )的状态。\n与迭代器相似，生成器对象也实现了Iterator 接口，因此具有next()方法。\n调用这个方法会让生成器开始或恢复执行。\n\nfunction* generatorFn() &#123;&#125; const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(g.next); // f next() &#123; [native code] &#125;\n\n\nnext ()方法的返回值类似于迭代器，有一个done属性和一个value属性。\n函数体为空的生成器函数中间不会停留,调用一次next()就会让生成器到达 done: true状态。\nvalue属性是生成器函数的返回值，默认值为undefined，可以通过生成器函数的返回值指定:\n\nfunction* generatorFn() &#123;     return &#x27;foo&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(generatorObject.next()); // &#123; done: true, value: &#x27;foo&#x27; &#125;\n\n\n生成器函数只会在初次调用next ()方法后开始执行。\n\nfunction* generatorFn() &#123;     console.log(&#x27;foobar&#x27;); &#125; // 初次调用生成器函数并不会打印日志let generatorObject = generatorFn(); generatorObject.next(); // foobar \n\n\n生成器对象实现了Iterable接口,它们默认的迭代器是自引用的。\n\nfunction* generatorFn() &#123;&#125; console.log(generatorFn); // f* generatorFn() &#123;&#125; console.log(generatorFn()[Symbol.iterator]);// f [Symbol.iterator]() &#123;native code&#125; console.log(generatorFn()); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(generatorFn()[Symbol.iterator]()); // generatorFn &#123;&lt;suspended&gt;&#125; const g = generatorFn(); console.log(g === g[Symbol.iterator]()); // true\n\n通过yield中断执行\nyield关键字可以让生成器停止和开始执行。\n生成器函数在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。\n停止执行的生成器函数只能通过在生成器对象上调用next ()方法来恢复执行。\nyield关键字生成的值会出现在next()方法返回的对象里\n通过yield关键字退出的生成器函数会处在done: false状态。\n通过return 关键字退出的生成器函数会处于done: true状态。\n\nfunction* generatorFn() &#123;     yield &#x27;foo&#x27;;     yield &#x27;bar&#x27;;     return &#x27;baz&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(generatorObject.next()); // &#123; done: false, value: &#x27;bar&#x27; &#125; console.log(generatorObject.next()); // &#123; done: true, value: &#x27;baz&#x27; &#125; \n\n\n生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用next ()不会影响其他生成器。\nyield关键字只能在生成器函数内部使用,用在其他地方会抛出错误。\nyield关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误。\n\n// 有效function* validGeneratorFn() &#123;     yield; &#125; // 无效function* invalidGeneratorFnA() &#123;     function a() &#123;         yield;     &#125; &#125; // 无效function* invalidGeneratorFnB() &#123;     const b = () =&gt; &#123;         yield;     &#125; &#125; // 无效function* invalidGeneratorFnC() &#123;     (() =&gt; &#123;         yield;     &#125;)(); &#125; \n\n1、生成器对象作为可迭代对象\n把生成器对象当成可迭代对象，那么使用起来会更方便。\n\nfunction* generatorFn() &#123;     yield 1;     yield 2;     yield 3; &#125; for (const x of generatorFn()) &#123;     console.log(x); &#125; // 1 // 2 // 3 \nfunction* nTimes(n) &#123;     while(n--) &#123;         yield;     &#125; &#125;for (let _ of nTimes(3)) &#123;     console.log(&#x27;foo&#x27;); &#125; // foo // foo // foo\n\n使用yield实现输入和输出\n除了可以作为函数的中间返回语句使用, yield关键字还可以作为函数的中间参数使用;\n第一次调用next ()传人的值不会被使用，因为这一次调用是为了开始执行生成器函数:\n\nfunction* generatorFn(initial) &#123;     // console.log(initial);     console.log(yield);     console.log(yield); &#125; let generatorObject = generatorFn(&#x27;foo&#x27;); generatorObject.next(&#x27;bar&#x27;); // 没有输出，开始执行生成器函数 generatorObject.next(&#x27;baz&#x27;); // baz generatorObject.next(&#x27;qux&#x27;); // qux \n\n\nyield关键字可以同时用于输入和输出：\n\nfunction* generatorFn() &#123;     return yield &#x27;foo&#x27;; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next()); // &#123; done: false, value: &#x27;foo&#x27; &#125; console.log(generatorObject.next(&#x27;bar&#x27;)); // &#123; done: true, value: &#x27;bar&#x27; &#125;\n\n因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到yield关键字时暂停执行并计算出要产生的值: “foo”。下一次调用next ()传入了”bar”，作为交给同一个yield 的值。然后这个值被确定为本次生成器函数要返回的值。\n\n\nyield 关键字并非只能使用一次，如下面的例子定义了一个无穷计数生成器函数：\n\nfunction* generatorFn() &#123;  for (let i = 0;;++i) &#123;  yield i;  &#125; &#125; let generatorObject = generatorFn(); console.log(generatorObject.next().value); // 0 console.log(generatorObject.next().value); // 1 console.log(generatorObject.next().value); // 2 console.log(generatorObject.next().value); // 3 console.log(generatorObject.next().value); // 4 console.log(generatorObject.next().value); // 5 ... \n\n\n使用生成器也可以实现范围和填充数组：\n\nfunction* range(start, end) &#123;     while(end &gt; start) &#123;         yield start++;     &#125; &#125; for (const x of range(4, 7)) &#123;     console.log(x); &#125; // 4 // 5 // 6 function* zeroes(n) &#123;     while(n--) &#123;         yield 0;     &#125; &#125; console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0]\n\n产生可迭代对象\nyield星号两侧的空格不影响其行为;\n使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：\n\nfunction* generatorFn() &#123;     yield* [1, 2, 3]; &#125; let generatorObject = generatorFn(); for (const x of generatorFn()) &#123;     console.log(x); &#125; // 1 // 2 // 3 \n\nyield*实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把yield放到一个循环里没什么不同。\nyield*的值是关联迭代器返回done: true 时的 value属性。对于普通迭代器来说，这个值是undefined。\n\nfunction* generatorFn() &#123;     console.log(&#x27;iter value:&#x27;, yield* [1, 2, 3]); &#125; for (const x of generatorFn()) &#123;     console.log(&#x27;value:&#x27;, x); &#125; // value: 1 // value: 2 // value: 3 // iter value: undefined\n\n\n对于生成器函数产生的迭代器来说,这个值就是生成器函数返回的值：\n\nfunction* innerGeneratorFn() &#123;     yield &#x27;foo&#x27;;     return &#x27;bar&#x27;; &#125; function* outerGeneratorFn(genObj) &#123;     console.log(&#x27;iter value:&#x27;, yield* innerGeneratorFn()); &#125; for (const x of outerGeneratorFn()) &#123;     console.log(&#x27;value:&#x27;, x); &#125; // value: foo // iter value: bar \n\n使用yield*实现递归算法function* nTimes(n) &#123;     if (n &gt; 0) &#123;         yield* nTimes(n - 1);         yield n - 1;     &#125; &#125; for (const x of nTimes(3)) &#123;     console.log(x); &#125; // 0 // 1 // 2\n\n生成器作为默认迭代器class Foo &#123;     constructor() &#123;         this.values = [1, 2, 3];     &#125;     * [Symbol.iterator]() &#123;         yield* this.values;     &#125; &#125; const f = new Foo(); for (const x of f) &#123;     console.log(x); &#125; // 1 // 2 // 3 \n\n提前终止生成器return()\nreturn()方法会强制生成器进人关闭状态。提供给return()方法的值,就是终止迭代器对象的值\n\nfunction* generatorFn() &#123;     for (const x of [1, 2, 3]) &#123;         yield x;     &#125; &#125;const g = generatorFn(); console.log(g); // generatorFn &#123;&lt;suspended&gt;&#125; console.log(g.return(4)); // &#123; done: true, value: 4 &#125; console.log(g); // generatorFn &#123;&lt;closed&gt;&#125;\n\n\n与迭代器不同，所有生成器对象都有return()方法，只要通过它进人关闭状态，就无法恢复了。\n后续调用next ()会显示done: true状态，而提供的任何返回值都不会被存储或传播:\n\nfunction* generatorFn() &#123;     for (const x of [1, 2, 3]) &#123;         yield x;     &#125; &#125;const g = generatorFn(); console.log(g.next()); // &#123; done: false, value: 1 &#125; console.log(g.return(4)); // &#123; done: true, value: 4 &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125; console.log(g.next()); // &#123; done: true, value: undefined &#125;\n\nthrow()\nthrow()方法会在暂停的时候将一个提供的错误注人到生成器对象中。如果错误未被处理，生成器就会关闭。\n假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。\n错误处理会跳过对应的yield。\n\nfunction* generatorFn() &#123;     for (const x of [1, 2, 3]) &#123;         try &#123;             yield x;         &#125; catch(e) &#123;&#125;     &#125; &#125;const g = generatorFn(); console.log(g.next()); // &#123; done: false, value: 1&#125; g.throw(&#x27;foo&#x27;); console.log(g.next()); // &#123; done: false, value: 3&#125;\n\n230\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十七）对象","url":"/2021/10/21/js-17/","content":"理解对象\n创建自定义对象的通常方式是创建object的一个新实例，然后再给它添加属性和方法。\n也可以使用对象字面量进行创建。\n\nlet person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29; person.job = &quot;Software Engineer&quot;; person.sayName = function() &#123;  console.log(this.name); &#125;;//===========等价于============let person = &#123;     name: &quot;Nicholas&quot;,     age: 29,     job: &quot;Software Engineer&quot;,     sayName() &#123;         console.log(this.name);     &#125; &#125;; \n\n属性类型\n属性分两种:数据属性和访回器属性。\n\n数据属性\n数据属性包含一个保存数据值的位置。\n值会从这个位置读取，也会写入到这个位置。\n数据属性有4个特性描述它们的行为。\n\n\n\n\n要修改属性的默认特性，就必须使用Object.defineProperty ()方法。\n这个方法接收3个参数:要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含: configurable、enumerable、writable和 value,跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。\n在调用Object.defineProperty()时, configurable,enumerable和writable的值如果不指定，则都默认为 false\n在严格模式下，尝试修改只读属性的值会抛出错误。\n\nlet person = &#123;&#125;; Object.defineProperty(person, &quot;name&quot;, &#123;     writable: false,     value: &quot;Nicholas&quot; &#125;); console.log(person.name); // &quot;Nicholas&quot; person.name = &quot;Greg&quot;; console.log(person.name); // &quot;Nicholas&quot; \n\n\n一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用object.defineProperty()并修改任何非 writable属性会导致错误。\n\nlet person = &#123;&#125;; Object.defineProperty(person, &quot;name&quot;, &#123;     configurable: false,     value: &quot;Nicholas&quot; &#125;); // 抛出错误Object.defineProperty(person, &quot;name&quot;, &#123;     configurable: true,     value: &quot;Nicholas&quot; &#125;); \n\n访问器属性\n访问器属性不包含数据值。\n访问器属性有4个特性描述它们的行为。\n访问器属性是不能直接定义的，必须使用Object.defineProperty ()。\n\n\n\n// 定义一个对象，包含伪私有成员 year_和公共成员 edition let book = &#123;     year_: 2017,     edition: 1 &#125;;Object.defineProperty(book, &quot;year&quot;, &#123;     get() &#123;         return this.year_;     &#125;,    set(newValue) &#123;         if (newValue &gt; 2017) &#123;             this.year_ = newValue;             this.edition += newValue - 2017;         &#125;    &#125;&#125;);book.year = 2018;console.log(book.edition); // 2\n\n在这个例子中，对象book 有两个默认属性: year_和 editiono。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性year被定义为一个访问器属性，其中获取函数简单地返回year_的值，而设置函数会做一些计算以决定正确的版本( edition )。因此，把year属性修改为2018会导致year_变成2018,edition变成2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。\n定义多个属性\nObject.defineProperties()方法可以通过多个描述符一次性定义多个属性。\n它接收两个参数:要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。\n\nlet book = &#123;&#125;; //数据属性的configurable、enumerable和writable特性值都是falseObject.defineProperties(book, &#123;     year_: &#123;         value: 2017     &#125;,     edition: &#123;         value: 1     &#125;,    //访问器属性    year: &#123;         get() &#123;             return this.year_;         &#125;,         set(newValue) &#123;             if (newValue &gt; 2017) &#123;                 this.year_ = newValue;                 this.edition += newValue - 2017;             &#125;         &#125;     &#125; &#125;);\n\n读取属性的特征\nObject.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。\n方法接收两个参数:属性所在的对象和要取得其描述符的属性名。\n返回值是一个对象，对于访问器属性包含configurable、enumerable、get和 set)属性，对于数据属性包含configurable、enumerable,writable和 value属性。\n\nlet book = &#123;&#125;; Object.defineProperties(book, &#123;     year_: &#123;         value: 2017     &#125;,     edition: &#123;         value: 1     &#125;,     year: &#123;         get: function() &#123;             return this.year_;         &#125;,         set: function(newValue)&#123;             if (newValue &gt; 2017) &#123;                 this.year_ = newValue;                 this.edition += newValue - 2017;             &#125;         &#125;     &#125; &#125;); let descriptor = Object.getOwnPropertyDescriptor(book, &quot;year_&quot;); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // &quot;undefined&quot; let descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // &quot;function&quot; \n\n\nObject.getOwnPropertyDescriptors ()静态方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。\n\nlet book = &#123;&#125;; Object.defineProperties(book, &#123;     year_: &#123;         value: 2017     &#125;,     edition: &#123;         value: 1     &#125;,     year: &#123;         get: function() &#123;             return this.year_;         &#125;,         set: function(newValue)&#123;             if (newValue &gt; 2017) &#123;                 this.year_ = newValue;                 this.edition += newValue - 2017;             &#125;         &#125;     &#125; &#125;); console.log(Object.getOwnPropertyDescriptors(book)); // &#123; // edition: &#123; //  configurable: false, //  enumerable: false, //  value: 1, //  writable: false // &#125;, // year: &#123; //  configurable: false, //  enumerable: false, //  get: f(), //  set: f(newValue), // &#125;, // year_: &#123; //  configurable: false, //  enumerable: false, //  value: 2017, //  writable: false // &#125; // &#125;\n\n合并对象\nECMAScript 6专门为合并对象提供了**Object.assign()**方法,这个方法接收一个目标对象和一个或多个源对象作为参数,然后将每个源对象中可枚举(Object.propertyIsEnumerable()返回true)和自有(Object.hasOwnProperty()返回true)属性复制到目标对象。\n以字符串和符号为键的属性会被复制。\n对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[ [Set]]设置属性的值。\n\nlet dest, src, result; /**  * 简单复制 */ dest = &#123;&#125;; src = &#123; id: &#x27;src&#x27; &#125;; result = Object.assign(dest, src); // Object.assign 修改目标对象// 也会返回修改后的目标对象console.log(dest === result); // true console.log(dest !== src); // true console.log(result); // &#123; id: src &#125; console.log(dest); // &#123; id: src &#125; /**  * 多个源对象 */ dest = &#123;&#125;; result = Object.assign(dest, &#123; a: &#x27;foo&#x27; &#125;, &#123; b: &#x27;bar&#x27; &#125;); console.log(result); // &#123; a: foo, b: bar &#125; /**  * 获取函数与设置函数 */ dest = &#123;     set a(val) &#123;         console.log(`Invoked dest setter with param $&#123;val&#125;`);     &#125; &#125;; src = &#123;     get a() &#123;         console.log(&#x27;Invoked src getter&#x27;);         return &#x27;foo&#x27;;     &#125; &#125;; Object.assign(dest, src); // 调用 src 的获取方法// 调用 dest 的设置方法并传入参数&quot;foo&quot; // 因为这里的设置函数不执行赋值操作// 所以实际上并没有把值转移过来console.log(dest); // &#123; set a(val) &#123;...&#125; &#125; \n\n\nObject.assign()实际上对每个源对象执行的是浅复制。\n如果多个源对象都有相同的属性，则使用最后一个复制的值。\n\nlet dest, src, result; /**  * 覆盖属性 */ dest = &#123; id: &#x27;dest&#x27; &#125;; result = Object.assign(dest, &#123; id: &#x27;src1&#x27;, a: &#x27;foo&#x27; &#125;, &#123; id: &#x27;src2&#x27;, b: &#x27;bar&#x27; &#125;); // Object.assign 会覆盖重复的属性console.log(result); // &#123; id: src2, a: foo, b: bar &#125; // 可以通过目标对象上的设置函数观察到覆盖的过程：dest = &#123;     set id(x) &#123;         console.log(x);     &#125; &#125;; Object.assign(dest, &#123; id: &#x27;first&#x27; &#125;, &#123; id: &#x27;second&#x27; &#125;, &#123; id: &#x27;third&#x27; &#125;); // first // second // third /**  * 对象引用 */ dest = &#123;&#125;; src = &#123; a: &#123;&#125; &#125;; Object.assign(dest, src); // 浅复制意味着只会复制对象的引用console.log(dest); // &#123; a :&#123;&#125; &#125; console.log(dest.a === src.a); // true\n\n\n如果赋值期间出错，则操作会中止并退出，同时抛出错误。\n\n","categories":["前端学习笔记","JS","对象"],"tags":["JS学习"]},{"title":"229.求众数Ⅱ","url":"/2021/10/22/lc-229/","content":"题目给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n解题思路思路一：哈希统计对数组进行遍历，使用map对所有的数值进行统计；然后再对map进行遍历找出符合题目要求的数值。时间复杂度O(n)，空间复杂度O(n)。\n代码/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var majorityElement = function(nums) &#123;    let count = new Map();    for(let i=0;i&lt;nums.length;i++)&#123;        if(count.has(nums[i]))&#123;            count.set(nums[i],count.get(nums[i])+1);        &#125;else&#123;            count.set(nums[i],1);        &#125;    &#125;    let result =[];    for(const x of count.keys())&#123;        if(count.get(x)&gt;parseFloat(nums.length/3))&#123;            result.push(x);        &#125;    &#125;    return result;&#125;;\n\n思路二：摩尔投票法&emsp;&emsp;摩尔投票法：简单来说，该方法是为了解决如何在人一多的候选人中，选出票数超过一半的那个人，我们可以直接利用反证法证明这样的数字只可能有一个。时间复杂度O(n)，空间复杂度O(1)。算法分为两个阶段：抵消阶段和计数阶段&emsp;&emsp;举个例子：假设投票结果如下：[a,c,c,a,a,b,a]，a,b,c为三个候选人。摩尔投票法的思路如下:&emsp;&emsp;首先选择第一张票a作为候选人，同时设置计数值vote=1，接着第一张票与第二张票进行比较，如果相同vote加一，不相同a_vote减一；&emsp;&emsp;接着与第三张票进行比较，结果不相同，但此时a_vote为0，故需要更换待定人为对应票面候选人c，并且将vote=1；接着与第四张票进行比较，结果不同vote减一；&emsp;&emsp;接着继续比较第五张票，结果不相同进行更换为a，vote=1；&emsp;&emsp;与第六张票进行比较，不同vote减一；&emsp;&emsp;与第七张票进行比较相同加一；&emsp;&emsp;得到最终结果为：候选人a，vote=1；&emsp;&emsp;如果得到的结果vote为0，那他已经无缘票数能超过一半的那个人了，直接返回结果；&emsp;&emsp;如果最后得到的抵消票数不为 0 的话，那说明他可能希望的，这是我们需要一个阶段来验证这个候选人的票数是否超过一半——计数阶段；=====================================================&emsp;&emsp;回到本题，我们可以利用升级版的摩尔投票法来达到目的，我们可以利用反证法推断出满足这样条件的元素最多只有两个，同样我们做以下假设：假设投票结果如下[a,b,c,a,a,b,c]，abc是三个候选人。&emsp;&emsp;此时我们选择两个候选人分别定义为：x,y;对应的抵消票为x_vote,y_vote;&emsp;&emsp;现在开始抵消：首先将第一张票x=a，x_vote=1，第二张票将y=b，y_vote=1;&emsp;&emsp;第三张票，x，y与之都不相同各自vote都减一，此时：x=a，x_vote=0；y=b，y_vote=0；&emsp;&emsp;第四张票，x与之相同，但此时x_vote和y_vote均为0，则先对x重新进行赋值，此时：x=a，x_vote=1；y=b，y_vote=0；&emsp;&emsp;第五张票，x与之相同，则x_vote加一，此时：x=a，x_vote=2；y=b，y_vote=0；&emsp;&emsp;第六张票，y与之相同，此时y=b，但y_vote=0，所以此时对y重新进行赋值，此时：x=a，x_vote=2；y=b，y_vote=1；&emsp;&emsp;第七张票，x，y与之都不相同各自vote都减一，此时：x=a，x_vote=1；y=b，y_vote=0；至此抵消阶段结束。&emsp;&emsp;接下来进行计数。由于y_vote=0，则y所对应的b候选人已经失去资格，故此时对a进行计数统计，然后判断a候选人的票数是否大于总数的三分之一。\n代码/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var majorityElement = function(nums) &#123;    let a_vote=0;    let b_vote=0;    let a=0;    let b=0;    for(let i=0;i&lt;nums.length;i++)&#123;        if(a==nums[i]&amp;&amp;acount&gt;0)&#123;            a_vote++;        &#125;else if(b==nums[i]&amp;&amp;bcount&gt;0)&#123;            b_vote++;        &#125;else if(acount==0)&#123;            a = nums[i];            a_vote++;        &#125;else if(bcount==0)&#123;            b = nums[i];            b_vote++;        &#125;else&#123;            a_vote--;            b_vote--;        &#125;    &#125;    let total_a=0;    let total_b=0;    let result=[];    for(let i=0;i&lt;nums.length;i++)&#123;        if(a_vote&gt;0&amp;&amp;a==nums[i])&#123;            total_a++;        &#125;else if(b_vote&gt;0&amp;&amp;b==nums[i])&#123;            total_b++;        &#125;    &#125;    if(a_vote&gt;0&amp;&amp;total_a&gt;parseFloat(nums.length/3))&#123;        result.push(a);    &#125;    if(b_vote&gt;0&amp;&amp;total_b&gt;parseFloat(nums.length/3))&#123;        result.push(b);    &#125;    return result;&#125;;\n","categories":["JS","前端刷题"],"tags":["LeetCode刷题"]},{"title":"算法学习笔记（一）——动态规划","url":"/2021/10/26/algo-1/","content":"基础知识\n动态规划问题的一般形式就是求最值。\n求解动态规划的核心问题是穷举。\n动态规划问题一定会具备最优子结构。\n只有找到并列出正确的状态转移方程才能正确的穷举。\n要符合最优子结构就需要子问题间必须相互独立。\n\n斐波那契数列常见方式为递归，代码如下：\nfunction fib(n)&#123;    if(n==1||n==2) return 1;    return fib(n-1)+fib(n-2);&#125;\n\n\n递归算法的时间复杂度等于子问题个数乘以解决一个子问题需要的时间。\n其中：子问题个数就是递归树中节点的总数，二叉节点总数为制数级别，故为O(2^n)。\n时间复杂度为制数级别十分费时。\n\n\n\n重叠子问题观察下面的递归树：可以发现存在大量的重复计算\n\n\n\n构建备忘录解决重叠子问题步骤：  1、 构造备忘录（数组/字典）；  2、 计算出子问题的答案先将其存储在备忘录中，再返回；  3、 每次遇到一个子问题先去备忘录中查询，如果已存在答案直接使用。\n\nfunction fib(n)&#123;    if(n&lt;1) return 0;    let memo = new Array(n+1).fill(0);    return helper(memo,n);&#125;function helper(memo,n)&#123;    if(n==1||n==2) return 1;    if(memo[n]!=0) return memo[n];    memo[n] = helper(memo,n-1)+helper(memo,n-2);    return memo[n];&#125;\n\n以下为具体过程：\n\n\n这种方法可以理解为自顶向下解法，而动态规划为自底向上解决问题。\n自底向上的dp数组迭代解法先看代码：\nfunction fib(n)&#123;    let dp = new Array(n+1).fill(0);    dp[1]=dp[2]=1;    for(let i=3;i&lt;=n;i++)&#123;        dp[i]=dp[i-1]+dp[i-2];    &#125;    return dp[n];&#125;\n\n代码更为简单，实际上就是在dp数组上进行操作，给定你需要求解的数值，直接计算到对应位置即可。\n状态转移方程状态转移方程实际上就是描述问题结构的数学形式，对于这个问题状态转移方程如下：\n\n\n寻找状态转移方程是非常关键的一步。\n列出状态转移方程步骤1、 确定状态；即原问题和子问题中的变化变量。2、 确定dp函数的定义。3、 确定选择并择优；即对于每个状态，可以做出什么选择改变当前状态。4、 最后明确base case。\n代码优化通过观察状态转移方程我们可以发现当前状态的数值只与当前状态的前两个状态有关，所以我们可以将空间复杂度进一步降低。代码如下：\nfunction fib(n)&#123;    if(n==1||n==2)&#123;        return 1;    &#125;    let prev=1,curr=1;    for(let i=3;i&lt;=n;i++)&#123;        let sum = prev+curr;        prev = curr;        curr = sum;    &#125;    return curr;&#125;\n\n时间复杂度O(n),空间复杂度O(1)。\n\n","categories":["算法学习笔记","动态规划"],"tags":["算法学习"]},{"title":"496.下一个更大元素 I","url":"/2021/10/26/lc-496/","content":"题目给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n解题思路1、暴力破解优先处理nums2中的数值，找出每个数值对应题目要求的数，然后使用map进行存储：nums2的值为key，下一个比它大的值为value。然后遍历nums1，对应map中的值输出结果。\n代码/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var nextGreaterElement = function(nums1, nums2) &#123;    let dic = new Map();    for(let i=0;i&lt;nums2.length;i++)&#123;        for(let j=i+1;j&lt;nums2.length;j++)&#123;            if(nums2[j]&gt;nums2[i])&#123;                dic[nums2[i]] = nums2[j];                break;            &#125;            if(j==nums2.length-1)&#123;                dic[nums2[i]] = -1;            &#125;        &#125;        if(i==nums2.length-1)&#123;            dic[nums2[i]] = -1;        &#125;    &#125;    let result = [];    for(const i of nums1)&#123;        result.push(dic[i])    &#125;    return result;&#125;;\n\n2、单调栈+哈希表利用单调栈+哈希表来快速确定每个元素右边第一个比它大的元素。\n这个思路其实和第一种思路一样：先确定nums2中每个元素右边第一个比啊它大的元素，然后再通过哈希表进行筛选输出。这里时间节省在使用了单调栈。\n具体使用方法如下：我们需要反向遍历nums2，这也符合栈的特点。接着我们需要判断当前值是否比现存栈顶元素大，如果大，则将栈顶元素出栈；反之，则不进行操作。循环以上操作，如果栈为空，也跳过该操作。最后将当前元素入栈。同时需要使用哈希表记录对应关系。\n操作演示：\n\n\n代码/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var nextGreaterElement = function(nums1, nums2) &#123;    let hmap = new Map();    let stack = [];    for(let i=nums2.length-1;i&gt;=0;i--)&#123;        let num = nums2[i];        while(stack.length &amp;&amp; num&gt;stack[stack.length-1])&#123;            stack.pop();        &#125;        hmap.set(num,stack.length ? stack[stack.length-1] : -1);        stack.push(num);    &#125;    let result = new Array(nums1.length).fill(0).map((_,i)=&gt; hmap.get(nums1[i]));    return result;&#125;;\n\n","categories":["JS","前端刷题","单调栈","哈希表"],"tags":["LeetCode刷题"]},{"title":"JavaScript学习笔记（十九）代理捕获器与反射方法","url":"/2021/10/27/js-19/","content":"get()\nget()捕获器会在获取属性值的操作中被调用。\n对应的反射API方法为Reflect.get()。\n\n275\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（十八）代理基础","url":"/2021/10/26/js-18/","content":"\n代理类似C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象；\n目标对象既可以直接被操作,也可以通过代理来操作。\n默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。\n在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象\n直接操作会绕过代理施予的行为。\n\n空代理\n除了作为一个抽象的目标对象，什么也不做\n代理是使用Proxy构造函数创建的，构造函数接收两个参数:目标对象和处理程序对象。\n缺少其中任何一个参数都会抛出TypeError；\n创建空代理，可以传一个简单的对象字面量作为处理程序对象。\n\n\n\nconst target = &#123;  id: &#x27;target&#x27; &#125;; const handler = &#123;&#125;; const proxy = new Proxy(target, handler); // id 属性会访问同一个值console.log(target.id); // target console.log(proxy.id); // target // 给目标属性赋值会反映在两个对象上// 因为两个对象访问的是同一个值target.id = &#x27;foo&#x27;; console.log(target.id); // foo console.log(proxy.id); // foo // 给代理属性赋值会反映在两个对象上// 因为这个赋值会转移到目标对象proxy.id = &#x27;bar&#x27;; console.log(target.id); // bar console.log(proxy.id); // bar // hasOwnProperty()方法在两个地方// 都会应用到目标对象console.log(target.hasOwnProperty(&#x27;id&#x27;)); // true console.log(proxy.hasOwnProperty(&#x27;id&#x27;)); // true // Proxy.prototype 是 undefined // 因此不能使用 instanceof 操作符console.log(target instanceof Proxy); // TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check// 严格相等可以用来区分代理和目标console.log(target === proxy); // false \n\n定义捕获器\n捕获器就是在处理程序对象中定义的“基本操作的拦截器”。\n每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。\n每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数,从而拦截并修改相应的行为。\n只有在代理对象上执行操作才会触发捕获器。\n\nconst target = &#123;     foo: &#x27;bar&#x27; &#125;; const handler = &#123;     // 捕获器在处理程序对象中以方法名为键    get() &#123;         return &#x27;handler override&#x27;;     &#125; &#125;; const proxy = new Proxy(target, handler); //proxy[property] 、proxy.property或Object.create(proxy)[property]等操作都会触发基本的get()操作以获取属性。console.log(target.foo); // bar console.log(proxy.foo); // handler override console.log(target[&#x27;foo&#x27;]); // bar console.log(proxy[&#x27;foo&#x27;]); // handler override console.log(Object.create(target)[&#x27;foo&#x27;]); // bar console.log(Object.create(proxy)[&#x27;foo&#x27;]); // handler override\n\n捕获器参数和反射API\n所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。\n\nconst target = &#123;     foo: &#x27;bar&#x27; &#125;;const handler = &#123;    get(trapTarget, property, receiver) &#123;         console.log(trapTarget === target);         console.log(property);         console.log(receiver === proxy);     &#125; &#125;; const proxy = new Proxy(target, handler); proxy.foo; // true // foo // true\n\n\n所有捕获器都可以基于自己的参数重建原始操作。\n通过调用全局Reflect对象上(封装了原始行为）的同名方法来轻松重建原始操作。\n\nconst target = &#123;     foo: &#x27;bar&#x27; &#125;; const handler = &#123;     get() &#123;         return Reflect.get(...arguments);     &#125; &#125;; const proxy = new Proxy(target, handler); console.log(proxy.foo); // bar console.log(target.foo); // bar \n\n\n事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射API的突代理那么甚至不需要定义处理程序对象:\n\nconst target = &#123;     foo: &#x27;bar&#x27; &#125;; const proxy = new Proxy(target, Reflect); console.log(proxy.foo); // bar console.log(target.foo); // bar \n\n捕获器不变式\n每个捕获的方法都知道目标对象上下文、捕获函数签名。\n捕获处理程序的行为必须遵循“捕获器不变式”。\n捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为\n如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError:\n\nconst target = &#123;&#125;; Object.defineProperty(target, &#x27;foo&#x27;, &#123;     configurable: false,     writable: false,     value: &#x27;bar&#x27; &#125;); const handler = &#123;     get() &#123;         return &#x27;qux&#x27;;     &#125; &#125;; const proxy = new Proxy(target, handler); console.log(proxy.foo); // TypeError \n\n可撤销代理\n使用new Proxy()创建的普通代理，这种联系会在代理对象的生命周期内一直持续存在。\nProxy的revocable()方法，这个方法支持撇销代理对象与目标对象的关联。\n撤销代理的操作是不可逆的；\n撤销函数(revoke())是幂等的，调用多少次的结果都一样；\n撤销代理之后再调用代理会抛出TypeError。\n撤销函数和代理对象是在实例化时同时生成的。\n\n\n\nconst target = &#123;     foo: &#x27;bar&#x27; &#125;; const handler = &#123;     get() &#123;         return &#x27;intercepted&#x27;;     &#125;&#125;; const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler); console.log(proxy.foo); // intercepted console.log(target.foo); // bar//撤销代理revoke(); console.log(proxy.foo); // TypeError\n\n实用反射API反射API与对象API\n反射API并不限于捕获处理程序。\n大多数反射API方法在Object类型上有对应的方法。\nObject上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。\n\n状态标记\n状态标记是指：反射方法返回的布尔值；表示意图执行的操作是否成功。\n\n以下反射方法会提供状态标记：\n\nReflect.defineProperty ()\nReflect.preventExtensions ()\nReflect.setPrototypeof ()\nReflect.set ()\nReflect.deleteProperty ()\n\n// 初始代码 const o = &#123;&#125;; try &#123;     Object.defineProperty(o, &#x27;foo&#x27;, &#x27;bar&#x27;);     console.log(&#x27;success&#x27;); &#125; catch(e) &#123;     console.log(&#x27;failure&#x27;); &#125;// 重构后的代码const o = &#123;&#125;; if(Reflect.defineProperty(o, &#x27;foo&#x27;, &#123;value: &#x27;bar&#x27;&#125;)) &#123;     console.log(&#x27;success&#x27;); &#125; else &#123;     console.log(&#x27;failure&#x27;); &#125; \n\n用一等函数代替操作符\n\n安全地应用函数\n通过apply方法调用函数时,被调用的函数可能也定义了自己的apply属性，为绕过这个问题我们可以采取以下两种方法来避免：\nFunction.prototype.apply.call(myFunc, thisVal, argumentList);\nReflect.apply(myFunc, thisVal, argumentsList); \n\n\n\n代理另一个代理const target = &#123;     foo: &#x27;bar&#x27; &#125;; const firstProxy = new Proxy(target, &#123;     get() &#123;         console.log(&#x27;first proxy&#x27;);         return Reflect.get(...arguments);     &#125; &#125;); const secondProxy = new Proxy(firstProxy, &#123;     get() &#123;         console.log(&#x27;second proxy&#x27;);         return Reflect.get(...arguments);     &#125; &#125;); console.log(secondProxy.foo); // second proxy // first proxy // bar\n\n代理存在的问题与不足\n代理中的this；\n代理与内部槽位；\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十）箭头函数","url":"/2021/10/27/js-20/","content":"\n很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。\n箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n\nlet arrowSum = (a, b) =&gt; &#123;     return a + b; &#125;; let functionExpressionSum = function(a, b) &#123;     return a + b; &#125;; console.log(arrowSum(5, 8)); // 13 console.log(functionExpressionSum(5, 8)); // 13\n\n\n箭头函数简洁的语法非常适合嵌入函数的场景：\n\nlet ints = [1, 2, 3]; console.log(ints.map(function(i) &#123; return i + 1; &#125;)); // [2, 3, 4] console.log(ints.map((i) =&gt; &#123; return i + 1 &#125;)); // [2, 3, 4] \n\n\n如果只有一个参数，可以不用括号。\n只有没有参数，或者多个参数的情况下，才需要使用括号。\n\n// 以下两种写法都有效let double = (x) =&gt; &#123; return 2 * x; &#125;; let triple = x =&gt; &#123; return 3 * x; &#125;; // 没有参数需要括号let getRandom = () =&gt; &#123; return Math.random(); &#125;; // 多个参数需要括号let sum = (a, b) =&gt; &#123; return a + b; &#125;; // 无效的写法：let multiply = a, b =&gt; &#123; return a * b; &#125;; \n\n\n箭头函数也叫以不用大括号，但这样会改变函数的行为。\n使用大括号就说明包含“ 函数体”，可以在一个函数中包含多条语句，跟常规的函数一样；\n如果不使用大括号，那么箭头后面就只能有一行代码\n\n// 以下两种写法都有效，而且返回相应的值let double = (x) =&gt; &#123; return 2 * x; &#125;; let triple = (x) =&gt; 3 * x; // 可以赋值let value = &#123;&#125;; let setName = (x) =&gt; x.name = &quot;Matt&quot;; setName(value); console.log(value.name); // &quot;Matt&quot; // 无效的写法：let multiply = (a, b) =&gt; return a * b; \n\n\n箭头函数不能使用arguments、super和new.target，也不能用作构造函数，箭头函数没有prototype属性。\n\n","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十二）函数（二）","url":"/2021/10/29/js-22/","content":"函数声明与函数表达式\nJavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。\n函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。\n函数声明提升：函数声明会在任何代码执行之前先被读取并添加到执行上下文。\n在执行代码时，JavaScript引擎会先执行一遍扫描,把发现的函数声明提升到源代码树的顶部。\n如果把代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错\n\n// 没问题 console.log(sum(10, 10)); function sum(num1, num2) &#123;     return num1 + num2; &#125; // 会出错console.log(sum(10, 10)); let sum = function(num1, num2) &#123;     return num1 + num2; &#125;;\n\n\n以上代码出错的原因在于并没有执行到let定义函数那一行，并不是因为使用let造成的。\n\n函数作为值\n函数名在ECMAScript中就是变量。这意味着不仅可以把函数作为参数传给另一个函数,而且还可以在一个函数中返回另一个函数。\n\n\nfunction callSomeFunction(someFunction, someArgument) &#123;     return someFunction(someArgument); &#125; function add10(num) &#123;     return num + 10; &#125; let result1 = callSomeFunction(add10, 10); console.log(result1); // 20 function getGreeting(name) &#123;     return &quot;Hello, &quot; + name; &#125; let result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;); console.log(result2); // &quot;Hello, Nicholas&quot; \n\n函数内部\n函数内部存在两个特殊的对象:arguments和this；一个属性new.target属性。\n\n1、arguments\narguments是一个类数组对象，包含调用函数时传入的所有参数。\n只有以 function关键字定义函数（相对于使用箭头语法创建函数)时才会有。\narguments对象其实还有一个callee属性,是一个指向arguments对象所在函数的指针。\n使用arguments.callee可以让函数逻辑与函数名解耦\n\nfunction factorial(num) &#123;     if (num &lt;= 1) &#123;         return 1;     &#125; else &#123;         return num * factorial(num - 1);     &#125; &#125;function factorial(num) &#123;     if (num &lt;= 1) &#123;         return 1;     &#125; else &#123;         return num * arguments.callee(num - 1);     &#125; &#125; \n\n2、this\n在标准函数中，this引用的是把函数当成方法调用的上下文对象。\n\nwindow.color = &#x27;red&#x27;; let o = &#123;     color: &#x27;blue&#x27; &#125;; function sayColor() &#123;     console.log(this.color); &#125; sayColor(); // &#x27;red&#x27; o.sayColor = sayColor; o.sayColor(); // &#x27;blue&#x27; \n\n\n在箭头函数中，this引用的是定义箭头函数的上下文。\n\nwindow.color = &#x27;red&#x27;; let o = &#123;     color: &#x27;blue&#x27; &#125;; let sayColor = () =&gt; console.log(this.color); sayColor(); // &#x27;red&#x27; o.sayColor = sayColor; o.sayColor(); // &#x27;red&#x27; \n\n\n箭头函数中的this会保留定义该函数时的上下文\n\n3、caller\n这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。\n\nfunction outer() &#123;     inner(); &#125; function inner() &#123;     console.log(inner.caller); &#125; outer();//显示 outer()函数的源代码\n\n\n同样可以通过arguments.callee.caller来降低耦合度。\n\nfunction outer() &#123;     inner(); &#125; function inner() &#123;     console.log(arguments.callee.caller); &#125; outer();//显示 outer()函数的源代码\n\n\nECMAScript5也定义了arguments.caller,但在严格模式下访问它会报错，在非严格模式下则始终是undefined。\n这是为了分清arguments.caller和函数的caller而故意为之的。\n严格模式下还有一个限制，就是不能给函数的caller属性赋值，否则会导致错误。\n\n\n\nnew.target\n如果函数是正常调用的则new.target的值是undefined;\n如果是使用new关键字调用的，则new.target将引用被调用的构造函数。\n\nfunction King() &#123;     if (!new.target) &#123;         throw &#x27;King must be instantiated using &quot;new&quot;&#x27;     &#125;     console.log(&#x27;King instantiated using &quot;new&quot;&#x27;); &#125; new King(); // King instantiated using &quot;new&quot; King(); // Error: King must be instantiated using &quot;new&quot; ","categories":["前端学习笔记","JS","函数"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十三）函数（三）","url":"/2021/10/29/js-23/","content":"函数属性与方法\n每个函数都有两个属性：length和prototype。\nlength 属性保存函数定义的命名参数的个数。\n\nfunction sayName(name) &#123;     console.log(name); &#125; function sum(num1, num2) &#123;     return num1 + num2; &#125; function sayHi() &#123;     console.log(&quot;hi&quot;); &#125; console.log(sayName.length); // 1 console.log(sum.length); // 2 console.log(sayHi.length); // 0 \n\n\nprototype是保存引用类型所有实例方法的地方，这意味着toString()、valueOf ()等方法实际上都保存在prototype. 上，进而由所有实例共享。\nprototype属性是不可枚举的。\n函数还有两个方法: apply()和call()，这两个方法都会以指定的this值来调用函数。\napply()方法接收两个参数:函数内this的值和一个参数数组第二个参数可以是Array的实例，但也可以是arguments对象。\n\n\n\nfunction sum(num1, num2) &#123;     return num1 + num2; &#125; function callSum1(num1, num2) &#123;     return sum.apply(this, arguments); // 传入 arguments 对象&#125; function callSum2(num1, num2) &#123;     return sum.apply(this, [num1, num2]); // 传入数组&#125; console.log(callSum1(10, 10)); // 20 console.log(callSum2(10, 10)); // 20 \n\n\ncall()方法与apply()的作用一样，call()向函数传参时，必须将参数一个一个地列出来。\n\nfunction sum(num1, num2) &#123;     return num1 + num2; &#125; function callSum(num1, num2) &#123;     return sum.call(this, num1, num2); &#125; console.log(callSum(10, 10)); // 20\n\n\n使用call ()或apply()的好处是可以将任意对象设置为任意函数的作用域。\n\nwindow.color = &#x27;red&#x27;; let o = &#123;     color: &#x27;blue&#x27; &#125;; function sayColor() &#123;     console.log(this.color); &#125; sayColor(); // red sayColor.call(this); // red sayColor.call(window); // red sayColor.call(o); // blue \n\n\n继承的方法toLocalestring()和tostring()始终返回函数的代码。\nvalueOf()返回函数本身。\n\n函数表达式\n函数声明的关键特点是函数声明提升。\n定义函数有两种方式：函数声明和函数表达式\n\nfunction functionName(arg0, arg1, arg2) &#123;  // 函数体 &#125; let functionName = function(arg0, arg1, arg2) &#123;  // 函数体 &#125;;\n\n\n函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量functionName这样创建的函数叫作匿名函数。\n未赋值给其他变量的匿名函数的name属性是空字符串。\n只要函数被当作值来使用，它就是一个函数表达式。\n\n","categories":["前端学习笔记","JS","函数"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十五）函数（五）闭包","url":"/2021/11/04/js-25/","content":"\n闭包指的是那些引用了另一个函数作用域中变量的函数。\n在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对像。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。\n\nthis对象\n如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文。\n在全局函数中调用，则this在非严格模式下等于window，严格模式下等于underfined。\n函数在被调用时都会自动创建两个特殊变量: this 和arguments。内部函数永远不可能直接访问外部函数的这两个变量。\n\nwindow.identity = &#x27;The Window&#x27;; let object = &#123;     identity: &#x27;My Object&#x27;,     getIdentityFunc() &#123;         return function() &#123;             return this.identity;         &#125;;     &#125; &#125;; console.log(object.getIdentityFunc()()); // &#x27;The Window&#x27;//=============================window.identity = &#x27;The Window&#x27;; let object = &#123;     identity: &#x27;My Object&#x27;,     getIdentityFunc() &#123;         let that = this;         return function() &#123;             return that.identity;         &#125;;     &#125; &#125;; console.log(object.getIdentityFunc()()); // &#x27;My Object&#x27; \n\nwindow.identity = &#x27;The Window&#x27;; let object = &#123;     identity: &#x27;My Object&#x27;,     getIdentity () &#123;         return this.identity;     &#125; &#125;;object.getIdentity(); // &#x27;My Object&#x27; (object.getIdentity)(); // &#x27;My Object&#x27; (object.getIdentity = object.getIdentity)(); // &#x27;The Window&#x27;\n\n第一行调用object.getIdentity()是正常调用，会返回”My object”, 因为this.identity就是object.identity。\n第二行在调用时把object.getIdentity放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但this值并没有变。这是因为按照规范，object.getIdentity和(object.get Identity)是相等的。\n第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身。this值不再与任何对象绑定，所以返回的是”The Window”。\n\n","categories":["前端学习笔记","JS","函数","闭包"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十四）函数（四）尾调用优化","url":"/2021/11/04/js-24/","content":"\n外部函数的返回值是一个内部函数的返回值。\n\n尾调用优化的条件\n尾调用优化的条件就是确定外部栈帧真的没有必要存在了。\n代码在严格模式下执行；\n外部函数的返回值是对尾调用函数的调用；\n尾调用函数返回后不需要执行额外的逻辑；\n尾调用函数不是引用外部函数作用域中自由变量的闭包\n\n\n\n下面展示了几个违反上述条件的函数，因此都不符合尾调用优化的要求：\n&quot;use strict&quot;; // 无优化：尾调用没有返回 function outerFunction() &#123;     innerFunction(); &#125; // 无优化：尾调用没有直接返回function outerFunction() &#123;     let innerFunctionResult = innerFunction();     return innerFunctionResult; &#125; // 无优化：尾调用返回后必须转型为字符串function outerFunction() &#123;     return innerFunction().toString(); &#125; // 无优化：尾调用是一个闭包function outerFunction() &#123;     let foo = &#x27;bar&#x27;;     function innerFunction() &#123; return foo; &#125;     return innerFunction(); &#125; \n\n下面是几个符合尾调用优化条件的例子:\n&quot;use strict&quot;; // 有优化：栈帧销毁前执行参数计算function outerFunction(a, b) &#123;     return innerFunction(a + b); &#125; // 有优化：初始返回值不涉及栈帧function outerFunction(a, b) &#123;     if (a &lt; b) &#123;         return a;     &#125;     return innerFunction(a + b); &#125; // 有优化：两个内部函数都在尾部function outerFunction(condition) &#123;     return condition ? innerFunctionA() : innerFunctionB(); &#125; ","categories":["前端学习笔记","JS","ES6","函数","尾调用优化"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十六）函数（六）","url":"/2021/11/04/js-26/","content":"立即调用的函数表达式\n立即调用的匿名函数又被称作立即调用的函数表达式。\n\n(function() &#123;  // 块级作用域 &#125;)(); //======================(function () &#123;  for (var i = 0; i &lt; count; i++) &#123;  console.log(i);  &#125; &#125;)(); console.log(i);\n\n私有变量\n严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。\n任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。\n私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。\n特权方法( privileged method )是能够访问函数私有变量(及私有函数)的公有方法。\n在对象上有两种方式创建特权方法。第一种是在构造函数中实现。\n\nfunction MyObject() &#123;     // 私有变量和私有函数     let privateVariable = 10;     function privateFunction() &#123;         return false;     &#125;     // 特权方法    this.publicMethod = function() &#123;         privateVariable++;         return privateFunction();     &#125;; &#125; \n\n静态私有变量\n特权方法也可以通过使用私有作用域定义私有变量和函数来实现。\n\n(function() &#123;  // 私有变量和私有函数    let privateVariable = 10;     function privateFunction() &#123;         return false;     &#125;     // 构造函数    MyObject = function() &#123;&#125;;     // 公有和特权方法    MyObject.prototype.publicMethod = function() &#123;         privateVariable++;         return privateFunction();     &#125;; &#125;)(); \n\n在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是有变量和私有函数，然后又定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。注意，这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会:创建内部函数，在这里并不是必需的。基于同样的原因(但操作相反),这里声明Myobject并没有使用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以Myobject变成了全局变量，用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以Myobject变成了全局变量。\n\n这个模式与前一个模式的主要区别就是：私有变量和私有函数是由实例共享的。\n因为特权方法定义在原型上，所以同样是由实例共享的。\n特权方法作为一个闭包，始终引用着包含它的作用域。\n\n(function() &#123;     let name = &#x27;&#x27;;     Person = function(value) &#123;         name = value;     &#125;;     Person.prototype.getName = function() &#123;         return name;     &#125;;     Person.prototype.setName = function(value) &#123;         name = value;     &#125;; &#125;)(); let person1 = new Person(&#x27;Nicholas&#x27;); console.log(person1.getName()); // &#x27;Nicholas&#x27; person1.setName(&#x27;Matt&#x27;); console.log(person1.getName()); // &#x27;Matt&#x27; let person2 = new Person(&#x27;Michael&#x27;); console.log(person1.getName()); // &#x27;Michael&#x27; console.log(person2.getName()); // &#x27;Michael&#x27;\n\n\n注意使用闭包和私有变量会 导致作用城链变长，作用域链越长，则查找变量所需的时间也越多。\n\n模块模式\n模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。\n模块模式的样板代码如下：\n\nlet singleton = function() &#123;     // 私有变量和私有函数    let privateVariable = 10;     function privateFunction() &#123;         return false;     &#125;     // 特权/公有方法和属性    return &#123;         publicProperty: true,         publicMethod() &#123;             privateVariable++;             return privateFunction();         &#125;     &#125;; &#125;(); \n\n&emsp;&emsp;;模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。&emsp;&emsp;如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式\nlet application = function() &#123;  // 私有变量和私有函数     let components = new Array();     // 初始化    components.push(new BaseComponent());     // 公共接口    return &#123;         getComponentCount() &#123;             return components.length;         &#125;,         registerComponent(component) &#123;             if (typeof component == &#x27;object&#x27;) &#123;                 components.push(component);             &#125;         &#125;    &#125;; &#125;(); \n\n模块增强模式\n另一个利用模块模式的做法是在返回对象之前先对其进行增强。\n这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。\n\nlet singleton = function() &#123;  // 私有变量和私有函数    let privateVariable = 10;     function privateFunction() &#123;         return false;     &#125;     // 创建对象    let object = new CustomType();     // 添加特权/公有属性和方法    object.publicProperty = true;     object.publicMethod = function() &#123;         privateVariable++;         return privateFunction();     &#125;;     // 返回对象    return object; &#125;();\n\n总结\n函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。\nES6新增了类似于函数表达式的箭头函数语法，但两者也有一 些重要区别。\nJavaScript中函数定义与调用时的参数极其灵活。arguments对象，以及ES6新增的扩展操作符，可以实现函数定义和调用的完全动态化。\n函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。\nJavaScript引擎可以优化符合尾调用条件的函数，以节省栈空间。\n闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。\n通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。\n闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。\n函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。\n立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。\n虽然JavaScript没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。\n可以访问私有变量的公共方法叫作特权方法。\n特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。\n\n","categories":["前端学习笔记","JS","函数"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十八）期约（二）","url":"/2021/11/08/js-28/","content":"期约的实例方法\n期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。\n这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值,或者添加只有期约进入终止状态时才会执行的代码。\n\n1、实现Thenable接口\nthen()方法被认为实现了Thenable接口：\n\nclass MyThenable &#123;     then() &#123;&#125; &#125;\n\n2、Promise.prototype.then()\nPromise.prototype.then()是为期约实例添加处理程序的主要方法。\n接收最多两个参数：onResolved处理程序和onRejected处理程序。\n这两个参数都是可选的，如果提供的话,则会在期约分别进入“兑现”和“拒绝”状态时执行。\n\nfunction onResolved(id) &#123;     setTimeout(console.log, 0, id, &#x27;resolved&#x27;);&#125; function onRejected(id) &#123;     setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); p1.then(() =&gt; onResolved(&#x27;p1&#x27;),         () =&gt; onRejected(&#x27;p1&#x27;)); p2.then(() =&gt; onResolved(&#x27;p2&#x27;),         () =&gt; onRejected(&#x27;p2&#x27;)); //（3 秒后）// p1 resolved // p2 rejected\n\n\n因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。\n如果想只提供onRejected参数，那就要在onResolved参数的位置上传入undefined。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。\nPromise.prototype.then ()方法返回一个新的期约实例。\n\nlet p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.then(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false\n\n\n这个新期约实例基于onResovled处理程序的返回值构建。换句话说，该处理程序的返回值会通过Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会包装上一个期约解决之后的值。如果没有显式的返回语句,则Promise.resolve()会包装默认的返回值undefined。\n\nlet p1 = Promise.resolve(&#x27;foo&#x27;); // 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo // 这些都一样let p3 = p1.then(() =&gt; undefined); let p4 = p1.then(() =&gt; &#123;&#125;); let p5 = p1.then(() =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined// 如果有显式的返回值，则 Promise.resolve()会包装这个值：let p6 = p1.then(() =&gt; &#x27;bar&#x27;); let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined//抛出异常会返回拒绝的期约：let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz//返回错误值不会触发上面的ધ绝行为，而会把错误对象包装在一个解决的期约中let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux\n\n\nonRejected处理程序也与之类似: onRejected 处理程序返回的值也会被Promise.resolve()包装。\n拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。\n\nlet p1 = Promise.reject(&#x27;foo&#x27;); // 调用 then()时不传处理程序则原样向后传let p2 = p1.then(); // Uncaught (in promise) foo setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo // 这些都一样let p3 = p1.then(null, () =&gt; undefined); let p4 = p1.then(null, () =&gt; &#123;&#125;); let p5 = p1.then(null, () =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;); let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(null, () =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined let p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: baz let p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux\n\n3、Promise.prototype.catch()\n该方法用于给期约添加拒绝处理程序。\n只接收一个参数:onRejected处理程序。\n这个方法就是一个语法糖,调用它就相当于调用Promise.prototype.then(null, onRejected)。\nPromise.prototype.catch()返回一个新的期约实例:\n\nlet p = Promise.reject(); let onRejected = function(e) &#123;     setTimeout(console.log, 0, &#x27;rejected&#x27;); &#125;; // 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejected p.catch(onRejected); // rejectedlet p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.catch(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false \n\n4、Promise.prototype.finally()\n方法用于给期约添加onFinally处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。\n可以避免onResolved和onRejected处理程序中出现冗余代码。\nonFinally 处理程序没有办法知道期约的状态是解决还是拒绝，故这个方法主要用于添加清理代码。\n方法返回一个新的期约实例。\n\nlet p1 = Promise.resolve(); let p2 = Promise.reject(); let onFinally = function() &#123;     setTimeout(console.log, 0, &#x27;Finally!&#x27;) &#125; p1.finally(onFinally); // Finally p2.finally(onFinally); // Finally \nlet p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false \n\n\nonFinally被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。\n如果返回的是一个待定的期约，或者onFinally处理程序抛出了错误(显式抛出或返回了一个拒绝期约),则会返回相应的期约（待定或拒绝）。\n\nlet p1 = Promise.resolve(&#x27;foo&#x27;); // 这里都会原样后传let p2 = p1.finally(); let p3 = p1.finally(() =&gt; undefined); let p4 = p1.finally(() =&gt; &#123;&#125;); let p5 = p1.finally(() =&gt; Promise.resolve()); let p6 = p1.finally(() =&gt; &#x27;bar&#x27;); let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)); let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p10 = p1.finally(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p9); // Promise &lt;pending&gt; setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefined let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz \n\n非重入期约方法\n非重入：当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。\n\n// 创建解决的期约let p = Promise.resolve(); // 添加解决处理程序// 直觉上，这个处理程序会等期约一解决就执行p.then(() =&gt; console.log(&#x27;onResolved handler&#x27;)); // 同步输出，证明 then()已经返回console.log(&#x27;then() returns&#x27;); // 实际的输出：// then() returns // onResolved handler \n\n\n先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。\n\nlet synchronousResolve; // 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123;     synchronousResolve = function() &#123;         console.log(&#x27;1: invoking resolve()&#x27;);         resolve();         console.log(&#x27;2: resolve() returns&#x27;);     &#125;; &#125;); p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)); synchronousResolve(); console.log(&#x27;3: synchronousResolve() returns&#x27;); // 实际的输出：// 1: invoking resolve() // 2: resolve() returns // 3: synchronousResolve() returns // 4: then() handler executes\n\n\n非重人适用于onResolved/onRejected处理程序、catch()处理程序和finally()处理程序。\n\nlet p1 = Promise.resolve(); p1.then(() =&gt; console.log(&#x27;p1.then() onResolved&#x27;)); console.log(&#x27;p1.then() returns&#x27;); let p2 = Promise.reject(); p2.then(null, () =&gt; console.log(&#x27;p2.then() onRejected&#x27;)); console.log(&#x27;p2.then() returns&#x27;); let p3 = Promise.reject(); p3.catch(() =&gt; console.log(&#x27;p3.catch() onRejected&#x27;)); console.log(&#x27;p3.catch() returns&#x27;); let p4 = Promise.resolve(); p4.finally(() =&gt; console.log(&#x27;p4.finally() onFinally&#x27;)); console.log(&#x27;p4.finally() returns&#x27;); // p1.then() returns // p2.then() returns // p3.catch() returns // p4.finally() returns // p1.then() onResolved // p2.then() onRejected // p3.catch() onRejected // p4.finally() onFinally \n\n6、邻近处理程序的执行顺序\n如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。\n无论是then()、catch()还是 finally()添加的处理程序都是如此。\n\nlet p1 = Promise.resolve(); let p2 = Promise.reject(); p1.then(() =&gt; setTimeout(console.log, 0, 1)); p1.then(() =&gt; setTimeout(console.log, 0, 2)); // 1 // 2 p2.then(null, () =&gt; setTimeout(console.log, 0, 3)); p2.then(null, () =&gt; setTimeout(console.log, 0, 4)); // 3 // 4 p2.catch(() =&gt; setTimeout(console.log, 0, 5)); p2.catch(() =&gt; setTimeout(console.log, 0, 6)); // 5 // 6 p1.finally(() =&gt; setTimeout(console.log, 0, 7)); p1.finally(() =&gt; setTimeout(console.log, 0, 8)); // 7 // 8\n\n7、传递解决值和拒绝理由\n到了落定状态后，期约会提供其解决值(如果兑现)或其拒绝理由(如果拒绝)给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。\n在执行函数中，解决的值和拒绝的理由是分别作为resolve() 和reject() 的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为onResolved或onRejected处理程序的唯一参数。\n\nlet p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)); p1.then((value) =&gt; console.log(value)); // foo let p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)); p2.catch((reason) =&gt; console.log(reason)); // bar \n\n\nPromise.resolve()和Promise.reject()在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给onResolved或onRejected处理程序。\n\nlet p1 = Promise.resolve(&#x27;foo&#x27;); p1.then((value) =&gt; console.log(value)); // foo let p2 = Promise.reject(&#x27;bar&#x27;); p2.catch((reason) =&gt; console.log(reason)); // bar\n\n拒绝期约与拒绝错误处理\n拒绝期约类似于throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。\n在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。\n\nlet p1 = new Promise((resolve, reject) =&gt; reject(Error(&#x27;foo&#x27;))); let p2 = new Promise((resolve, reject) =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;); let p3 = Promise.resolve().then(() =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;); let p4 = Promise.reject(Error(&#x27;foo&#x27;)); setTimeout(console.log, 0, p1); // Promise &lt;rejected&gt;: Error: foo setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: Error: foo setTimeout(console.log, 0, p3); // Promise &lt;rejected&gt;: Error: foo setTimeout(console.log, 0, p4); // Promise &lt;rejected&gt;: Error: foo \n\n\n期约可以以任何理由拒绝，包括undefined, 但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。\n在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令。\n异步错误只能通过异步的onRejected处理程序捕获；这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用try/catch 在执行函数中捕获错误。\n\n// 正确 Promise.reject(Error(&#x27;foo&#x27;)).catch((e) =&gt; &#123;&#125;); // 不正确try &#123;     Promise.reject(Error(&#x27;foo&#x27;)); &#125; catch(e) &#123;&#125;let p = new Promise((resolve, reject) =&gt; &#123;     try &#123;         throw Error(&#x27;foo&#x27;);     &#125; catch(e) &#123;&#125;     resolve(&#x27;bar&#x27;); &#125;); setTimeout(console.log, 0, p); // Promise &lt;resolved&gt;: bar\n\n\nthen()和catch()的onRejected处理程序在语义上相当于try/catch。\nonRejected处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。\n\n","categories":["前端学习笔记","JS","Promise"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（二十七）期约（一）","url":"/2021/11/04/js-27/","content":"\nJavaScript时单线程事件循环模型，同步操作与异步操作时代码依赖的核心机制。\n\n同步与异步\n同步行为对应内存中顺序执行的处理器指令。\n每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地(如寄存器或系统内存)的信息。\n异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。\n\n期约基础\n可以通过new操作符来实例化Promise。\n创建期约时需要传入执行器函数作为参数。\n\nlet p = new Promise(() =&gt; &#123;&#125;); setTimeout(console.log, 0, p); // Promise &lt;pending&gt;\n\n期约状态机\n期约是一个有状态的对象，包括下面三种状态之一：\n\npending：待定\nfulfilled/resolved：兑现/解决\nrejected：拒绝\n\n\n待定(pending)是期约的最初始状态。在待定状态下，期约可以落定（settled)为代表成功的兑现(fulfilled)状态，或者代表失败的拒绝(rejected)状态。\n\n无论落定为哪种状态都是不可逆的。\n\n只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。\n\n期约的状态是私有的，不能直接通过JavaScript检测到。\n\n期约故意将异步行为封装起来，从而隔离外部的同步代码。\n\n\n解决值、拒绝理由及期约用例\n期约主要有两大用途：\n抽象地表示一个异步操作。期约的状态代表期约是否完成。”待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。\n期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。\n\n\n\n通过执行函数控制期约状态\n执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。\n控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为resolve()和 reject()。\n调用resolve()会把状态切换为兑现；\n调用reject ()会把状态切换为拒绝。另外，调用reject ()也会抛出错误。\n\n\n\nlet p = new Promise((resolve, reject) =&gt; &#123;  setTimeout(reject, 10000); // 10 秒后调用 reject()  // 执行函数的逻辑&#125;); setTimeout(console.log, 0, p); // Promise &lt;pending&gt; setTimeout(console.log, 11000, p); // 11 秒后再检查状态// (After 10 seconds) Uncaught error // (After 11 seconds) Promise &lt;rejected&gt; \n\nPromise.resolve()\n期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。\n通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。\n\nlet p1 = new Promise((resolve, reject) =&gt; resolve());//等价于 let p2 = Promise.resolve(); \n\n\n使用这个静态方法，实际上可以把任何值都转换为一个期约。\n\nsetTimeout(console.log, 0, Promise.resolve()); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3 // 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); // Promise &lt;resolved&gt;: 4 \n\n\nPromise.resolve()是一个幂等方法，这个幂等性会保留传入期约的状态。\n\nlet p = Promise.resolve(7); setTimeout(console.log, 0, p === Promise.resolve(p)); // true setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))); // true\n\n\n这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为。\n\nlet p = Promise.resolve(new Error(&#x27;foo&#x27;)); setTimeout(console.log, 0, p); // Promise &lt;resolved&gt;: Error: foo\n\nPromise.reject()\nPromise.reject ()会实例化一个拒绝的期约并抛出一个异步错误(这个错误不能通过try/catch 捕获，而只能通过拒绝处理程序捕获)。\n拒绝的期约的理由就是传给Promise.reject()的第一个参数。\n\nlet p = Promise.reject(3); setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3 p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 \n\n\nPromise.reject ()并没有照搬Promise.resolve()的幂等逻辑。如果传一个期约对象，则这个期约会成为它返回的拒绝期约的理由。\n\nsetTimeout(console.log, 0, Promise.reject(Promise.resolve())); // Promise &lt;rejected&gt;: Promise &lt;resolved&gt; \n\n同步/异步执行的二元性try &#123;     throw new Error(&#x27;foo&#x27;); &#125; catch(e) &#123;     console.log(e); // Error: foo &#125; try &#123;     Promise.reject(new Error(&#x27;bar&#x27;)); &#125; catch(e) &#123;     console.log(e); &#125; // Uncaught (in promise) Error: bar\n\n第一个try/catch 抛出并捕获了错误，第二个try/catch 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例,而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象(在同步执行模式中使用)，但也是异步执行模式的媒介。\n","categories":["前端学习笔记","JS","Promise"],"tags":["JS学习"]},{"title":"JavaScript——判断字符串中是否包含某个字符/字符串","url":"/2021/10/31/js-skill-1/","content":"方法一：indexOf()\n返回某个指定的字符串值在字符串中首次出现的位置；如果不存在，则返回-1；\n\nlet str = &#x27;Hello World!&#x27;;if(str.indexOf(&quot;World&quot;))&#123;    console.log(true);&#125;else&#123;    console.log(false);&#125;//true\n\n方法二：search()\n方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。\n\nlet str = &#x27;Hello World!&#x27;;if(str.search(&quot;World&quot;))&#123;    console.log(true);&#125;else&#123;    console.log(false);&#125;//true\n\n方法三: match()\n方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n\nlet str = &#x27;Hello World!&#x27;;let reg = RegExp(/Hello/);if(str.match(reg))&#123;    console.log(true);&#125;else&#123;    console.log(false);&#125;//true\n\n方法四: test()\n方法用于检索字符串中指定的值。返回 true 或 false。\n\nlet str = &#x27;Hello World!&#x27;;let reg = RegExp(/Hello/);if(reg.test(str))&#123;    console.log(true);&#125;else&#123;    console.log(false);&#125;//true\n\n方法五:exec()\n方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。\n\nlet str = &#x27;Hello World!&#x27;;let reg = RegExp(/Hello/);if(reg.exec(str))&#123;    console.log(true);&#125;else&#123;    console.log(false);&#125;//true","categories":["JS","前端刷题"],"tags":["知识点总结"]},{"title":"JavaScript学习笔记（二十一）函数（一）","url":"/2021/10/27/js-21/","content":"函数名\n函数名是指向函数的指针，它们跟其他包含对象指针的变量具有相同的行为。\n一个函数可以有多个名称。\nES6所有函数对象都会暴露一个只读的name属性。\n包含关于函数的信息；\n多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名；\n函数没有名称会如实显示成空字符串；\n使用Function构造函数创建的，则会标识成“anonymous”。\n\n\n\nfunction foo() &#123;&#125; let bar = function() &#123;&#125;; let baz = () =&gt; &#123;&#125;; console.log(foo.name); // foo console.log(bar.name); // bar console.log(baz.name); // baz console.log((() =&gt; &#123;&#125;).name); //（空字符串）console.log((new Function()).name); // anonymous\n\n\n如果函数是一个 获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀。\n\nfunction foo() &#123;&#125; console.log(foo.bind(null).name); // bound foo let dog = &#123;     years: 1,     get age() &#123;         return this.years;     &#125;,     set age(newAge) &#123;         this.years = newAge;     &#125; &#125; let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, &#x27;age&#x27;); console.log(propertyDescriptor.get.name); // get age console.log(propertyDescriptor.set.name); // set age\n\n函数参数\nECMAScript函数的参数在内部表现为一个数组。\n\n函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。\n\n不存在验证命名参数的机制。\n\narguments对象是一个类数组对象；\n\n可以使用中括号语法访问其中的元素。\n\n\n通过arguments.length可以确定参数个数。\n\n\nfunction howManyArgs() &#123;     console.log(arguments.length); &#125; howManyArgs(&quot;string&quot;, 45); // 2 howManyArgs(); // 0 howManyArgs(12); // 1\n\narguments对象可以跟命名参数一起使用。\n\nfunction doAdd(num1, num2) &#123;     if (arguments.length === 1) &#123;         console.log(num1 + 10);     &#125; else if (arguments.length === 2) &#123;         console.log(arguments[0] + num2);     &#125; &#125; \n\n箭头函数中的参数\n箭头函数的参数不能使用arguments关键字访问，只能通过定义的命名参数访问。\n\nfunction foo() &#123;     console.log(arguments[0]); &#125; foo(5); // 5 let bar = () =&gt; &#123;     console.log(arguments[0]); &#125;; bar(5); // ReferenceError: arguments is not defined\n\n\n虽然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数。\n\nfunction foo() &#123;     let bar = () =&gt; &#123;         console.log(arguments[0]); // 5     &#125;;     bar(); &#125; foo(5); \n\n默认参数值\nES6中只要在函数定义中的参数后面用就可以为参数赋一个默认值。\n\nfunction makeKing(name = &#x27;Henry&#x27;) &#123;     return `King $&#123;name&#125; VIII`; &#125; console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27; console.log(makeKing()); // &#x27;King Henry VIII&#x27;\n\n\n给参数传undefined相当于没有传值。\n\nfunction makeKing(name = &#x27;Henry&#x27;, numerals = &#x27;VIII&#x27;) &#123;     return `King $&#123;name&#125; $&#123;numerals&#125;`; &#125; console.log(makeKing()); // &#x27;King Henry VIII&#x27; console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27; console.log(makeKing(undefined, &#x27;VI&#x27;)); // &#x27;King Henry VI&#x27; \n\n\n在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。\n\nfunction makeKing(name = &#x27;Henry&#x27;) &#123;     name = &#x27;Louis&#x27;;     return `King $&#123;arguments[0]&#125;`; &#125; console.log(makeKing()); // &#x27;King undefined&#x27; console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis&#x27; \n\n默认参数作用域与暂时性死区\n因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。\n给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样。\n参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。\n\n// 调用时不传第一个参数会报错function makeKing(name = numerals, numerals = &#x27;VIII&#x27;) &#123;     return `King $&#123;name&#125; $&#123;numerals&#125;`; &#125;// 调用时不传第二个参数会报错function makeKing(name = &#x27;Henry&#x27;, numerals = defaultNumeral) &#123;  let defaultNumeral = &#x27;VIII&#x27;;  return `King $&#123;name&#125; $&#123;numerals&#125;`; &#125;\n\n参数扩展与收集扩展参数\n**…**等价于apply()方法\n\nfunction getProduct(a, b, c = 1) &#123;     return a * b * c; &#125;let getSum = (a, b, c = 0) =&gt; &#123;     return a + b + c; &#125;console.log(getProduct(...[1,2])); // 2 console.log(getProduct(...[1,2,3])); // 6 console.log(getProduct(...[1,2,3,4])); // 6 console.log(getSum(...[0,1])); // 1 console.log(getSum(...[0,1,2])); // 3 console.log(getSum(...[0,1,2,3])); // 3 \n\n收集参数\n使用扩展操作符把不同长度的独立参数组合为一个数组。\n\nfunction getSum(...values) &#123;  // 顺序累加 values 中的所有值 // 初始值的总和为 0     return values.reduce((x, y) =&gt; x + y, 0); &#125; console.log(getSum(1,2,3)); // 6 \n\n\n收集参数的前面如果还有命名参数，则只会收集其余的参数;如果没有则会得到空数组。\n收集参数的结果可变，只能把它作为最后一个参数。\n\n// 不可以function getProduct(...values, lastValue) &#123;&#125; // 可以function ignoreFirst(firstValue, ...values) &#123;     console.log(values); &#125; ignoreFirst(); // [] ignoreFirst(1); // [] ignoreFirst(1,2); // [2] ignoreFirst(1,2,3); // [2, 3] \n\n\n使用收集参数并不影响arguments对象。\n\nfunction getSum(...values) &#123;     console.log(arguments.length); // 3     console.log(arguments); // [1, 2, 3]     console.log(values); // [1, 2, 3] &#125; console.log(getSum(1,2,3));","categories":["前端学习笔记","JS","ES6"],"tags":["JS学习"]},{"title":"500.键盘行","url":"/2021/10/31/lc-500/","content":"题目给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。\n美式键盘中：\n第一行由字符 “qwertyuiop” 组成。第二行由字符 “asdfghjkl” 组成。第三行由字符 “zxcvbnm” 组成。\n提示：\n\n1 &lt;= words.length &lt;= 20\n1 &lt;= words[i].length &lt;= 100\nwords[i] 由英文字母（小写和大写字母）组成\n\n解题思路和代码\n创建三个字符串分别表示三行字符；\n判断字符串是否符合条件之前先对字符串进行大小写转换；\n对单个字符串进行遍历，遍历第一个字符给整个字符串添加标识；\n接下来的每次遍历查看是否都属于该标识所代表的字母，如果是继续遍历直至遍历完，反之将标识置为-1，然后跳过整个遍历过程。\n将标识不为-1的字符串保存在字符串中并返回。\n\n代码/** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123;    let arr1 = &#x27;qwertyuiop&#x27;;    let arr2 = &#x27;asdfghjkl&#x27;;    let arr3 = &#x27;zxcvbnm&#x27;;    let result = [];    words.forEach((word,index)=&gt;&#123;        let flag = 0;        for(let i of word)&#123;            if(i.charCodeAt()&lt;97)&#123;                i = String.fromCharCode(i.charCodeAt()+32);            &#125;            if(arr1.indexOf(i)!=-1)&#123;                if(flag ==0)&#123;                    flag = 1;                &#125;else&#123;                    if(flag !=1)&#123;                        flag =-1;                        break;                    &#125;else&#123;                        continue                    &#125;                &#125;            &#125;else if(arr2.indexOf(i)!=-1)&#123;                if(flag ==0)&#123;                    flag = 2;                &#125;else&#123;                    if(flag !=2)&#123;                        flag =-1;                        break;                    &#125;else&#123;                        continue                    &#125;                &#125;                &#125;else&#123;                if(flag ==0)&#123;                    flag = 3;                &#125;else&#123;                    if(flag !=3)&#123;                        flag =-1;                        break;                    &#125;else&#123;                        continue                    &#125;                &#125;             &#125;        &#125;        if(flag!=-1)&#123;            result.push(word);        &#125;    &#125;)    return result;&#125;;\n\n知识点总结\n字符与ASCll码互转：str为字符\n\n字符➡ASCll码：String.fromChartCode(Number)；\nASCll码➡字符：str.chartCodeAt()；\n\n\n判断字符串中是否包含某一字符\n\n","categories":["JS","前端刷题"],"tags":["LeetCode刷题"]},{"title":"575. 分糖果","url":"/2021/11/01/lc-575/","content":"题目给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。链接：https://leetcode-cn.com/problems/distribute-candies\n解题思路和代码假设糖果总共m个，种类有n种：当n &lt; m/2时，结果为n；当n &gt; m/2时，结果为m/2；\n\n使用哈希表统计糖果种类数；\n使用Set集合直接计算；\n\n代码一：执行用时：128ms；内存消耗：51.4MB；\n/** * @param &#123;number[]&#125; candyType * @return &#123;number&#125; */var distributeCandies = function(candyType) &#123;    let dic = new Map();    let len = candyType.length;    for(const i of candyType)&#123;        if(dic.has(i))&#123;            dic.set(i,dic.get(i)+1);        &#125;else&#123;            dic.set(i,1);        &#125;    &#125;    return Math.min(dic.size,len/2);&#125;\n\n代码二：执行用时: 104 ms内存消耗: 50.9 MB\n/** * @param &#123;number[]&#125; candyType * @return &#123;number&#125; */var distributeCandies = function(candyType) &#123;    let len = candyType.length;    let set = new Set(candyType);    return Math.min(set.size,len/2);&#125;\n\n","categories":["JS","前端刷题"],"tags":["LeetCode刷题"]},{"title":"JavaScript学习笔记（二十九）期约（三）","url":"/2021/11/11/js-29/","content":"期约连锁与期约合成\n期约连锁与期约合成主要用于将多个期约组合在一起进而构成强大的代码逻辑。\n前者是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。\n\n期约连锁\n简单理解，期约连锁是由期约的连缀方法构成的。\n期约连锁的原理是：每个期约实例的方法都会返回一个新的期约对象，而这个新期约又有自己的实例方法。\n\nlet p = new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;first&#x27;);     resolve(); &#125;); p.then(() =&gt; console.log(&#x27;second&#x27;))  .then(() =&gt; console.log(&#x27;third&#x27;))  .then(() =&gt; console.log(&#x27;fourth&#x27;)); // first // second // third // fourth\n\n\n以上实例代码实现了一连串同步任务，实际上使用4个同步函数也可以达到这样的效果，所以说这种方式执行的任务没有那么有用。\n要真正的执行异步任务，可以改写这个例子，让每个执行器都返回一个期约实例，实现串行化异步任务。\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;p1 executor&#x27;);     setTimeout(resolve, 1000); &#125;); p1.then(() =&gt; new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;p2 executor&#x27;);     setTimeout(resolve, 1000);  &#125;))  .then(() =&gt; new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;p3 executor&#x27;);     setTimeout(resolve, 1000);  &#125;))  .then(() =&gt; new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;p4 executor&#x27;);     setTimeout(resolve, 1000);  &#125;)); // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后）\n\n\n将生成期约的代码提取到一个工厂函数中：\n\n//工厂函数function delayedResolve(str) &#123;     return new Promise((resolve, reject) =&gt; &#123;         console.log(str);         setTimeout(resolve, 1000);     &#125;); &#125; delayedResolve(&#x27;p1 executor&#x27;)     .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;))     .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;))     .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;)) // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后）\n\n\n假如不使用期约：就会出现回调地狱问题。\n\nfunction delayedExecute(str, callback = null) &#123;     setTimeout(() =&gt; &#123;         console.log(str);         callback &amp;&amp; callback();     &#125;, 1000) &#125; delayedExecute(&#x27;p1 callback&#x27;, () =&gt; &#123;     delayedExecute(&#x27;p2 callback&#x27;, () =&gt; &#123;         delayedExecute(&#x27;p3 callback&#x27;, () =&gt; &#123;             delayedExecute(&#x27;p4 callback&#x27;);         &#125;);     &#125;); &#125;); // p1 callback（1 秒后）// p2 callback（2 秒后）// p3 callback（3 秒后）// p4 callback（4 秒后）\n\n期约图\n期约连锁可以构建有向非循环图的结构，这是由于一个期约可以有任意多个处理程序。\n\n每一个期约都是图中的一个节点，使用实例方法添加的处理程序则是有向顶点。\n\n图的方向就是期约的解决或拒绝顺序。\n\n我们以二叉树为例：\n\n\n//      A //    /   \\ //   B     C //  / \\   / \\ // D   E F   G let A = new Promise((resolve, reject) =&gt; &#123;     console.log(&#x27;A&#x27;);     resolve(); &#125;); let B = A.then(() =&gt; console.log(&#x27;B&#x27;)); let C = A.then(() =&gt; console.log(&#x27;C&#x27;)); B.then(() =&gt; console.log(&#x27;D&#x27;)); B.then(() =&gt; console.log(&#x27;E&#x27;)); C.then(() =&gt; console.log(&#x27;F&#x27;)); C.then(() =&gt; console.log(&#x27;G&#x27;)); // A // B // C // D // E // F // G\n\n\n以上代码实现了对二叉树的层序遍历。\n期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。\n\nPromise.all()\nPromise.all()静态方法创建的期约会在一组期约全部解决之后再解决。\n这个静态方法接收一个可迭代对象，返回一个新期约。\n\nlet p1 = Promise.all([     Promise.resolve(),     Promise.resolve() ]); // 可迭代对象中的元素会通过 Promise.resolve()转换为期约let p2 = Promise.all([3, 4]); // 空的可迭代对象等价于 Promise.resolve() let p3 = Promise.all([]); // 无效的语法let p4 = Promise.all(); // TypeError: cannot read Symbol.iterator of undefined \n\n\n合成的期约只会在每个包含的期约都解决之后才解决。\n\nlet p = Promise.all([     Promise.resolve(),     new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p); // Promise &lt;pending&gt; p.then(() =&gt; setTimeout(console.log, 0, &#x27;all() resolved!&#x27;)); // all() resolved!（大约 1 秒后）\n\n\n如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝。\n如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组,按照迭代器顺序。\n如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作。\n\nPromise.race()\nPromise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。\n这个方法接收一个可迭代对象，返回一个新期约。\n\nlet p1 = Promise.race([     Promise.resolve(),     Promise.resolve() ]); // 可迭代对象中的元素会通过 Promise.resolve()转换为期约let p2 = Promise.race([3, 4]); // 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;) let p3 = Promise.race([]); // 无效的语法let p4 = Promise.race(); // TypeError: cannot read Symbol.iterator of undefined \n\n\nPromise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约。\n\n// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([  Promise.resolve(3),  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3 // 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([     Promise.reject(4),     new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4 // 迭代顺序决定了落定顺序let p3 = Promise.race([     Promise.resolve(5),     Promise.resolve(6),     Promise.resolve(7) ]); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5\n\n串行期约合成\n这里其实利用了期约的另一个主要特性：异步产生值并将其转给处理程序。\n\nfunction addTwo(x) &#123;return x + 2;&#125; function addThree(x) &#123;return x + 3;&#125; function addFive(x) &#123;return x + 5;&#125; function addTen(x) &#123;     return Promise.resolve(x)         .then(addTwo)         .then(addThree)         .then(addFive); &#125; addTen(8).then(console.log); // 18\n\n\n使用Array.prototype.reduce()改写简洁形式：\n\nfunction addTwo(x) &#123;return x + 2;&#125; function addThree(x) &#123;return x + 3;&#125; function addFive(x) &#123;return x + 5;&#125; function addTen(x) &#123;     return [addTwo, addThree, addFive] .reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x)); &#125; addTen(8).then(console.log); // 18 \n\n\n这种模式可以提炼出一个通用函数：可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。\n\nfunction addTwo(x) &#123;return x + 2;&#125; function addThree(x) &#123;return x + 3;&#125; function addFive(x) &#123;return x + 5;&#125; function compose(...fns) &#123;     return (x) =&gt; fns.reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x)) &#125; let addTen = compose(addTwo, addThree, addFive);addTen(8).then(console.log); // 18 \n\n期约扩展期约取消期约取消可以理解为，存在以下情况时的操作：    * 期约正在处理过程中，程序不需要其结果，需要将期约取消。\n使用Kevin Smith提到的“取消令牌”。\n\n生成的令牌实例提供了一个接口，利用这个接口可以取消期约；\n同时提供一个期约实例用来触发取消后的操作并求值取消状态。\n\n期约进度通知\n可以理解为监控期约的执行进度。\n使用扩展Promise类，为它添加notify()方法。\n\nclass TrackablePromise extends Promise &#123;     constructor(executor) &#123;         const notifyHandlers = [];             super((resolve, reject) =&gt; &#123;             return executor(resolve, reject, (status) =&gt; &#123;                 notifyHandlers.map((handler) =&gt; handler(status));             &#125;);         &#125;);         this.notifyHandlers = notifyHandlers;     &#125;     notify(notifyHandler) &#123;         this.notifyHandlers.push(notifyHandler);         return this;     &#125; &#125; ","categories":["前端学习笔记","JS","ES6","Promise"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十）异步函数（一）","url":"/2021/11/14/js-30/","content":"\n异步函数,也称为“async/await”(语法关键字)。\nES8的async/await旨在解决利用异步结构组织代码的问题。\n\n异步函数1、async\nasync关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。\n\nasync function foo() &#123;&#125; let bar = async function() &#123;&#125;; let baz = async () =&gt; &#123;&#125;; class Qux &#123;     async qux() &#123;&#125; &#125; \n\n\n使用async关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。\n在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。\n\nasync function foo() &#123;     console.log(1); &#125;foo(); console.log(2); // 1 // 2 \n\n\n异步函数如果使用return关键字返回了值（如果没有return则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。\n异步函数始终返回期约对象。\n\nasync function foo() &#123;     console.log(1);     return 3; &#125; // 给返回的期约添加一个解决处理程序foo().then(console.log);console.log(2); // 1 =&gt; 异步函数中输出// 2 =&gt; 非重入期约方法优先执行// 3 =&gt; 排队等待最后输出//============等价于===============async function foo() &#123;     console.log(1);     return Promise.resolve(3); &#125; // 给返回的期约添加一个解决处理程序foo().then(console.log); console.log(2); // 1 // 2 // 3\n\n\n异步函数的返回值期待(但实际上并不要求)一个实现thenable接口的对象,但常规的值也可以。\n如果返回的是实现thenable接口的对象，则这个对象可以由提供给then()的处理程序“解包”。\n如果不是，则返回值就被当作已经解决的期约。\n\n// 返回一个原始值 async function foo() &#123;     return &#x27;foo&#x27;; &#125; foo().then(console.log); // foo// 返回一个没有实现 thenable 接口的对象async function bar() &#123;     return [&#x27;bar&#x27;]; &#125; bar().then(console.log); // [&#x27;bar&#x27;]// 返回一个实现了 thenable 接口的非期约对象async function baz() &#123;     const thenable = &#123;         then(callback) &#123; callback(&#x27;baz&#x27;); &#125;     &#125;;     return thenable; &#125; baz().then(console.log); // baz// 返回一个期约async function qux() &#123;     return Promise.resolve(&#x27;qux&#x27;); &#125; qux().then(console.log); // qux\n\n\n与在期约处理程序中一样,在异步函数中抛出错误会返回拒绝的期约。拒绝期约的错误不会被异步函数捕获\n\nasync function foo() &#123;     console.log(1);     throw 3; &#125; // 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2); // 1 // 2 // 3async function foo() &#123;     console.log(1);     Promise.reject(3); &#125; // Attach a rejected handler to the returned promise foo().catch(console.log); console.log(2); // 1 // 2 // Uncaught (in promise): 3\n\n2、await\n使用await关键字可以暂停异步函数代码的执行，等待期约解决。\nawait关键字会暂停执行异步函数后面的代码，让出 JavaScript运行时的执行线程。\nawait关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。\n\n// 异步打印&quot;foo&quot; async function foo() &#123;     console.log(await Promise.resolve(&#x27;foo&#x27;)); &#125; foo(); // foo // 异步打印&quot;bar&quot; async function bar() &#123;     return await Promise.resolve(&#x27;bar&#x27;); &#125; bar().then(console.log); // bar // 1000 毫秒后异步打印&quot;baz&quot; async function baz() &#123;     await new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));     console.log(&#x27;baz&#x27;); &#125; baz(); // baz（1000 毫秒后）\n\n\nawait关键字期待（但实际上并不要求)一个实现thenable接口的对象，但常规的值也可以。\n如果是实现thenable接口的对象，则这个对象可以由await来“解包”。\n如果不是，则这个值就被当作已经解决的期约。\n\n// 等待一个原始值 async function foo() &#123;     console.log(await &#x27;foo&#x27;); &#125; foo(); // foo// 等待一个没有实现 thenable 接口的对象async function bar() &#123;     console.log(await [&#x27;bar&#x27;]); &#125; bar(); // [&#x27;bar&#x27;]// 等待一个实现了 thenable 接口的非期约对象async function baz() &#123;     const thenable = &#123;         then(callback) &#123; callback(&#x27;baz&#x27;); &#125;     &#125;;     console.log(await thenable); &#125; baz(); // baz // 等待一个期约async function qux() &#123;     console.log(await Promise.resolve(&#x27;qux&#x27;)); &#125; qux(); // qux\n\n\n等待会抛出错误的同步操作，会返回拒绝的期约。\n\nasync function foo() &#123;     console.log(1);     await (() =&gt; &#123; throw 3; &#125;)(); &#125; // 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2); // 1 // 2 // 3 \n\n\n单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用await 则会释放（ unwrap)错误值（将拒绝期约返回)。\n\nasync function foo() &#123;     console.log(1);     await Promise.reject(3);     console.log(4); // 这行代码不会执行&#125; // 给返回的期约添加一个拒绝处理程序foo().catch(console.log); console.log(2); // 1 // 2 // 3\n\n3、await的限制\nawait 关键字必须在异步函数中使用，不能在顶级上下文如script标签或模块中使用。\n\nasync function foo() &#123;     console.log(await Promise.resolve(3)); &#125; foo(); // 3 // 立即调用的异步函数表达式(async function() &#123;     console.log(await Promise.resolve(3)); &#125;)(); // 3\n\n\n异步函数的特质不会扩展到嵌套函数。\nawait关键字只能直接出现在异步函数的定义中。\n在同步函数内部使用await会抛出SyntaxError。\n\n// 不允许：await 出现在了箭头函数中function foo() &#123;  const syncFn = () =&gt; &#123;  return await Promise.resolve(&#x27;foo&#x27;);  &#125;;  console.log(syncFn()); &#125; // 不允许：await 出现在了同步函数声明中function bar() &#123;     function syncFn() &#123;         return await Promise.resolve(&#x27;bar&#x27;);     &#125;     console.log(syncFn()); &#125; // 不允许：await 出现在了同步函数表达式中function baz() &#123;     const syncFn = function() &#123;         return await Promise.resolve(&#x27;baz&#x27;);     &#125;;     console.log(syncFn()); &#125; // 不允许：IIFE 使用同步函数表达式或箭头函数function qux() &#123;     (function () &#123; console.log(await Promise.resolve(&#x27;qux&#x27;)); &#125;)();     (() =&gt; console.log(await Promise.resolve(&#x27;qux&#x27;)))(); &#125; \n\n停止和恢复执行async function foo() &#123;     console.log(await Promise.resolve(&#x27;foo&#x27;)); &#125; async function bar() &#123;     console.log(await &#x27;bar&#x27;); &#125; async function baz() &#123;     console.log(&#x27;baz&#x27;); &#125; foo(); bar(); baz(); // baz // bar // foo \n\n\nasync/await中真正起作用的是 await。\nasync关键字，无论从哪方面来看，都不过是一个标识符。\n异步函数如果不包含await关键字,其执行基本上跟普通函数没有什么区别。\n\nasync function foo() &#123;     console.log(2); &#125; console.log(1); foo(); console.log(3); // 1 // 2 // 3 \n\n\nJavaScript运行时在碰到await关键字时，会记录在哪里暂停执行。等到await 右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。\n即使await后面跟着一个立即可用的值，函数的其余部分也会被异步求值。\n\nasync function foo() &#123;     console.log(2);     await null;     console.log(4); &#125; console.log(1); foo(); console.log(3); // 1 // 2 // 3 // 4 \n\n控制台中输出结果的顺序很好地解释了运行时的工作过程：\n\n打印1；\n\n调用异步函数foo()；\n\n（在foo()中）打印2；\n\n（在foo()中）await关键字暂停执行，为立即可用的值null向消息队列中添加一个任务；\n\nfoo()退出；\n\n打印3；\n\n同步线程的代码执行完毕；\n\nJavaScript运行时从消息队列中取出任务，回复异步函数执行；\n\n（在foo()中）恢复执行，await取得null值；\n\n（在foo()中）打印4；\n\nfoo()返回。\n\n对于await后面是一个期约，问题会稍微复杂一点；为了执行异步函数，实际上会有两个任务被添加到消息队列并被添加到消息队列并被异步求值。\n\n\nasync function foo() &#123;     console.log(2);     console.log(await Promise.resolve(8));     console.log(9); &#125; async function bar() &#123;     console.log(4);     console.log(await 6);     console.log(7); &#125; console.log(1); foo(); console.log(3); bar(); console.log(5); // 1 // 2 // 3 // 4 // 5 // 6 // 7 // 8 // 9\n\n执行步骤如下：(1) 打印 1；(2) 调用异步函数 foo()；(3)（在 foo()中）打印 2；(4)（在 foo()中）await 关键字暂停执行，向消息队列中添加一个期约在落定之后执行的任务；(5) 期约立即落定，把给 await 提供值的任务添加到消息队列；(6) foo()退出；(7) 打印 3；(8) 调用异步函数 bar()；(9)（在 bar()中）打印 4；(10)（在 bar()中）await 关键字暂停执行，为立即可用的值 6 向消息队列中添加一个任务；(11) bar()退出；(12) 打印 5；(13) 顶级线程执行完毕；(14) JavaScript 运行时从消息队列中取出解决 await 期约的处理程序，并将解决的值 8 提供给它；(15) JavaScript 运行时向消息队列中添加一个恢复执行 foo()函数的任务；(16) JavaScript 运行时从消息队列中取出恢复执行 bar()的任务及值 6；(17)（在 bar()中）恢复执行，await 取得值 6；(18)（在 bar()中）打印 6；(19)（在 bar()中）打印 7；(20) bar()返回；(21) 异步任务完成，JavaScript 从消息队列中取出恢复执行 foo()的任务及值 8；(22)（在 foo()中）打印 8；(23)（在 foo()中）打印 9；(24) foo()返回。\n","categories":["前端学习笔记","JS","ES6","Promise"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十一）异步函数（二）","url":"/2021/11/15/js-31/","content":"异步函数策略1、实现sleep()函数async function sleep(delay) &#123;     return new Promise((resolve) =&gt; setTimeout(resolve, delay)); &#125; async function foo() &#123;     const t0 = Date.now();     await sleep(1500); // 暂停约 1500 毫秒    console.log(Date.now() - t0); &#125; foo(); // 1502 \n\n2、利用平行执行我们来看下面这个例子：\nasync function randomDelay(id) &#123;  // 延迟 0~1000 毫秒    const delay = Math.random() * 1000;     return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123;         console.log(`$&#123;id&#125; finished`);         resolve();     &#125;, delay)); &#125; async function foo() &#123;     const t0 = Date.now();     for (let i = 0; i &lt; 5; ++i) &#123;         await randomDelay(i);     &#125;     console.log(`$&#123;Date.now() - t0&#125;ms elapsed`); &#125; foo(); // 0 finished // 1 finished // 2 finished // 3 finished // 4 finished // 877ms elapsed\n\n\n这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。\n如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。\n\nasync function randomDelay(id) &#123;  // 延迟 0~1000 毫秒    const delay = Math.random() * 1000;     return new Promise((resolve) =&gt; setTimeout(() =&gt; &#123;         console.log(`$&#123;id&#125; finished`);         resolve(id);     &#125;, delay)); &#125; async function foo() &#123;     const t0 = Date.now();     const promises = Array(5).fill(null).map((_, i) =&gt; randomDelay(i));     for (const p of promises) &#123;         console.log(`awaited $&#123;await p&#125;`);     &#125;     console.log(`$&#123;Date.now() - t0&#125;ms elapsed`); &#125; foo(); // 1 finished // 2 finished // 4 finished // 3 finished // 0 finished // awaited 0 // awaited 1 // awaited 2 // awaited 3 // awaited 4 // 645ms elapsed\n\n3、串行执行期约async function addTwo(x) &#123;return x + 2;&#125; async function addThree(x) &#123;return x + 3;&#125; async function addFive(x) &#123;return x + 5;&#125; async function addTen(x) &#123;     for (const fn of [addTwo, addThree, addFive]) &#123;         x = await fn(x);     &#125;     return x; &#125; addTen(9).then(console.log); // 19","categories":["前端学习笔记","JS","ES6","Promise"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十二）BOM（一）","url":"/2021/11/15/js-32/","content":"\nBOM的核心是window对象，表示浏览器的实例。\nwindow对象在浏览器中有两重身份：\nECMAScript中的Global对象；\n浏览器窗口的JavaScript接口。\n\n\n\nGlobal作用域\nwindow对象被复用为ECMAScript的Global对象；\n通过var声明的所有全局变量和函数都会变成window对象的属性和方法。\n使用let 或const替代var，则不会把变量添加给全局对象。\n\nvar age = 29; var sayAge = () =&gt; alert(this.age); alert(window.age); // 29 sayAge(); // 29 window.sayAge(); // 29 //=========================let age = 29; const sayAge = () =&gt; alert(this.age); alert(window.age); // undefined sayAge(); // undefined window.sayAge(); // TypeError: window.sayAge is not a function \n\n\n访问未声明的变量会抛出错误，但是可以在window对象上查询是否存在可能未声明的变量。\n\n// 这会导致抛出错误，因为 oldValue 没有声明var newValue = oldValue; // 这不会抛出错误，因为这里是属性查询// newValue 会被设置为 undefined var newValue = window.oldValue;\n\n窗口关系\ntop对象始终指向最上层（最外层)窗口，即浏览器窗口本身。\nparent对象则始终指向当前窗口的父窗口。\nself对象是终极window属性，始终会指向window。\n\n窗口位置与像素比\nwindow对象的位置可以通过不同的属性和方法来确定：\nscreenLeft和screenTop属性，用于表示窗口相对于屏幕左侧和顶部的位置，返回值的单位是CSS像素。\n\n\n可以使用moveTo()和 moveBy()方法移动窗口，这两个方法都接收两个参数：\nmoveTo()接收要移动到的新位置的绝对坐标x和y;\nmoveBy()接收相对当前位置在两个方向上移动的像素数。\n\n\n\n// 把窗口移动到左上角window.moveTo(0,0); // 把窗口向下移动 100 像素window.moveBy(0, 100);// 把窗口移动到坐标位置(200, 300) window.moveTo(200, 300); // 把窗口向左移动 50 像素window.moveBy(-50, 0);\n\n窗口大小\nouterWidth 和 outerHeight返回浏览器窗口自身大小。\ninnerWidth 和innerHeight返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）\ndocument.documentElement.clientWidth和document. documentElement.clientHeight返回页面视口的宽度和高度。\n浏览器窗口自身的精确尺寸不好确定,但可以确定页面视口的大小：\n\nlet pageWidth = window.innerWidth,     pageHeight = window.innerHeight; if (typeof pageWidth != &quot;number&quot;) &#123;     if (document.compatMode == &quot;CSS1Compat&quot;)&#123;         pageWidth = document.documentElement.clientWidth;         pageHeight = document.documentElement.clientHeight;     &#125; else &#123;         pageWidth = document.body.clientWidth;      pageHeight = document.body.clientHeight;     &#125; &#125; \n\n这里，先将 pagewidth 和 pageHeight 的值分别设置为window.innerwidth和 window.innerHeight。然后，检查 pagewidth是不是一个数值，如果不是则通过document.compatMode来检查页面是否处于标准模式。如果是，则使用document.documentElement.clientwidth 和 document.documentElement.clientHeight；否则，就使用document.body.clientwidth和document.body.clientHeight。\n\n在移动设备上，window.innerwidth和window.innerHeight返回视口的大小，也就是屏幕上页面可视区域的大小。Mobile Internet Explorer支持这些属性，但在 document.documentElement.clientwidth和 document.documentElement.clientHeight中提供了相同的信息。在放大或缩小页面时,这些值也会相应变化。\n在其他移动浏览器中, document.documentElement.clientWidth和document.documentElement.clientHeight返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分。Mobile Internet Explorer 把布局视口的信息保存在document.body.clientwidth和document.body.clientHeight中。在放大或缩小页面时，这些值也会相应变化。\n\n视口位置\n浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。\n度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollx和window.pageYoffset/window.scrollY。\n可以使用scroll()、scrollTo()和 scrollBy()方法滚动页面。\n这3个方法都接收表示相对视口距离的x和y坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。\n\n\n\n// 相对于当前视口向下滚动 100 像素window.scrollBy(0, 100); // 相对于当前视口向右滚动 40 像素window.scrollBy(40, 0); // 滚动到页面左上角window.scrollTo(0, 0);// 滚动到距离屏幕左边及顶边各 100 像素的位置window.scrollTo(100, 100);\n\n\n这几个方法也都接收一个 scrollTo0ptions 字典,除了提供偏移值,还可以通过behavior属性告诉浏览器是否平滑滚动。\n\n// 正常滚动 window.scrollTo(&#123;     left: 100,     top: 100,     behavior: &#x27;auto&#x27; &#125;); // 平滑滚动window.scrollTo(&#123;     left: 100,     top: 100,     behavior: &#x27;smooth&#x27; &#125;); \n\n导航与打开新窗口\nwindow.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。方法接收4个参数：\n要加载的URL；\n目标窗口；如果是一个已存在的窗口或窗格的名字，则会在对应的窗口或窗格中打开URL；如果不是则会打开一个新窗口或标签页\n特性字符串；用于指定新窗口的配置，如果没有指定则新窗口会带有所有默认的浏览器特性，如果打开的不是新窗口则忽略。\n表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。\n\n\n\n// 与&lt;a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;/&gt;相同window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); /**执行这行代码的结果就如同用户点击了一个href 属性为&quot;http://www.wrox.com&quot;，target属性为&quot;topFrame&quot;的链接。如果有一个窗口名叫&quot;topPrame&quot;，则这个窗口就会打开这个 URL;否则就会打开一个新窗口并将其命名为&quot;topFrame&quot;。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、 _top或_blank。**/\n\n定时器\nsetTimeout()用于指定在一定时间后执行某些代码。\n接收两个参数：要执行的代码和执行回调函数前等待的时间。\n第一个参数可以是包含JavaScript代码的字符串或者一个函数；\n第二个参数是要等待的毫秒数，告诉JavaScript引擎在指定的毫秒数过后把任务添加到这个队列。\n返回一个表示该超时排期的数值ID\n\n\nsetInterval()用于指定每隔一段时间执行某些代码。\n接收两个参数：要执行的代码（字符串或函数）和下一次执行定时代码的任务添加到队列要等待的时间。\n第二个参数指的是向队列添加新任务之前等待的时间。\n执行时间短、非阻塞的回调函数比较合适。\n返回一个循环定时ID，可以用于在未来某个时间点上取消循环定时。\n\n\n\nlet num = 0; let max = 10; let incrementNumber = function() &#123;     num++;     // 如果还没有达到最大值，再设置一个超时任务    if (num &lt; max) &#123;         setTimeout(incrementNumber, 500);     &#125; else &#123;         alert(&quot;Done&quot;);     &#125;  &#125; setTimeout(incrementNumber, 500);//==================================/*在这个例子中，变量num 会每半秒递增一次，直至达到最大限制值。此时循环定时会被取消。*/let num = 0, intervalId = null; let max = 10; let incrementNumber = function() &#123;     num++;     // 如果达到最大值，则取消所有未执行的任务    if (num == max) &#123;         clearInterval(intervalId);         alert(&quot;Done&quot;);     &#125; &#125; intervalId = setInterval(incrementNumber, 500);\n\n系统对话框\n使用alert()、confirm()和prompt()方法，可以让浏览器调用系统对话框向用户显示消息。\n这些对话框与浏览器中显示的网页无关，也不包含HTML。\n这些对话框都是同步的模态对话框,即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。\nalert()方法：消息框\n接收一个要显示给用户的字符串。\n只接受一个参数。\n只有一个按钮（OK/确认）\n如果传入的参数不是一个原始字符串，则会调用这个值的toString()方法转换为字符串。\n\n\nconfirm()方法：确认框\n两个按钮（OK/确认，Cancel/取消）。\n返回一个布尔值，OK/确认➡true，Cancel/取消➡false。\n\n\nprompt()方法：提示框\n两个按钮（OK/确认，Cancel/取消）和文本框（允许用户输入内容）。\n接收两个参数：要显示给用户的文本以及文本框的默认值。\n\n\n\n","categories":["前端学习笔记","JS","BOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（Node类型）","url":"/2021/11/24/js-34-1/","content":"Node类型\nDOMLevel 1描述了名为Node的接口，这个接口时所有DOM节点类型都必须实现的。\n每个节点都有nodeType 属性，表示该节点的类型。节点类型由定义在 Node类型上的12个数值常量表示:\nNode.ELEMENT_NODE（1） \nNode.ATTRIBUTE_NODE（2） \nNode.TEXT_NODE（3） \nNode.CDATA_SECTION_NODE（4） \nNode.ENTITY_REFERENCE_NODE（5） \nNode.ENTITY_NODE（6） \nNode.PROCESSING_INSTRUCTION_NODE（7） \nNode.COMMENT_NODE（8） \nNode.DOCUMENT_NODE（9） \nNode.DOCUMENT_TYPE_NODE（10） \nNode.DOCUMENT_FRAGMENT_NODE（11） \nNode.NOTATION_NODE（12）\n\n\n\n1、nodeName与nodeValue\nnodeName 与nodeValue 保存着有关节点的信息。\n这两个属性的值完全取决于节点类型，在使用这两个属性前,最好先检测节点类型。\n\nif (someNode.nodeType == 1)&#123;     value = someNode.nodeName; // 会显示元素的标签名&#125;/*在这个例子中，先检查了节点是不是元素。如果是，则将其nodeName 的值赋给一个变量。对元素而言，nodeName始终等于元素的标签名，而nodevalue 则始终为null。*/\n\n2、节点关系\n文档中的所有节点都与其他节点有关系，这些关系可以形容为家族关系，相当于把文档树比作家谱。\n每个节点都有一个childNodes属性，其中包含一个NodeList的实例。\nNodeList是一个类数组对象，用于存储可以按位置存取的有序节点。\nNodeList并不是Array的实例，但可以使用中括号访问它的值,而且它也有length属性。\nNodeList是一个对DOM结构的查询，DOM结构的变化会自动地在NodeList 中反映出来。\n我们通常说NodeList 是实时的活动对象，而不是第一次访问时所获得内容的快照。\n\nlet firstChild = someNode.childNodes[0]; let secondChild = someNode.childNodes.item(1); let count = someNode.childNodes.length; \n\n\n使用Array.prototype.slice()可以把NodeList对象转换为数组。\nES6的Array.from()静态方法同样也能实现。\n\nlet arrayOfNodes1 = Array.prototype.slice.call(someNode.childNodes,0);let arrayOfNodes2 = Array.from(someNode.childNodes); \n\n\n每个节点都有一个parentNode属性，指向其DOM树中的父元素。\n\nchildNodes中的所有节点都有同一个父元素，因此它们的parentNode属性都指向同一个节点。\n\nchildNodes列表中的每个节点都是同一列表中其他节点的同胞节点。\n\n使用previoussibling 和nextsibling可以在这个列表的节点间导航。\n\n这个列表中第一个节点的previoussibling属性是 null，最后一个节点的nextSibling属性也是null。\nif (someNode.nextSibling === null)&#123;      alert(&quot;Last node in the parent&#x27;s childNodes list.&quot;); &#125; else if (someNode.previousSibling === null)&#123;     alert(&quot;First node in the parent&#x27;s childNodes list.&quot;); &#125;\n如果childlNodes中只有一个节点,则它的previoussibling和 nextsibling 属性都是null。\n\n父节点和它的第一个及最后一个子节点也有专门属性：firstchild 和 lastchild 分别指向childNodes 中的第一个和最后一个子节点。\n\nsomeNode.firstchild的值始终等于someNode.childNodes[0]，而someNode.lastChild 的值始终等于someNode.childNodes[someNode.childNodes.length-1]。\n\n如果只有一个子节点，则firstchild和 lastchild指向同一个节点。\n\n如果没有子节点，则firstchild和 lastchild都是 null。\n\n\n\n\n3、操纵节点\n由于所有的关系指针都是只读的，DOM提供了一些操纵节点的方法。\nappendChild()：用于在childNodes列表末尾添加节点\n添加新节点会更新相关的关系指针，包括父节点和之前一个子节点。\nappendChild()会返回新添加的节点。\n\n\n\nlet returnedNode = someNode.appendChild(newNode); alert(returnedNode == newNode); // true alert(someNode.lastChild == newNode); // true\n\n\n如果把文档中已经存在的节点传给appendChild() ,则这个节点会从之前的位置被转移到新位置。\n即使DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。\n如果调用appendChild()传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点。\n\n// 假设 someNode 有多个子节点let returnedNode = someNode.appendChild(someNode.firstChild); alert(returnedNode == someNode.firstChild); // false alert(returnedNode == someNode.lastChild); // true\n\n\n如果想把节点放到childNodes中的特定位置而不是末尾，则可以使用**insertBefore()**方法。\n方法接收两个参数：要插入的节点和参照节点。\n调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。\n如果参照节点是 null，则insertBefore()与 appendchild()效果相同。\n\n\n\n// 作为最后一个子节点插入returnedNode = someNode.insertBefore(newNode, null); alert(newNode == someNode.lastChild); // true // 作为新的第一个子节点插入returnedNode = someNode.insertBefore(newNode, someNode.firstChild); alert(returnedNode == newNode); // true alert(newNode == someNode.firstChild); // true // 插入最后一个子节点前面returnedNode = someNode.insertBefore(newNode, someNode.lastChild); alert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true\n\n\nappendChild()和insertBefore()在插入节点时不会删除任何已有节点。\nreplacechild()方法接收两个参数：要插入的节点和要替换的节点。\n要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。\n使用replacechild()插入一个节点后，所有关系指针都会从被替换的节点复制过来。\n\n// 替换第一个子节点let returnedNode = someNode.replaceChild(newNode, someNode.firstChild); // 替换最后一个子节点returnedNode = someNode.replaceChild(newNode, someNode.lastChild);\n\n\n移除节点可以使用removeChild()方法。\n这个方法接收一个参数，即要移除的节点。\n被移除的节点会被返回,\n\n\n\n// 删除第一个子节点let formerFirstChild = someNode.removeChild(someNode.firstChild); // 删除最后一个子节点let formerLastChild = someNode.removeChild(someNode.lastChild);\n\n\n上面介绍的4个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的parentNode属性）。\n并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法,则会导致抛出错误。\n\n4、其他方法\ncloneNode()会返回与调用它的节点一模一样的节点。\n\n方法接收一个布尔值参数，表示是否深复制。即复制节点及其整个子DOM树。\n如果传入 false，则只会复制调用该方法的节点。\n复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点 ( orphan )。\n可以通过appendchild()，insertBefore()或replacechild()方法把孤儿节点添加到文档中。\n\n\nnormalize()用于处理文档子树中的文本节点。\n\n在节点上调用normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。\n如果发现空文本节点，则将其删除；\n如果两个同胞节点是相邻的，则将其合并为一个文本节点。\n\n\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十三）BOM（二）","url":"/2021/11/17/js-33/","content":"location对象\nlocation对象提供了当前窗口中加载文档的信息，以及通常的导航功能。\n它既是window的属性，也是document的属性。\nlocation对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。\n\n假设当前浏览器加载的URL是：http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q= javascript#contents\nlocation对象的内容如下：\n\n\n查询字符串\n虽然location.search 返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。\n\n/*这个函数首先删除了查询字符串开头的问号，当然前提是location.search必须有内容。解析后的参数将被保存到args对象，这个对象以字面量形式创建。接着，先把查询字符串按照s分割成数组，每个元素的形式为name=value。for循环迭代这个数组，将每一个元素按照=分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用decodeURIComponent ()解码后（这是因为查询字符串通常是被编码后的格式)分别保存在name和value变量中。最后，name作为属性而value作为该属性的值被添加到args对象。*/let getQueryStringArgs = function() &#123;  // 取得没有开头问号的查询字符串    let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;),     // 保存数据的对象    args = &#123;&#125;;     // 把每个参数添加到 args 对象    for (let item of qs.split(&quot;&amp;&quot;).map(kv =&gt; kv.split(&quot;=&quot;))) &#123;         let name = decodeURIComponent(item[0]),             value = decodeURIComponent(item[1]);         if (name.length) &#123;             args[name] = value;         &#125;     &#125;     return args; &#125; \n\n\nURLSearchParams提供了一组标准API方法,通过它们可以检查和修改查询字符串。\n实例上暴露了get()、set()、delete()等方法。\n\nlet qs = &quot;?q=javascript&amp;num=10&quot;; let searchParams = new URLSearchParams(qs); alert(searchParams.toString()); // &quot; q=javascript&amp;num=10&quot; searchParams.has(&quot;num&quot;); // true searchParams.get(&quot;num&quot;); // 10 searchParams.set(&quot;page&quot;, &quot;3&quot;); alert(searchParams.toString()); // &quot; q=javascript&amp;num=10&amp;page=3&quot; searchParams.delete(&quot;q&quot;); alert(searchParams.toString()); // &quot; num=10&amp;page=3&quot;\n\n操作地址\n通过修改location对象可以修改浏览器的地址。\nassign()方法传入一个URL。\n\nlocation.assign(&quot;http://www.wrox.com&quot;);//下面两行代码都会执行与显式调用assign()一样的操作window.location = &quot;http://www.wrox.com&quot;; location.href = &quot;http://www.wrox.com&quot;;\n\n\n修改location对象的属性也会修改当前加载的页面。\n\n// 假设当前 URL 为 http://www.wrox.com/WileyCDA/ // 把 URL 修改为 http://www.wrox.com/WileyCDA/#section1 location.hash = &quot;#section1&quot;; // 把 URL 修改为 http://www.wrox.com/WileyCDA/?q=javascript location.search = &quot;?q=javascript&quot;; // 把 URL 修改为 http://www.somewhere.com/WileyCDA/ location.hostname = &quot;www.somewhere.com&quot;; // 把 URL 修改为 http://www.somewhere.com/mydir/ location.pathname = &quot;mydir&quot;; // 把 URL 修改为 http://www.somewhere.com:8080/WileyCDA/ location.port = 8080; \n\n\n以上所有方法都会在浏览器的历史记录中增加相应的记录。* 如果不希望增加历史记录，可以使用replace()方法。\n这个方法接收一个URL参数。\n重新加载页面后不会增加历史记录，并且用户不能回到前一页。\n\n\nreload()方法也可以修改地址，作用是重新加载当前显示的页面。\n不传参数页面会以最有效的方式重新加载。\n\n\n\nlocation.reload(); // 重新加载，可能是从缓存加载location.reload(true); // 重新加载，从服务器加载\n\nnavigator对象navigator是由Netscape Navigator2最早引入浏览器的，现在已经成为客户端标识浏览器的标准。只要浏览器启用JavaScript，navigator对象就一定存在。但是与其他BOM对象一样，每个浏览器都支持自己的属性。\n\n\n\n\nnavigator对象的属性通常用于确定浏览器的类型。\n\n检测插件\n除IE10及更低版本外的浏览器，都可以通过plugins数组来确定。这个数组中的每一项都包含如下属性。\nname：插件名称。\ndescription：插件介绍。\nfilename：插件的文件名。\nlength：由当前插件处理的MIME类型数量。\n\n\n\n// 插件检测，IE10 及更低版本无效 let hasPlugin = function(name) &#123;     name = name.toLowerCase();     for (let plugin of window.navigator.plugins)&#123;         if (plugin.name.toLowerCase().indexOf(name) &gt; -1)&#123;             return true;         &#125;     &#125;     return false; &#125; // 检测 Flash alert(hasPlugin(&quot;Flash&quot;)); // 检测 QuickTime alert(hasPlugin(&quot;QuickTime&quot;));\n\n注册处理程序\n使用registerProtocolHandler()方法可以把一个网站注册为处理某种特定类型信息应用程序。\n必须传入3个参数：\n要处理的协议；如：mailto或ftp\n处理该协议的URL；\n应用名称。\n\n\n\n把一个Web应用程序注册为默认邮件客户端：\n/*这个例子为&quot;mailto&quot;协议注册了一个处理程序，这样邮件地址就可以通过指定的Web应用程序打开。注意,第二个参数是负责处理请求的URL，%s表示原始的请求。*/navigator.registerProtocolHandler(&quot;mailto&quot;,  &quot;http://www.somemailclient.com?cmd=%s&quot;,  &quot;Some Mail Client&quot;); \n\nscreen对象\n该对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息。\nscreen对象上暴露的属性如下：\n\n\n\nhistory对象\n表示当前窗口首次使用以来用户的导航历史记录。\nhistory是window的属性。\n\n导航\ngo()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。\n只接收一个参数：\n可以是一个整数：表示前进后退多少步；\n负值：表示在历史记录中后退；\n正值：表示在历史记录中前进；\n\n\n\n// 后退一页history.go(-1); // 前进一页history.go(1); // 前进两页history.go(2);\n\n\ngo()方法可以简写为：back()和forward()。\n\n// 后退一页history.back(); // 前进一页history.forward(); \n\n历史状态管理\nhashchange会在页面URL的散列变化时被触发，开发者可以在此时执行某些操作。\n状态管理API则可以让开发者改变浏览器URL而不会加载新页面。\nhistory.pushState()方法接收3个参数：\nstate对象；\n新状态的标题；\n(可选的)相对URL。\n\n\npushstate()方法执行后，状态信息就会被推到历史记录中,浏览器地址栏也会改变以反映新的相对URL。\n\n","categories":["前端学习笔记","JS","BOM","location对象"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（Document类型）","url":"/2021/11/24/js-34-2/","content":"Document类型\nDocument类型是JavaScript中表示文档节点的类型。\n在浏览器中，文档对象 document是HTMLDocument 的实例(HTMLDocument继承Document )，表示整个HTML页面。\ndocument是window对象的属性，因此是一个全局对象。\nDocument类型的节点有以下特征：\nnodeType等于9；\nnodeName值为”#document”；\nnodeValue值为null;\nparentNode值为null；\nownerDocument值为null；\n子节点可以是DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment类型。\n\n\nDocument类型可以表示HTML页面或其他XML文档，但最常用的还是通过HTMLDocument的实例取得document对象。\ndocument对象可用于获取关于页面的信息以及操纵其外观和底层结构。\n\n1、文档子节点\n有两个快捷方式用于访问子节点：\ndocumentElement属性：始终指向HTML页面中的html元素。&lt;html&gt;     &lt;body&gt;     &lt;/body&gt; &lt;/html&gt;\n针对以上页面结构，浏览器解析完成后，文档只有一个子节点，即&lt;html&gt;元素，这个元素既可以通过documentElement属性获取也可以通过childNodes列表访问。\n\nlet html = document.documentElement; // 取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); // true alert(html === document.firstChild); // true \n\n\nHTMLDocument的实例document还有一个body属性直接指向&lt;body&gt;元素。\nDocument类型另一种可能的子节点是DocumentType。\n&lt;!doctype&gt;标签是文档中独立的部分，其信息可以通过doctype属性来访问。\n出现在&lt;html&gt;元素外的注释也是文档的子节点，类型为Comment。不过由于浏览器实现不同，注释不一定能被识别。\n因为文档类型是只读的，而且只能由一个Element类型的子节点，所以像appendChild()、removeChild()等方法不会再document对象上使用。\n\n2、文档类型\ndocument作为HTMLDocument的实例，还有一些标准Document对象上所没有的属性。\ntitle：包含&lt;title&gt;元素中的文本，通常显示再浏览器窗口或标签页的标题栏。可以通过修改title属性来修改页面的标题，但是并不会改变&lt;title&gt;元素。（document.title）\nURL：包含当前页面完整的URL，与域名是相关的。比如：http://www.wrox.com/WileyCDA/ ➡ www.wrox.com。（document.URL）\ndomain：包含页面的域名，可以调整设置，但出于安全考虑设置的值也是有限制的。（document.domain）\nreferrer：包含链接到当前页面的那个页面的URL；如果当前页面没有来源，则referrer属性包含字符串。（document.referrer）\n\n\n当页面中包含来自某个不同子域的窗格(&lt;frame&gt;)或内嵌窗格(&lt;iframe&gt;)时，设置document.domain是有用的。\n因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时,在每个页面上把document.domain设置为相同的值，这些页面就可以访问对方的JavaScript对象了。\n比如，一个加载自 www.wrox.com的页面中包含一个内嵌窗格，其中的页面加载自p2p.wrox.com。这两个页面的document.domain包含不同的字符串，内部和外部页面相互之间不能访问对方的 JavaScript对象。如果每个页面都把document.domain 设置为wrox.com，那这两个页面之间就可以通信了。\n浏览器对domain属性还有一个限制，即这个属性一旦放松就不能再收紧。\n\n// 页面来自 p2p.wrox.com document.domain = &quot;wrox.com&quot;; // 放松，成功document.domain = &quot;p2p.wrox.com&quot;; // 收紧，错误\n\n3、定位元素\n获取某个或某组元素的引用：\ngetElementById()：\n接收一个参数，即要获取元素的ID；\n如果找到了则返回这个元素，如果没找到则返回null；\n参数ID必须跟元素在页面中的id属性值完全匹配，包括大小写。\n\n\ngetElementsByTagName()：\n方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的NodeList。\n在 HTML文档中，这个方法返回一个HTMLCollection对象。\n\n\ngetElementsByName()：\n返回具有给定name属性的所有元素。\n\n\n\n\n\n4、特殊集合document对象上还暴露了几个特殊集合，这些集合也都是HTMLCollection的实例，同样也是访问文档中公共部分的快捷方式。\n\ndocument.anchors：包含文档中所有带name属性的&lt;a&gt;元素\ndocument.applets：包含文档中所有&lt;applet&gt;元素\ndocument.forms：包含文档中所有&lt;form&gt;元素与document.getElementsByTagName (“form”)返回的结果相同)。\ndocument.images：包含文档中所有&lt;img&gt;元素(与document.getElementsByTagName (“img”)返回的结果相同)。\ndocument.links包含文档中所有带href属性的&lt;a&gt;元素。\n\n5、DOM兼容性检测\n由于DOM有多个 Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。\ndocument.implementation属性是一个对象，其中提供了与浏览器DOM实现相关的信息和能力。\nDOM Level 1在 document.implementation上只定义了一个方法，即hasFeature()。\n这个方法接收两个参数：特性名称和DOM版本。\n\n\n\n\n\n\n6、文档写入\nwrite()、writeln()、open()和 close()。\nwrite()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。\nwrite()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符（\\n）。\n\n&lt;html&gt; &lt;head&gt;     &lt;title&gt;document.write() Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;p&gt;The current date and time is:     &lt;script type=&quot;text/javascript&quot;&gt;         document.write(&quot;&lt;strong&gt;&quot; + (new Date()).toString() + &quot;&lt;/strong&gt;&quot;);     &lt;/script&gt;     &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;\n运行结果如下：\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（Element类型）","url":"/2021/11/24/js-34-3/","content":"Element类型\nElement表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。\n\nElement类型的节点具有以下特征：\n\nnodeType等于1；\nnodeName值为元素的标签名；\nnodevalue值为null；\nparentNode值为Document或Element对象；\n子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference类型。\n\n\n可以通过nodeName或tagName属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会)。\n&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;\nlet div = document.getElementById(&quot;myDiv&quot;); alert(div.tagName); // &quot;DIV&quot; alert(div.tagName == div.nodeName); // true\n在 HTML 中，元素标签名始终以全大写表示；\n\n在 XML(包括XHTML) 中，标签名始终与源代码中的大小写一致。\n\n如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较\n\n\nif (element.tagName == &quot;div&quot;)&#123; // 不要这样做，可能出错！    // do something here &#125; if (element.tagName.toLowerCase() == &quot;div&quot;)&#123; // 推荐，适用于所有文档    // 做点什么&#125;\n\n1、HTML元素\n所有HTML元素都通过HTMLElement类型表示，包括其直接实例和间接实例。\n\nHTMLElement直接继承Element并增加了一些属性。\n\n每个属性都对应下列属性之一，它们是所有HTML元素上都有的标准属性：\n\nid：元素在文档中的唯一标识符；\ntitle：包含元素的额外信息，通常以提示条形式展示；\nlang：元素内容的语言代码(很少用)；\ndir：语言的书写方向(“ltr”表示从左到右，”rtl”表示从右到左，同样很少用)；\nclassName：相当于class属性，用于指定元素的CSS类(因为class是 ECMAScript关键字所以不能直接用这个名字)。&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; \n//这个元素中的所有属性都可以使用下列JavaScript代码读取let div = document.getElementById(&quot;myDiv&quot;); alert(div.id); // &quot;myDiv&quot; alert(div.className); // &quot;bd&quot; alert(div.title); // &quot;Body text&quot; alert(div.lang); // &quot;en&quot; alert(div.dir); // &quot;ltr&quot; //可以使用下列代码修改元素的属性:div.id = &quot;someOtherId&quot;; div.className = &quot;ft&quot;; div.title = &quot;Some other text&quot;; div.lang = &quot;fr&quot;; div.dir =&quot;rtl&quot;; \n\n\n把id或lang改成其他值对用户是不可见的(假设没有基于这两个属性应用CSS样式)；\n\n修改title属性则只会在鼠标移到这个元素上时才会反映出来；\n\n修改dir会导致页面文本立即向左或向右对齐；\n\n修改className 会立即反映应用到新类名的CSS样式（如果宗义了不同的样式)。\n\n\n2、取得属性\n与属性相关的DOM方法主要有3个：getAttribute()、setAttribute()和 removeAttribute()。\n如果给定的属性不存在，则getAttribute()返回null。\n\n&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; \nlet div = document.getElementById(&quot;myDiv&quot;); alert(div.getAttribute(&quot;id&quot;)); // &quot;myDiv&quot; alert(div.getAttribute(&quot;class&quot;)); // &quot;bd&quot; alert(div.getAttribute(&quot;title&quot;)); // &quot;Body text&quot; alert(div.getAttribute(&quot;lang&quot;)); // &quot;en&quot; alert(div.getAttribute(&quot;dir&quot;)); // &quot;ltr&quot; \n\n\ngetAttribute()方法也能取得不是HTML语言正式属性的自定义属性的值。\n\n&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt;\nlet value = div.getAttribute(&quot;my_special_attribute&quot;); \n\n\n属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。\n根据 HTML5 规范的要求，自定义属性名应该前缀data-以方便验证。\n元素的所有属性也可以通过相应DOM元素对象的属性来取得。\n通过 DOM对象访问的属性中有两个返回的值跟使用getAttribute()取得的值不一样：\n首先是style属性，这个属性用于为元素设定CSS样式。在使用getAttribute()访问style属性时，返回的是CSS字符串。而在通过DOM对象的属性访问时，style属性返回的是一个(cssstyleDeclaration)对象。\n第二个属性其实是一类，即事件处理程序（或者事件属性)，比如 onclick。如果使用getAttribute()访问事件属性，则返回的是字符串形式的源代码。而通过DOM对象的属性访问事件属性时返回的则是一个JavaScript函数（未指定该属性则返回null)。\n\n\n\n3、设置属性\nsetAttribute()：\n\n方法接收两个参数：要设置的属性名和属性的值。\n如果属性已经存在，则setAttribute()会以指定的值替换原来的值；如果不存在，则会创建该属性。\n适用于HTML属性和自定义属性。\n设置的属性名会规范为小写形式。\n\n\n因为元素属性也是DOM对象属性，所以直接给DOM对象的属性赋值也可以设置元素属性的值。\n\n在DOM对象上添加自定义属性不会让它变成元素的属性。\n&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt; \nlet div = document.getElementById(&quot;myDiv&quot;); div.setAttribute(&quot;id&quot;， &quot;someOtherId&quot;); div.setAttribute(&quot;class&quot;， &quot;ft&quot;); div.setAttribute(&quot;title&quot;， &quot;Some other text&quot;); div.setAttribute(&quot;lang&quot;，&quot;fr&quot;); div.setAttribute(&quot;dir&quot;， &quot;rtl&quot;); //==================div.id = &quot;someOtherId&quot;; div.align = &quot;left&quot;;//==================div.mycolor = &quot;red&quot;; alert(div.getAttribute(&quot;mycolor&quot;)); // null\nremoveAttribute()用于从元素中完全删除对应属性。\n\n在序列化DOM元素时可以通过它控制要包含的属性。\n\n\n\ndiv.removeAttribute(&quot;class&quot;); \n\n4、attributes属性\nElement类型是唯一使用attributes属性的 DOM节点类型。\n\nattributes属性包含一个NamedNodeMap实例，是一个类似NodeList 的“实时”集合。\n\n元素的每个属性都表示为一个Attr节点，并保存在这个NamedNodeMap对象中。\n\nNamedNodeMap对象包含下列方法:\n\ngetNamedItem(name)，返回nodeName属性等于name的节点;\nremoveNamedItem(name)，删除nodeName属性等于name 的节点;\nsetNamedItem(node)，向列表中添加node节点，以其nodeName为索引;\nitem(pos)，返回索引位置pos处的节点。\n\n\nattributes属性中的每个节点的nodeName是对应属性的名字，nodeValue 是属性的值。\n// 要取得元素 id 属性的值，可以使用以下代码：let id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue;// =============等价于=================let id = element.attributes[&quot;id&quot;].nodeValue; // 设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，element.attributes[&quot;id&quot;].nodeValue = &quot;someOtherId&quot;; \nemoveNamedItem()方法与元素上的removeAttribute()方法类似，也是删除指定名字的属性。\n\n两个方法唯一的不同之处，就是removeNamedItem()返回表示被删除属性的Attr节点\n\n\n\nlet oldAttr = element.attributes.removeNamedItem(&quot;id&quot;);\n\n\nattributes属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把DOM结构序列化为XML或HTML字符串。\n\n5、创建元素\ndocument.createElement()方法创建新元素。\n方法接收一个参数：需要创建元素的标签名。\n\n\n同时使用appendChild()、insertBefore()或 replaceChild()将元素添加到文档树中，浏览器就会立即将其渲染出来。\n\nlet div = document.createElement(&quot;div&quot;); document.body.appendChild(div);\n\n6、元素后代\n元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（Text类型）","url":"/2021/11/25/js-34-4/","content":"Text类型\nText节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML字符，但不含HTML代码。\nText类型的节点具有以下特征：\nnodeType等于3；\nnodeName值为”#text “；\nnodevalue值为节点中包含的文本；\nparentNode值为Element对象；\n不支持子节点。\n\n\nText节点中包含的文本可以通过nodevalue属性访问，也可以通过data属性访问，这两个属性包含相同的值。\n修改nodevalue或data的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法:\nappendData(text)，向节点末尾添加文本text；\ndeleteData(offset，count)，从位置offset开始删除count个字符；\ninsertData(offset，text)，在位置offset插人text；\nreplaceData(offset，count，text)，用text替换从位置offset到offset+count的文本；\nsplitText ( offset)，在位置offset将当前文本节点拆分为两个文本节点;\nsubstringData(offset，count)，提取从位置offset到offset+count的文本。\n\n\n通过length属性获取文本节点中包含的字符数量。这个值等于nodeValue.length和data.length。\n默认情况下，包含文本内容的每个元素最多只能有一个文本节点。\n\n&lt;!-- 没有内容，因此没有文本节点 --&gt; &lt;div&gt;&lt;/div&gt; &lt;!-- 有空格，因此有一个文本节点 --&gt;&lt;div&gt; &lt;/div&gt; &lt;!-- 有内容，因此有一个文本节点 --&gt; &lt;div&gt;Hello World!&lt;/div&gt; \n// 下列代码可以用来访问这个文本节点，同时修改它：let textNode = div.firstChild; // 或 div.childNodes[0] div.firstChild.nodeValue = &quot;Some other message&quot;; // 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot; \n\n1、创建文本节点\ndocument.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。\n跟设置已有文本节点的值一样，这些要插入的文本也会应用HTML或XML编码。let textNode = document.createTextNode(&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;);\n创建新文本节点后，其ownerDocument 属性会被设置为document。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。\n\n/*以下代码创建了一个&lt;div&gt;元素并给它添加了一段文本消息：*/let element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;; let textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode); document.body.appendChild(element);/*这个例子首先创建了一个&lt;div&gt;元素并给它添加了值为&quot;message&quot;的class属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。*/\n\n\n一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：\n\nlet element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;; let textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode); let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); element.appendChild(anotherTextNode); document.body.appendChild(element);\n\n\n在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。\n\n2、规范化文本节点\nDOM文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM文档中也经常会出现两个相邻文本节点。\nnormalize()方法可以合并相邻的文本节点。\n该方法是在Node类型中定义的。\n在包含两个或多个相邻文本节点的父节点上调用normalize()时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的nodevalue就等于之前所有同胞节点nodevalue拼接在一起得到的字符串。\n\n\n\nlet element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;; let textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode); let anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); element.appendChild(anotherTextNode); document.body.appendChild(element); alert(element.childNodes.length); // 2 element.normalize(); alert(element.childNodes.length); // 1 alert(element.firstChild.nodeValue); // &quot;Hello world!Yippee!&quot;\n\n3、拆分文本节点\nsplitText()：方法可以在指定的偏移位置拆分nodevalue，将一个文本节点拆分成两个文本节点。\n拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。\n方法返回新的文本节点，具有与原来的文本节点相同的parentNode。\n\n\n\nlet element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;; let textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode); document.body.appendChild(element); let newNode = element.firstChild.splitText(5); alert(element.firstChild.nodeValue); // &quot;Hello&quot; alert(newNode.nodeValue); // &quot; world!&quot; alert(element.childNodes.length); // 2 ","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（CDATASection类型和DocumentType类型）","url":"/2021/11/27/js-34-6/","content":"CDATASection类型\nCDATASection类型表示XML中特有的CDATA区块。\n\nCDATASection类型继承Text类型，因此拥有包括splitText ()在内的所有字符串操作方法。\n\nCDATASection类型的节点具有以下特征:\n\nnodeType等于4；\nnodeName值为”#cdata-section”；\nnodeValue值为CDATA区块的内容；\nparentNode值为Document或Element对象；\n不支持子节点。\n\n\nCDATA区块只在XML文档中有效，因此某些浏览器比较陈旧的版本会错误地将CDATA区块解析为Comment或Element。\n\n在真正的XML文档中，可以使用document.createCDataSection()并传入节点内容来创建：CDATA区块。\n\n\nDocumentType类型\nDocumentType类型的节点包含文档的文档类型(doctype)信息，具有以下特征：\nnodeType等于10；\nnodeName 值为文档类型的名称；\nnodeValue值为null；\nparentNode值为Document对象；\n不支持子节点。\n\n\nDocumentType对象在DOM Level 1中不支持动态创建，只能在解析文档代码时创建。\n对于支持这个类型的浏览器，DocumentType 对象保存在document.doctype属性中。\nDOM Level 1规定了DocumentType对象的3个属性: name、entities 和notations：\nname：文档类型的名称；\nentities：这个文档类型描述的实体的NamedNodeMap；* notations：这个文档类型描述的表示法的NamedNodeMap。\n\n\n因为浏览器中的文档通常是HTML或XHTML文档类型，所以entities和notations列表为空。( 这个对象只包含行内声明的文档类型。)无论如何，只有name属性是有用的。\n这个属性包含文档类型的名称，即紧跟在&lt;!DOCTYPE后面的那串文本。\n\n&lt;!DOCTYPE HTML PUBLIC &quot;-// W3C// DTD HTML 4.01// EN&quot;  &quot;http:// www.w3.org/TR/html4/strict.dtd&quot;&gt; \n//对于这个文档类型，name 属性的值是&quot;html&quot;：alert(document.doctype.name); // &quot;html&quot;","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十四）DOM（一）","url":"/2021/11/18/js-34/","content":"\n文档对象模型时HTML和XML文档的编程接口。\nDOM表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。\n\n节点层级\n任何HTML或XML都可以用DOM表示一个由节点构成的层级结构。\n\n&lt;html&gt;     &lt;head&gt;         &lt;title&gt;Sample Page&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;p&gt;Hello World!&lt;/p&gt;     &lt;/body&gt; &lt;/html&gt;\n\n\n\n其中, document节点表示每个文档的根节点。在这里,根节点的唯一子节点是&lt;html&gt;元素，我们称之为文档元素( documentElement)。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在HTML页面中，文档元素始终是&lt;html&gt;元素。在XML文档中,则没有这样预定义的元素,任何元素都可能成为文档元素。\nNode类型点击此处\n\nDocument类型点击此处\n\nElement类型点击此处\n\nText类型点击此处\n\nComment类型点击此处\n\nCDATASection类型点击此处\n\nDocumentType类型点击此处\n\nDocumentFragment类型点击此处\n\nAttr类型点击此处","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（Comment类型）","url":"/2021/11/27/js-34-5/","content":"Comment类型\nDOM中的注释通过Comment类型表示。\nComment类型的节点具有以下特征:\nnodeType等于8；\nnodeName值为”#comment “；\nnodeValue值为注释的内容；\nparentNode值为Document或Element对象;\n不支持子节点。\n\n\nComment类型与Text类型继承同一个基类( CharacterData )因此拥有除splitText ()之外Text节点所有的字符串操作方法。\n与Text类型相似，注释的实际内容可以通过nodeValue或data属性获得。\n\n&lt;!--注释节点可以作为父节点的子节点来访问。比如下面的HTML代码:--&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;/div&gt; \n//可以像下面这样访问它let div = document.getElementById(&quot;myDiv&quot;); let comment = div.firstChild; alert(comment.data); // &quot;A comment&quot;\n\n\n可以使用document.createComment()方法创建注释节点，参数为注释文本。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记——DOM类型（DocumentFragment类型和Attr类型）","url":"/2021/11/28/js-34-7/","content":"DocumentFragment类型\n在所有节点类型中，DocumentFragment类型是唯一一个在标记中没有对应表示的类型。\nDOM将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。\nDocumentFragment节点具有以下特征:\nnodeType等于11；\nnodeName值为”#document- fragment”；\nnodeValue值为null；\nparentNode值为null；\n子节点可以是Element、 Process ingInstruction、Comment、 Text、CDATASection或EntityRe ference。\n\n\n文档片段的作用是充当其他要被添加到文档的节点的仓库。\n可以使用document.createDocumentFragment()方法创建文档片段。let fragment = document.createDocumentFragment();\n文档片段从Node类型继承了所有文档类型具备的可以执行DOM操作的方法。\n如果文档中的一个节点被添加到一一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。\n可以通过appendChild()或insertBefore()方法将文档片段的内容添加到文档。\n在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。\n文档片段本身永远不会被添加到文档树。\n\nAttr类型\n元素数据在DOM中通过Attr类型表示。\nAttr类型构造函数和原型在所有浏览器中都可以直接访问。\n技术上讲，属性是存在于元素attributes属性中的节点。\nAttr 节点具有以下特点：\nnodeType等于2;\nnodeName值为属性名;\nnodeValue值为属性值;\nparentNode值为null;\n在HTML中不支持子节点;\n在XML中子节点可以是Text或Ent ityReference。\n\n\n属性节点尽管是节点，却不被认为是DOM文档树的一部分。\nAttr节点很少直接被引用，通常更喜欢使用getAttribute()、removeAttribute()和 setAttribute()方法操作属性。\nAttr对象上有3个属性: name、value和specified。其中，name包含属性名（与nodeName一样）value包含属性值(与nodeValue一样),而specified是一个布尔值，表示属性使用的是默认值还是被指定的值。\n可以使用document.createAttribute()方法创建新的Attr节点，参数为属性名。let attr = document.createAttribute(&quot;align&quot;); attr.value = &quot;left&quot;; element.setAttributeNode(attr); alert(element.attributes[&quot;align&quot;].value); // &quot;left&quot; alert(element.getAttributeNode(&quot;align&quot;).value); // &quot;left&quot; alert(element.getAttribute(&quot;align&quot;)); // &quot;left&quot; /*在这个例子中，首先创建了一个新属性。调用createAttribute()并传人&quot;align&quot;为新属性设置了name属性，因此就不用再设置了。随后，value属性被赋值为&quot;left&quot;。为把这个新属性添加到元素上，可以使用元素的setAttri buteNode()方法。添加这个属性后，可以通过不同方式访问它，包括attributes属性、getAttr ibuteNode ()和getAttribute()方法。其中，attributes 属性和getAttri buteNode ()方法都返回属性对应的Attr节点，而getAttribute()方法只返回属性的值。*/\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十五）DOM（二）","url":"/2021/11/28/js-35/","content":"DOM编程动态脚本\n&lt;script&gt;元素用于向网页中插人JavaScript代码,可以是src属性包含的外部文件，也可以是作为该元素内容的源代码。\n有两种方式通过&lt;script&gt;动态为网页添加脚本:引人外部文件和直接插人源代码。\n动态脚本就是在页面初始加载时不存在，之后又通过DOM包含的脚本。\n可以通过DOM编程创建这个节点:\n\nlet script = document.createElement(&quot;script&quot;); script.src = &quot;foo.js&quot;; document.body.appendChild(script); \n\n\n抽象出一个跨浏览器的函数:\n\nfunction loadScriptString(code)&#123;     var script = document.createElement(&quot;script&quot;);     script.type = &quot;text/javascript&quot;;     try &#123;         script.appendChild(document.createTextNode(code));     &#125; catch (ex)&#123;         script.text = code;     &#125;     document.body.appendChild(script); &#125;//这个函数可以这样调用：loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); \n\n动态样式\nCSS样式在HTML页面中可以通过两个元素加载：&lt;link&gt;和&lt;style&gt;\n&lt;link&gt;：用于包含CSS外部文件；\n&lt;style&gt;：用于添加嵌入样式。\n\n\n\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; \n//使用 DOM 编程创建出来let link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.type = &quot;text/css&quot;; link.href = &quot;styles.css&quot;; let head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link); \n\n应该把&lt;link&gt;元素添加到&lt;head&gt;元素而不是&lt;body&gt;元素，这样才能保证所有浏览器都能正常运行。\n\n这个过程可以抽象为以下通用函数:\nfunction loadStyles(url)&#123;     let link = document.createElement(&quot;link&quot;);     link.rel = &quot;stylesheet&quot;;     link.type = &quot;text/css&quot;;     link.href = url;     let head = document.getElementsByTagName(&quot;head&quot;)[0];     head.appendChild(link); &#125;//这样调用这个 loadStyles()函数了：loadStyles(&quot;styles.css&quot;);\n通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后顺序。\n\n另一种定义样式的方式是使用&lt;script&gt;元素包含嵌入的 CSS 规则\n&lt;style type=&quot;text/css&quot;&gt; body &#123;     background-color: red; &#125; &lt;/style&gt; \nlet style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;)); let head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style); \n\n操作表格\n表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建&lt;table&gt;元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。\n\n&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;     &lt;tbody&gt;         &lt;tr&gt;             &lt;td&gt;Cell 1,1&lt;/td&gt;             &lt;td&gt;Cell 2,1&lt;/td&gt;         &lt;/tr&gt;         &lt;tr&gt;             &lt;td&gt;Cell 1,2&lt;/td&gt;             &lt;td&gt;Cell 2,2&lt;/td&gt;         &lt;/tr&gt;     &lt;/tbody&gt; &lt;/table&gt; \n// 创建表格let table = document.createElement(&quot;table&quot;); table.border = 1; table.width = &quot;100%&quot;; // 创建表体let tbody = document.createElement(&quot;tbody&quot;); table.appendChild(tbody); // 创建第一行let row1 = document.createElement(&quot;tr&quot;); tbody.appendChild(row1); let cell1_1 = document.createElement(&quot;td&quot;); cell1_1.appendChild(document.createTextNode(&quot;Cell 1,1&quot;)); row1.appendChild(cell1_1); let cell2_1 = document.createElement(&quot;td&quot;); cell2_1.appendChild(document.createTextNode(&quot;Cell 2,1&quot;)); row1.appendChild(cell2_1); // 创建第二行let row2 = document.createElement(&quot;tr&quot;); tbody.appendChild(row2); let cell1_2 = document.createElement(&quot;td&quot;); cell1_2.appendChild(document.createTextNode(&quot;Cell 1,2&quot;)); row2.appendChild(cell1_2); let cell2_2= document.createElement(&quot;td&quot;); cell2_2.appendChild(document.createTextNode(&quot;Cell 2,2&quot;)); row2.appendChild(cell2_2); // 把表格添加到文档主体document.body.appendChild(table); \n\n\n为了方便创建表格，HTML DOM给```、和``元素添加了一些属性和方法。\n&lt;table&gt;元素添加了以下属性和方法:\n&lt;tbody&gt;元素添加了以下属性和方法:\n&lt;tr&gt;元素添加了以下属性和方法:\n\n// 创建表格let table = document.createElement(&quot;table&quot;); table.border = 1; table.width = &quot;100%&quot;; // 创建表体let tbody = document.createElement(&quot;tbody&quot;); table.appendChild(tbody); // 创建第一行tbody.insertRow(0); tbody.rows[0].insertCell(0); tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;)); tbody.rows[0].insertCell(1); tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;)); // 创建第二行tbody.insertRow(1); tbody.rows[1].insertCell(0); tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;)); tbody.rows[1].insertCell(1); tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;)); // 把表格添加到文档主体document.body.appendChild(table); \n\n使用NodeList\nDOM编程的关键是：理解NodeList对象和相关的NameNodeMap、HTMLCollection。\n以上三个集合类型是“实时的”，意味着文档结构的变化会实时地在他们身上反映出来，它们的值始终代表最新的状态。\nNodeList是基于DOM文档的实时查询。\n任何时候需要迭代NodeList，最好初始化一个变量保存当时查询时的长度，然后使用循环变量与这个变量进行比较。\n\nlet divs = document.getElementsByTagName(&quot;div&quot;); for (let i = 0, len = divs.length; i &lt; len; ++i) &#123;     let div = document.createElement(&quot;div&quot;);     document.body.appendChild(div); &#125;","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十八）DOM扩展（二）","url":"/2021/12/01/js-38/","content":"HTML5\nHTML5规范包含了与标记相关的大量 JavaSeript API定义。其中有的API与DOM重合，定义了浏览器应该提供的DOM扩展。\n\n一、CSS类扩展1、getElementByClassName()\n该方法暴露在document对象和所有HTML元素上。\n\n方法接收一个参数：包含一个或多个类名的字符串；\n返回类名中包含相应类的元素的NodeList；\n如果提供了多个类名，则顺序无关紧要。// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素// 这两个类名的顺序无关紧要let allCurrentUsernames = document.getElementsByClassName(&quot;username current&quot;); // 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素let selected = document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); \n\n\n在 document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素上调用getElementsByClassName()则返回该元素后代中匹配的元素。\n\n\n2、classList属性\nclassList属性是为了更加方便的对于类名进行增删改查操作。\nclassList是一个新的集合类型DOMTokenList的实例。\n除开length属性，item()和中括号取值等操作外，还增加了以下方法：\nadd(value)：向类名列表中添加指定的字符串值value。如果这个值已经存在,则什么也不做。\ncontains(value)：返回布尔值,表示给定的value是否存在。\nremove(value)：从类名列表中删除指定的字符串值value。\ntoggle(value)：如果类名列表中已经存在指定的value，则删除；如果不存在，则添加。// 删除&quot;disabled&quot;类div.classList.remove(&quot;disabled&quot;); // 添加&quot;current&quot;类div.classList.add(&quot;current&quot;);// 切换&quot;user&quot;类div.classList.toggle(&quot;user&quot;); // 检测类名 if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;))&#123;  // 执行操作) // 迭代类名for (let class of div.classList)&#123;     doStuff(class); &#125;\n\n\n\n\n添加了classList属性之后，除非是完全删除或完全重写元素的class属性，否则className属性就用不到了。\n\n二、焦点管理\nHTML5增加了辅助DOM焦点管理的功能。首先是document.activeElement，始终包含当前拥有焦点的 DOM元素。\n页面加载时，可以通过用户输人(按Tab键或代码中使用focus()方法）让某个元素自动获得焦点。\n默认情况下，document.activeElement在页面刚加载完之后会设置为document.body。而在页面完全加载之前，document.activeElement的值为null。\n\nlet button = document.getElementById(&quot;myButton&quot;); button.focus(); console.log(document.activeElement === button); // true\n\n\ndocument.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点。\n确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面。\n\nlet button = document.getElementById(&quot;myButton&quot;); button.focus(); console.log(document.hasFocus()); // true \n\n\n这对于保证 Web应用程序的无障碍使用是非常重要的。无障碍Web应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。\n\n三、HTMLDocument扩展1、readyState属性\ndocument.readyState属性有两个可能的值：\nloading：表示文档正在加载；\ncomplete：表示文档加载完成。\n\n\n实际开发中，最好是把 document.readstate当成一个指示器，以判断文档是否加载完毕。\n通常要依赖onload事件处理程序设置一个标记，表示文档加载完了。\n\nif (document.readyState == &quot;complete&quot;)&#123;     // 执行操作&#125; \n\n2、compatMode属性\n这个属性唯一的任务是指示浏览器当前处于什么渲染模式。\n标准模式下document.compatMode的值是“CSSlCompat”。\n混杂模式下document.compatMode的值是“BlackCompat”。\n\nif (document.compatMode == &quot;CSS1Compat&quot;)&#123;     console.log(&quot;Standards mode&quot;); &#125; else &#123;     console.log(&quot;Quirks mode&quot;); &#125; \n\n3、head属性\ndocument.head属性指向文档的&lt;head&gt;元素。\n\nlet head = document.head;\n\n四、字符集属性\ncharacterSet属性表示文档实际使用的字符集，也可以用来指定新字符集。\n属性的默认值是“UTF-16”，可以通过&lt;meta&gt;元素或响应头以及新增的characterSeet属性来修改。\n\nconsole.log(document.characterSet); // &quot;UTF-16&quot; document.characterSet = &quot;UTF-8&quot;; \n\n五、自定义数据属性\nHTML5允许给元素指定非标准的属性，但要使用前缀data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。\n除了前缀，自定义属性对命名是没有限制的,data-后面跟什么都可以。\n\n&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;\n\n\n定义了自定义数据属性后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap的实例，包含一组键/值对映射。\n元素的每个data-name 属性在dataset 中都可以通过data-后面的字符串作为键来访问(例如，属性data-myname,data-myName可以通过myname访问，但要注意data-my-name、data-My-Name要通过myName 来访问)。\n\n// 本例中使用的方法仅用于示范let div = document.getElementById(&quot;myDiv&quot;); // 取得自定义数据属性的值let appId = div.dataset.appId; let myName = div.dataset.myname; // 设置自定义数据属性的值div.dataset.appId = 23456; div.dataset.myname = &quot;Michael&quot;; // 有&quot;myname&quot;吗？if (div.dataset.myname)&#123;     console.log(`Hello, $&#123;div.dataset.myname&#125;`); &#125;\n\n六、插入标记\n在所有现代浏览器中，通过innerHTML插入的&lt;script&gt;标签是不会执行的。\n\n1、innerHTML属性\n在读取innerHTML属性时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。\n\n在写入innerHTML时，则会根据提供的字符串值以新的DOM子树替代元素中原来包含的所有节点。\n\n比如下面的 HTML 代码：\n&lt;div id=&quot;content&quot;&gt;     &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;     &lt;ul&gt;         &lt;li&gt;Item 1&lt;/li&gt;         &lt;li&gt;Item 2&lt;/li&gt;         &lt;li&gt;Item 3&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt; \n对于这里的&lt;div&gt;元素而言，其 innerHTML 属性会返回以下字符串：\n&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt;     &lt;li&gt;Item 1&lt;/li&gt;     &lt;li&gt;Item 2&lt;/li&gt;     &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; \n实际返回的文本内容会因浏览器而不同：\n\nIE 和 Opera 会把所有元素标签转换为大写；\nSafari、Chrome和 Firefox 会按照文档源代码的格式返回，包含空格和缩进。\n\n\n在写人模式下，赋给innerHTML属性的值会被解析为DOM子树，并替代元素之前的所有节点。如果赋值中不包含任何HTML标签，则直接生成一个文本节点。\n\n因为所赋的值默认为HTML，所以其中的所有标签都会以浏览器处理HTML的方式转换为元素(同样，转换结果也会因浏览器不同而不同)。div.innerHTML = &quot;Hello world!&quot;; \n\n\n因为浏览器会解析设置的值，所以给innerHTML， 设置包含HTML的字符串时，结果会大不一样。\ndiv.innerHTML = &quot;Hello &amp; welcome, &lt;b&gt;\\&quot;reader\\&quot;!&lt;/b&gt;&quot;;\n&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt;\n设置innerHTML会导致浏览器将HTML字符串解析为相应的DOM树。这意味着设置innerHTML属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 DOM子树序列化之后的结果。\n\n\n2、outerHTML属性\n读取 outerHTML属性时，会返回调用它的元素（及所有后代元素)的 HTML字符串。\n在写入outerHTML属性时，调用它的元素会被传入的 HTML字符串经解释之后生成的 DOM子树取代。\n如果使用outerHTML设置HTML，比如：div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;;\n会得到与执行以下脚本相同的结果：let p = document.createElement(&quot;p&quot;); p.appendChild(document.createTextNode(&quot;This is a paragraph.&quot;)); div.parentNode.replaceChild(p, div);\n新的&lt;p&gt;元素会取代 DOM 树中原来的&lt;div&gt;元素。\n\n3、insertAdjacentHTML()与insertAdjacentText()\n这两个方法都接收两个参数：\n要插入标记的位置；\n要插入的HTML或文本。\n\n\n第一个参数必须是下列值中的一个：\nbeforebegin：插入当前元素前面，作为前一个同胞节点；\nafterbegin：插入当前元素内部，作为新的子节点或放在第一个子节点前面；\nbeforeend：插入当前元素内部，作为新的子节点或放在最后一个子节点后面；\nafterend：插入当前元素后面，作为下一个同胞节点。\n\n\n这几个值是不区分大小写的。第二个参数会作为HTML字符串解析(与innerHTML 和outerHTML相同)或者作为纯文本解析(与innerText和outerText相同)。 如果是HTML，则会在解析出错时抛出错误。\n\n// 作为前一个同胞节点插入element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); element.insertAdjacentText(&quot;beforebegin&quot;, &quot;Hello world!&quot;); // 作为第一个子节点插入element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); element.insertAdjacentText(&quot;afterbegin&quot;, &quot;Hello world!&quot;); // 作为最后一个子节点插入element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); element.insertAdjacentText(&quot;beforeend&quot;, &quot;Hello world!&quot;); // 作为下一个同胞节点插入element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); element. insertAdjacentText(&quot;afterend&quot;, &quot;Hello world!&quot;); \n\n4、内存与性能问题\n使用以上方法替换子节点可能在浏览器(特别是IE)中导致内存问题。\n\n七、scrollIntoView()\nDOM规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5选择了标准化scrollIntoView()。\nscrollIntoView()方法存在于所有HTML元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。参数如下：\nalignToTop是一个布尔值：\ntrue：窗口滚动后元素的顶部与视口顶部对齐。\nfalse：窗口滚动后元素的底部与视口底部对齐。\n\n\nscrollIntoViewOptions是一个选项对象：\nbehavior：定义过渡动画，可取的值为” smooth”和”auto”，默认为”auto”。\nblock：定义垂直方向的对齐，可取的值为“start”、“center”、“end”和“nearest”，默认为“start”。\ninline：定义水平方向的对齐，可取的值为“start”、“center”、“end”和“nearest”，默认为“nearest”。\n\n\n不传参数等同于alignToTop为true。\n\n\n\n// 确保元素可见document.forms[0].scrollIntoView(); // 同上document.forms[0].scrollIntoView(true); document.forms[0].scrollIntoView(&#123;block: &#x27;start&#x27;&#125;); // 尝试将元素平滑地滚入视口document.forms[0].scrollIntoView(&#123;behavior: &#x27;smooth&#x27;, block: &#x27;start&#x27;&#125;);\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十七）DOM扩展（一）","url":"/2021/11/30/js-37/","content":"Selectors API\nSelectors API(参见W3C网站上的Selectors APl Level 1)是W3C推荐标准，规定了浏览器原生支持的CSS查询API。\n支持这一特性的所有JavaScript库都会实现一个基本的CSS解析器，然后使用已有的DOM方法搜索文档并匹配目标节点。\nSelectors APILevel1的核心是两个方法：queryselector()和 querySelectorAll()。在兼容浏览器中，Document类型和Element类型的实例上都会暴露这两个方法。\nSelectors API Level 2规范在Element类型上新增了更多方法，比如 matches ()、find()和findAll()。不过，目前还没有浏览器实现或宣称实现find()和findAll()。\n\nquerySelector()\n方法接收CSS选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回null。\n\n// 取得&lt;body&gt;元素let body = document.querySelector(&quot;body&quot;); // 取得 ID 为&quot;myDiv&quot;的元素let myDiv = document.querySelector(&quot;#myDiv&quot;);// 取得类名为&quot;selected&quot;的第一个元素let selected = document.querySelector(&quot;.selected&quot;); // 取得类名为&quot;button&quot;的图片let img = document.body.querySelector(&quot;img.button&quot;); \n\n在Document上使用querySelector()方法时，会从文档元素开始搜索;在Element 上使用querySelector()方法时，则只会从当前元素的后代中查询。\n如果选择符有语法错误或碰到不支持的选择符，则querySelector( )方法会抛出错误。\n\nquerySelectorAll()\nquerySelectorAll()方法跟querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个NodeList的静态实例。\nquerySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用NodeList对象可能造成的性能问题。\n返回的NodeList对象可以通过for-of循环、item()方法或中括号语法取得个别元素。\n如果没有匹配项，则返回空的NodeList实例。\n\n\nquerySelectorAll()也可以在Document、DocumentFragment和Element类型上使用。\n\n// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;); // 取得所有类名中包含&quot;selected&quot;的元素let selecteds = document.querySelectorAll(&quot;.selected&quot;); // 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs = document.querySelectorAll(&quot;p strong&quot;);//=======================let strongElements = document.querySelectorAll(&quot;p strong&quot;); // 以下 3 个循环的效果一样for (let strong of strongElements) &#123;     strong.className = &quot;important&quot;; &#125; for (let i = 0; i &lt; strongElements.length; ++i) &#123;     strongElements.item(i).className = &quot;important&quot;; &#125; for (let i = 0; i &lt; strongElements.length; ++i) &#123;     strongElements[i].className = &quot;important&quot;; &#125;\n\nmatches()\nmatches()方法(在规范草案中称为matchesSelector())接收一个CSS选择符参数，如果元素匹配则该选择符返回true，否则返回false。\n使用这个方法可以方便地检测某个元素会不会被querySelector()或 querySelectorAll()方法返回。\n\nif (document.body.matches(&quot;body.page1&quot;))&#123;     // true &#125;\n\n元素遍历\nIE9之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了childNodes和firstchild等属性上的差异。为了弥补这个差异，同时不影响DOM规范，W3C通过新的ElementTraversal规范定义了一组新属性。\n\nElement Traversal API 为 DOM 元素添加了 5 个属性：\n\nchildElementCount：返回子元素数量(不包含文本节点和注释)；\nfirstElementChild：指向第一个Element类型的子元素(Element版firstChild)；\nlastElementChild：指向最后一个 Element类型的子元素(Element版lastchild)；\npreviousElementSibling：指向前一个Element类型的同胞元素（Element版previoussibling)；\nnextElementsibling：指向后一个Element类型的同胞元素(Element 版nextsibling )。\n\n\n以下是跨浏览器方式遍历特定元素的所有子元素的写法：\nlet parentElement = document.getElementById(&#x27;parent&#x27;); let currentChildNode = parentElement.firstChild; // 没有子元素，firstChild 返回 null，跳过循环while (currentChildNode) &#123;     if (currentChildNode.nodeType === 1) &#123;     // 如果有元素节点，则做相应处理        processChild(currentChildNode);     &#125;     if (currentChildNode === parentElement.lastChild) &#123;         break;     &#125;     currentChildNode = currentChildNode.nextSibling; &#125; \n使用Element Traversal属性之后,以上代码可以简化如下:\nlet parentElement = document.getElementById(&#x27;parent&#x27;); let currentChildElement = parentElement.firstElementChild;// 没有子元素，firstElementChild 返回 null，跳过循环while (currentChildElement) &#123;     // 这就是元素节点，做相应处理    processChild(currentChildElement);     if (currentChildElement === parentElement.      lastElementChild) &#123;         break;     &#125;     currentChildElement = currentChildElement.nextElementSibling; &#125;\n\n","categories":["前端学习笔记","JS","DOM","Selectors API"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十九）DOM扩展（二）","url":"/2021/12/02/js-39/","content":"专有扩展1、children属性\nchildren属性是一个HTMLCollection，只包含元素的Element类型的子节点。\n如果元素的子节点类型全部是元素类型，那children和childNodes中包含的节点应该是一样的。\n\nlet childCount = element.children.length; let firstChild = element.children[0];\n\n2、contains()方法\nDOM编程中经常需要确定一个元素是不是另一个元素的后代。\n\nIE引入了contains()方法，让开发者可以在不遍历DOM的情况下获取这个信息。\n\n参数为待确定的目标节点；\n如果目标节点是被搜索节点的后代，返回true；否则返回false。// 这个例子测试&lt;html&gt;元素中是否包含&lt;body&gt;元素，在格式正确的HTML中会返回true。console.log(document.documentElement.contains(document.body)); // true\n\n\n使用DOM Level 3的compareDocumentPosition()方法也可以确定节点间的关系。\n\n方法会返回表示两个节点关系的位掩码。\n下表给出了这些位掩码的说明。\n\n\n掩码\n节点关系\n\n\n\n0x1\n断开（传入的节点不在文档中）\n\n\n0x2\n领先(传人的节点在DOM树中位于参考节点之前)\n\n\n0x4\n随后(传入的节点在DOM树中位于参考节点之后)\n\n\n0x8\n包含(传入的节点是参考节点的祖先)\n\n\n0x10\n被包含(传人的节点是参考节点的后代)\n\n\n\n\n\n要模仿contains()方法，就需要用到掩码16 ( 0x10 )。compareDocumentPosition()方法的结果可以通过按位与来确定参考节点是否包含传入的节点。\nlet result = document.documentElement.compareDocumentPosition(document.body); console.log(!!(result &amp; 0x10)); /*以上代码执行后result的值为20 (或0x14,其中0x4表示“随后”，加上0x10“被包含”)。对result和0x10应用按位与会返回非零值，而两个叹号将这个值转换成对应的布尔值。*/\n\n3、插入标记\nHTML5将IE发明的innerHTML和outerHTML纳人了标准，但还有两个属性没有入选。这两个剩下的属性是innerText和outerText。\n\n（1）innerText属性\ninnerText属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。\n在用于读取值时，innerText会按照深度优先的顺序将子树中所有文本节点的值拼接起来。\n在用于写入值时，innerText会移除元素的所有后代并插入一个包含该值的文本节点。&lt;div id=&quot;content&quot;&gt;     &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;     &lt;ul&gt;         &lt;li&gt;Item 1&lt;/li&gt;         &lt;li&gt;Item 2&lt;/li&gt;         &lt;li&gt;Item 3&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;\n/*对这个例子中的&lt;div&gt;而言，innerText 属性会返回以下字符串:This is a paragraph with a list following it .Item 1Item 2Item 3*/\n设置innerText会移除元素之前所有的后代节点，完全改变DOM子树。此外，设置innerText也会编码出现在字符串中的HTML语法字符(小于号、大于号、引号及和号)。\n因为设置innerText只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必须进行HTML编码。\ninnerText 属性可以用于去除HTML标签。通过将innerText 设置为等于innerText，可以去除所有HTML标签而只剩文本。\n\n（2）outerText属性\nouterText与innerText 是类似的，只不过作用范围包含调用它的节点。\n要读取文本值时，outerText与innerText实际上会返回同样的内容。\n写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。\n\ndiv.outerText = &quot;Hello world!&quot;; //等价于以下两行代码let text = document.createTextNode(&quot;Hello world!&quot;); div.parentNode.replaceChild(text, div); \n\n\n本质上，这相当于用新的文本节点替代outerText所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。\nouterText是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除Firefox之外所有主流浏览器都支持outerText。\n\n4、滚动\nHTML5把scrollIntoView()标准化了，但不同浏览器中仍然有其他专有方法。\nscrollIntoViewIfNeeded()作为HTMLElement类型的扩展可以在所有元素上调用。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十二）DOM2和DOM3（三）","url":"/2021/12/09/js-42/","content":"遍历\nDOM2 Traversal and Range模块定义了两个类型用于辅助顺序遍历DOM结构。这两个类型NodeIterator和Treewalker从某个起点开始执行对DOM结构的深度优先遍历。\nDOM遍历是**对DOM结构的深度优先遍历，至少允许朝两个方向移动(取决于类型)**。遍历以给定节点为根，不能在 DOM中向上超越这个根节点。\n查看以下HTML：&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Example&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;        &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;     &lt;/body&gt; &lt;/html&gt; \nDOM树如下：\n\n\n\n1）NodeIterator\nNodeIterator类型是两个类型中比较简单的，可以通过document.createNodeIterator()方法创建其实例。方法接收四个参数：\nroot：作为遍历根节点的节点；\nwhatToShow：数值代码，表示应该访问哪些节点；\nfilter：NodeFilter对象或函数,表示是否接收或跳过特定节点；\nentityReferenceExpansion，布尔值,表示是否扩展实体引用。这个参数在HTML文档中没有效果，因为实体引用永远不扩展。\n\n\nwhatToshow参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在NodeFilter类型中定义的。\n这些值除了 NodeFilter.SHOW_ALL 之外，都可以组合使用。\n\n\n\n\n\n\ncreateNodeIterator()方法的filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。\n\nNodeFilter对象只有一个方法**acceptNode()**，如果给定节点应该访问就返回NodeFilter.FILTER_ACCEPT，否则返回NodeFilter.FILTER_SKIP。\n\nNodeFilter 是一个抽象类型，所以不可能创建它的实例。只要创建一个包含 acceptNode()的对象，然后把它传给createNodeIterator()就可以了。\n/*以下代码定义了只接收&lt;p&gt;元素的节点过滤器对象：*/let filter = &#123;     acceptNode(node) &#123;         return node.tagName.toLowerCase() == &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;     &#125; &#125;;/*filter 参数还可以是一个函数，与 acceptNode()的形式一样，如下面的例子所示：*/let filter = function(node) &#123;     return node.tagName.toLowerCase() == &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;; let iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false);\n/*创建一个简单的遍历所有节点的 NodeIterator*/let iterator = document.createNodeIterator(document, NodeFilter.SHOW_ALL, null, false); \nNodeIterator 的两个主要方法是nextNode()和 previousNode()：\n\nnextNode()方法在DOM子树中以深度优先方式进前一步；previousNode()是在遍历中后退一步。\nNodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用nextNode ()返回的是根节点。。\n当遍历到达DOM树最后一个节点时，nextNode()返回null；previousNode()返回遍历的根节点后，再次调用也会返回null。&lt;div id=&quot;div1&quot;&gt;     &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;     &lt;ul&gt;         &lt;li&gt;List item 1&lt;/li&gt;         &lt;li&gt;List item 2&lt;/li&gt;         &lt;li&gt;List item 3&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;\n\n\n假设想要遍历&lt;div&gt;元素内部所有元素。\nlet div = document.getElementById(&quot;div1&quot;); let iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, null, false); let node = iterator.nextNode(); while (node !== null) &#123;     console.log(node.tagName); // 输出标签名    node = iterator.nextNode(); &#125;/*DIV P BUL LI LI LI*/\n如果只想遍历&lt;li&gt;元素，可以传入一个过滤器：\n\n\nlet div = document.getElementById(&quot;div1&quot;); let filter = function(node) &#123;     return node.tagName.toLowerCase() == &quot;li&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;; let iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,filter, false); let node = iterator.nextNode(); while (node !== null) &#123;    console.log(node.tagName); // 输出标签名    node = iterator.nextNode(); &#125;\n\n2）TreeWalker\nTreewalker是NodeIterator的高级版。\n除了包含同样的nextNode().previousNode()方法，Treewalker还添加了如下在 DOM结构中向不同方向遍历的方法。\nparentNode()，遍历到当前节点的父节点；\nfirstChild()，遍历到当前节点的第一个子节点；\nlastChild()，遍历到当前节点的最后一个子节点；\nnextSibling()，遍历到当前节点的下一个同胞节点；\nprevioussibling()，遍历到当前节点的上一个同胞节点。\n\n\n调用document.createTreewalker()方法来创建Treewalker对象。\n参数： 作为遍历起点的根节点、要查看的节点类型、节点过滤器、一个表示是否扩展实体引用的布尔值。\n节点过滤器：除了可以返回NodeFilter.FILTER_ACCEPT和NodeFilter.FILTER_SKIP，还可以返回NodeFilter.FILTER_REJECT。\n\n\n在使用NodeIterator时，NodeFilter.FILTER_SKIP和NodeFilter.FILTER_REJECT是一样的。\n在使用Treewalker时，NodeFilter.FILTER_SKIP表示跳过节点，访问子树中的下一个节点，而NodeFilter.FILTER_REJECT则表示跳过该节点以及该节点的整个子树。\n\n范围1、DOM范围\nDOM2在Document类型上定义了一个createRange()方法可用于创建一个DOM范围对象。\n\nlet range = document.createRange(); \n\n\n新创建的氛围对象是与创建它的文档关联，不能在其他文档中使用。\n创建范围并指定它的位置后就可以对范围的内容执行一些操作，从而实现对底层DOM树更精细的控制。\n每个范围都是 Range类型的实例，拥有相应的属性和方法。\n\n\n\n2、简单选择\nselectNode()或 selectNodeContents()是通过范围选择文档中౼个部分最简单的方式。\n参数：接收一个节点，并将该节点的信息添加到调用它的氛围\n不同：\nselectNode()选择整个节点，包括其后代节点。\nselectNodeContents()只选择节点的后代。&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;body&gt;         &lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;     &lt;/body&gt; &lt;/html&gt;\nlet range1 = document.createRange(),     range2 = document.createRange(),     p1 = document.getElementById(&quot;p1&quot;); range1.selectNode(p1); range2.selectNodeContents(p1); \n\n\n\n\n\n\n\n\n调用selectNode()时，startContainer、endContainer和 commonAncestorContainer都等于传入节点的父节点。在这个例子中,这几个属性都等于document.body。\n选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制：\n\n\n\n3、复杂选择\n要创建复杂的范围，需要使用setstart()和setEnd()方法。\n两个方法都接收两个参数：参照节点和偏移量。\n对setstart()来说，参照节点会成为startContainer，而偏移量会赋值给startoffset。\n对setEnd()而言，参照节点会成为endContainer，而偏移量会赋值给endoffset。&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;body&gt;         &lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;     &lt;/body&gt; &lt;/html&gt;\n/*通过范围从中选择从&quot;Hello&quot;中的&quot;1lo&quot;到&quot; world! 中的&quot;o&quot;的部分。*/let p1 = document.getElementById(&quot;p1&quot;),     helloNode = p1.firstChild.firstChild,     worldNode = p1.lastChildlet range = document.createRange(); range.setStart(helloNode, 2); range.setEnd(worldNode, 3); \n\n\n\n\n\n4、操作范围\n创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。\n为操作范围的内容，选区中的内容必须格式完好。\n范围能够确定缺ܾ的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作。\n\n&lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;body&gt;         &lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;     &lt;/body&gt; &lt;/html&gt;\n\n针对以上例子，范围发现选区中缺少一个开始的&lt;b&gt;标签，于是会在后台动态补上这个标签，同时还需要补上封闭”He”的结束标签&lt;/b&gt;，结果会把 DOM 修改为这样：\n&lt;p&gt;&lt;b&gt;He&lt;/b&gt;&lt;b&gt;llo&lt;/b&gt; world!&lt;/p&gt; \ndeleteContents()方法会从文档中删除范围包含的节点。\n\n\nlet p1 = document.getElementById(&quot;p1&quot;),    helloNode = p1.firstChild.firstChild,    worldNode = p1.lastChild,    range = document.createRange(); range.setStart(helloNode, 2);range.setEnd(worldNode, 3);range.deleteContents();\n\n执行上面的代码之后，页面中的 HTML 会变成这样：&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; \nextractContents()也会从文档中移除范围选区，同时返回范围对应的文档片段。\n下面例子中提取了范围的文档片段，然后把它添加到文档&lt;body&gt;元素的最后。let p1 = document.getElementById(&quot;p1&quot;),     helloNode = p1.firstChild.firstChild,     worldNode = p1.lastChild, range = document.createRange(); range.setStart(helloNode, 2); range.setEnd(worldNode, 3); let fragment = range.extractContents(); p1.parentNode.appendChild(fragment);\n&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; &lt;b&gt;llo&lt;/b&gt; wo\n如果不想把范围从文档中移除,也可以使用cloneContents()创建一个副本，然后把这个副本插入到文档其他地方。\n\n5、范围插入\ninsertNode()：方法可以在范围选区的开始位置插人一个节点。&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; \nlet p1 = document.getElementById(&quot;p1&quot;),     helloNode = p1.firstChild.firstChild,     worldNode = p1.lastChild,     range = document.createRange(); range.setStart(helloNode, 2); range.setEnd(worldNode, 3); let span = document.createElement(&quot;span&quot;); span.style.color = &quot;red&quot;; span.appendChild(document.createTextNode(&quot;Inserted text&quot;)); range.insertNode(span); \n&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;He&lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt; world&lt;/p&gt;\nsurroundContents()：方法插入包含范围的内容。\n接收一个参数：包含范围内容的节点。\n\n\n\n6、范围折叠\n如果范围并没有选择文档的任何部分，则称为折叠( collapsed )。\n折叠范围有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。\n在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。\n\n\n\n\ncollapse()方法\n接收一个参数：布尔值，表示折叠到范围哪一段。\ntrue表示折叠到起点；false表示折叠到终点。let p1 = document.getElementById(&quot;p1&quot;),     p2 = document.getElementById(&quot;p2&quot;),     range = document.createRange(); range.setStartAfter(p1); range.setStartBefore(p2); console.log(range.collapsed); // true \n\n\n\n7、范围比较\ncompareBoundaryPoints()方法确定范围之间是否存在公共的边界。\n参数：接收两个参数，要比较的范围和以恶常量值，表示比较的方式。\nRange.START_TO_START(0)，比较两个范围的起点;\nRange.START_TO_END(1)，比较第一个范围的起点和第二个范围的终点；\nRange.END_TO_END（2),比较两个范围的终点；\nRange.END_TO_START (3)，比较第一个范围的终点和第二个范围的起点。\n\n\n返回值：\n在第一个范围的边界点位于第二个范围的边界点之前时返回-1；\n在两个范围的边界点相等时返回0；\n在第一个范围的边界点位于第二个范围的边界点之后时返回1。&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; \nlet range1 = document.createRange(); let range2 = document.createRange(); let p1 = document.getElementById(&quot;p1&quot;); range1.selectNodeContents(p1); range2.selectNodeContents(p1); range2.setEndBefore(p1.lastChild); console.log(range1.compareBoundaryPoints(Range.START_TO_START, range2)); // 0 console.log(range1.compareBoundaryPoints(Range.END_TO_END, range2)); // 1 \n\n\n\n\n\n8、复制范围\ncloneRange()方法可以复制范围，会创建调用它的范围的副本。\n新范围包含与原始范围一样的属性,修改其边界点不会影响原始范围。\n\n9、清理\ndetach()方法把范围从创建它的文档中剥离。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十）DOM2和DOM3（一）","url":"/2021/12/03/js-40/","content":"\nDOM1(DOMLevel1)主要定义了HTML和XML文档的底层结构。\nDOM2(DOMLevel2)和DOM3 ( DOM Level3 )在这些结构之上加入更多交互能力，提供了更高级的XML特性。\nDOM2和DOM3是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个DOM子集。这些模式如下所示。\nDOM Core:在DOM1核心部分的基础上，为节点增加方法和属性。\nDOM Views:定义基于样式信息的不同视图。\nDOM Events:定义通过事件实现DOM文档交互。\nDOM Style:定义以编程方式访问和修改CSS样式的接口。\nDOM Traversal and Range:新增遍历DOM文档及选择文档内容的接口。\nDOM HTML:在DOM1 HTML部分的基础上，增加属性、方法和新接口。\nDOM Mutation Observers:定义基于DOM变化触发回调的接口。这个模块是DOM4级模块，用于取代Mutation Events。\n\n\n\nDOM的演进\nDOM2和DOM3Core模块的目标是扩展DOMAPI,满足XML的所有需求并提供更好的错误处理和特性检测。\nDOM2 Core没有新增任何类型，仅仅在DOM1 Core基础上增加了一些方法和属性。\nDOM3 Core除了增强原有类型，也新增了一些新类型。\n\n1、XML命名空间\nXML命名空间可以实现在一个格式规范的文档中混用不同的XML语言，而不必担心元素命名冲突。严格来讲，XML命名空间在XHTML中才支持，HTML并不支持。\n命名空间是使用xmlns指定的。XHTML的命名空间是”http://www.w3.org/1999/xhtml&quot;，应该包含在任何格式规范的XHTML页面的``````元素中：\n\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;     &lt;head&gt;        &lt;title&gt;Example XHTML page&lt;/title&gt;     &lt;/head&gt;    &lt;body&gt;        Hello world!     &lt;/body&gt; &lt;/html&gt; \n\n对这个例子来说，所有元素都默认属于XHTML命名空间。可以使用xmlns给命名空间创建一个前缀，格式为“xmlns：前缀”，如下所示：\n&lt;xhtml:html xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;     &lt;xhtml:head&gt;     &lt;xhtml:title&gt;Example XHTML page&lt;/xhtml:title&gt;     &lt;/xhtml:head&gt;     &lt;xhtml:body&gt;     Hello world!     &lt;/xhtml:body&gt; &lt;/xhtml:html&gt;\nDOM2 Core为解决以下问题，给大部分DOM1方法提供了特定于命名空间的版本。\n\n创建了一个新元素，那这个元素属于哪个命名空间？\n查询特定标签名时，结果中应该包含哪个命名空间下的元素？\n\n\n\n1）Node的变化\n在DOM2中，Node类型包含以下特定于命名空间的属性：\nlocalName：不包含命名空间前缀的节点名；\nnamespaceURI：节点的命名空间URL，如果未指定则为null；\nprefix：命名空间前缀，如果未指定则为null。\n在节点使用命名空间前缀的情况下，nodeName 等于prefix+ “:”+ localName。\n\n\nDOM3进一步增加了如下与命名空间相关的方法：\nisDefaultNamespace(namespaceURI)，返回布尔值，表示namespaceURI是否为节点的默认命名空间。\nlookupNamespaceURI(prefix)，返回给定prefix的命名空间URI；\nlookupPrefix(namespaceURI)，返回给定namespaceURI的前缀。\n\n\n\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;     &lt;head&gt;         &lt;title&gt;Example XHTML page&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;s:svg xmlns:s=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;         viewBox=&quot;0 0 100 100&quot; style=&quot;width:100%; height:100%&quot;&gt;             &lt;s:rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;fill:red&quot; /&gt;         &lt;/s:svg&gt;     &lt;/body&gt; &lt;/html&gt; \nconsole.log(document.body.isDefaultNamespace(&quot;http://www.w3.org/1999/xhtml&quot;)); // true // 假设 svg 包含对&lt;s:svg&gt;元素的引用console.log(svg.lookupPrefix(&quot;http://www.w3.org/2000/svg&quot;)); // &quot;s&quot; console.log(svg.lookupNamespaceURI(&quot;s&quot;)); // &quot;http://www.w3.org/2000/svg&quot; \n\n2）Document的变化\nDOM2在Document类型上新增了如下命名空间特定的方法：\ncreateElementNs(namespaceURI, tagName), 以给定的标签名tagName创建指定命名空间namespaceURI的一个新元素；\ncreateAttributeNS (namespaceURI, attributeName),以给定的属性名attributeName创建指定命名空间namespaceURI的一个新属性；\ngetElementsByTagNameNS (namespaceURI, tagName) ，返回指定命名空间namespaceURI中所有标签名为tagName的元素的NodeList。\n\n\n这些命名控件特定的方法只在文档中包含两个或两个以上命名空间时才有用。\n\n3）Element的变化\nDOM2 Core对Element类型的更新主要集中在对属性的操作上。下面是新增的方法：\ngetElementsByTagNameNS (namespaceURI, tagName) ，取得指定命名空间namespaceURI中标签名为tagName的元素的NodeList;\nhasAttributeNS (namespaceURI, localName)， 返回布尔值，表示元素中是否有命名空间namespaceURI下名为localName的属性(注意，DOM2Core也添加不带命名空间的hasAttribute()方法);\nremoveAttributeNS (namespaceURI, localName) ，删除指定命名空间namespaceURI中名为localName的属性;\nsetAttributeNS (namespaceURI, qualifiedName,value)，设置指定命名空间namespaceURI中名为qualifiedName的属性为value；\nsetAttributeNodeNS (attNode)，为元素设置(添加)包含命名空间信息的属性节点attNode。\n\n\n这些方法与DOM1中对应的方法行为相同，除setAttributeNodeNS()之外都只是多了一个命名空间参数。\n\n4）NamedNodeMap的变化\nNamedNodeMap也增加了以下处理命名空间的方法。因为NamedNodeMap主要表示属性，所以这些方法大都适用于属性：\ngetNamedItemNS (namespaceURI, localName), 取得指定命名空间namespaceURI中名为localName的项; \nremoveNamedItemNS (namespaceURI, localName)，删除指定命名空间namespaceURI 中名为loca1Name的项；\nsetNamedItemNS (node)，为元素设置(添加)包含命名空间信息的节点。\n\n\n\n2、其他变化1）DocumentType的变化\n新增了三个属性：publicId、systemId和internalSubset。publicId、systemId属性表示文档类型声明中有效但无法使用DOM1 API访问的数据。\n\n&lt;!DOCTYPE HTML PUBLIC &quot;-// W3C// DTD HTML 4.01// EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\n\npublicId是”-// W3C// DTD HTML 4.01// EN”；\nsystemId是”http://www.w3.org/TR/html4/strict.dtd&quot;；\n支持DOM2的浏览器应该可以运行以下JavaScript代码：\n\nconsole.log(document.doctype.publicId); console.log(document.doctype.systemId); \n\n\ninternalsubset用于访问文档类型声明中可能包含的额外定义，如下面的例子所示：\n\n&lt;!DOCTYPE html PUBLIC &quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot; [&lt;!ELEMENT name (#PCDATA)&gt;] &gt; \n\n对于以上声明，document . doctype. internalSubset会返回”“。HTML文档中几乎不会涉及文档类型的内部子集，XML文档中稍微常用一些。\n\n2）Document的变化\n唯一与命名空间无关的方法：importNode()。\n\n用于从其他文档获取一个节点并导入到新文档，以便将其插入新文档。\n接收两个参数：要复制的节点和表示是否同时复制子树的布尔值。\n返回结果是适合在当前文档中使用的新节点。let newNode = document.importNode(oldNode, true); // 导入节点及所有后代document.body.appendChild(newNode);\n\n\n由于每个节点都有一个ownerDocument属性，表示所属文档；如果调用appendChild()方法时传入节点的owerDocument不是指向当前文档，则会发生错误；而调用importNode()导入其他文档的节点会返回一个新节点，这个新节点的owerDocument属性时正确的。\n\nDOM2 View给Document类型增加了新属性defaultView，是一个指向拥有当前文档的窗口的指针。\n\n并没有明确视图何时可用，因此这是添加的唯一一个属性。\n可用于确定拥有文档的窗口。\n\n\n\nlet parentWindow = document.defaultView || document.parentWindow;\n\n\nDOM2 Core还针对document.implementation对象增加了两个新方法: createDocumentType ()和createDocument ()。\n\ncreateDocumentType：\n\n用于创建DocumentType类型的新节点；\n接收三个参数：文档类型名称、publicId和systemld。\ncreateDocumentType()只在创建新文档时才会用到。\n\n\ncreateDocument()：\n\n接收三个参数：文档元素的namespaceURI、文档元素的标签名和文档类型。\n\n\n要创建一个XHTML文档，可以使用以下代码：\nlet doctype = document.implementation.createDocumentType(&quot;html&quot;, &quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot;, &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;); let doc = document.implementation.createDocument(&quot;http://www.w3.org/1999/xhtml&quot;,  &quot;html&quot;, doctype); \nDOM2 HTML模块也为document.implamentation对象添加了createHTMLDocument()方法。\n\n方法可以创建一个完整的HTML文档，包含&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;元素。\n直接收一个参数：创建文档的标题（放到title元素中）\n返回一个新的HTML文档。\n\n\n\nlet htmldoc = document.implementation.createHTMLDocument(&quot;New Doc&quot;); console.log(htmldoc.title); // &quot;New Doc&quot; console.log(typeof htmldoc.body); // &quot;object&quot;\n\n3）Node的变化\nDOM3新增了两个用于比较节点的方法：isSameNode()和isEqualNode()。\n\n两个方法都接收一个参数：节点参数；\n返回值：如果这个节点与参考节点相同或相等，则返回true；反之返回false。\n节点相同，意味着引用同一个对象；\n节点相等，意味着节点类型相同，拥有相等的属性( nodeName、nodevalue等)，而且attributes和childNodes也相等(即同样的位置包含相等的值)。let div1 = document.createElement(&quot;div&quot;); div1.setAttribute(&quot;class&quot;, &quot;box&quot;); let div2 = document.createElement(&quot;div&quot;); div2.setAttribute(&quot;class&quot;, &quot;box&quot;); console.log(div1.isSameNode(div1)); // true console.log(div1.isEqualNode(div2)); // true console.log(div1.isSameNode(div2)); // false\n\n\nsetUserData()：\n\n给DOM节点附加额外数据的方法。\n接收三个参数：键、值、处理函数。document.body.setUserData(&quot;name&quot;, &quot;Nicholas&quot;, function() &#123;&#125;); \n\n\n处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行，可以在这时候决定如何处理用户数据。\n\n处理函数接收五个参数：表示操作类型的数值( 1代表复制，2代表导人，3代表删除，4代表重命名)、数据的键、数据的值、源节点和目标节点。\n\n删除节点时，源节点为null；除复制外，目标节点都为null。\nlet div = document.createElement(&quot;div&quot;); div.setUserData(&quot;name&quot;, &quot;Nicholas&quot;, function(operation, key, value, src, dest) &#123;     if (operation == 1) &#123;         dest.setUserData(key, value, function() &#123;&#125;);    &#125; &#125;); let newDiv = div.cloneNode(true); console.log(newDiv.getUserData(&quot;name&quot;)); // &quot;Nicholas&quot; /*这里先创建了一个&lt;div&gt;元素，然后给它添加了一-些数据，包含用户的名字。在使用cloneNode ()复制这个元素时，就会调用处理函数，从而将同样的数据再附加给复制得到的目标节点。然后，在副本节点上调用getUserData ()能够取得附加到源节点上的数据。*/\n\n4）内嵌窗格的变化\nDOM2 HTML给HTMLIFrameElement类型新增了一个属性：contentDocument。\ncontentDocument属性时Document的实例，拥有所有文档属性和方法\n\n\ncontentWindow属性返回相应窗格的window对象，这个对象上有一个document属性。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十三）事件（一）","url":"/2021/12/12/js-43/","content":"事件流\n事件流描述了页面接收事件的顺序。\n\n1、事件冒泡\nIE事件流被称为事件冒泡。\n事件被定义为从最具体的元素(文档树中最深的节点)开始触发，然后向上传播至没有那么具体的元素（文档)。\n\n\n如下页面结构：\n当点击页面中的div元素后，click事件会以如下顺序发生：\n&lt;div&gt;\n&lt;body&gt;\n&lt;html&gt;\ndocument&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;\n\n\n\n\n\n2、事件捕获\n由Netscape Communicator 团队提出。\n事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。\n事件捕获实际上是为了在事件到达最终目标前拦截事件。\n上面例子使用事件捕获，出发顺序如下：\ndocument\n&lt;html&gt;\n&lt;body&gt;\n&lt;div&gt;\n\n\n\n3、DOM事件流\nDOM2 Events规定事件流分为3个阶段：事件捕获、到达目标、事件冒泡。\n事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。\n\n\n\n\n在 DOM事件流中，实际的目标(&lt;div&gt;元素)在捕获阶段不会接收到事件。这是因为捕获阶段从document到&lt;html&gt;再到&lt;body&gt;就结束了。下一阶段，即会在&lt;div&gt;元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。\n\n事件处理程序\n为响应事件而调用的函数被称为事件处理程序。\n事件处理程序的名字以“on”开头。\n\n1、HTML事件处理程序\n特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。\n在 HTML 中定义的事件处理程序可以包含精确的动作指令也可以调用在页面其他地方定义的脚本。\n\n2、DOM0事件处理程序\n每个元素（包括window和 document)都有通常小写的事件处理程序属性。let btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function() &#123;     console.log(&quot;Clicked&quot;); &#125;; \n像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。\n\n3、DOM2事件处理程序\naddEventListener()和removeEventListener()：\n接收三个参数：事件名、事件处理函数和一个布尔值。true表示在捕获阶段调用事件处理程序；false（默认值）表示在冒泡阶段调用事件处理程序。\n\n\n\nlet btn = document.getElementById(&quot;myBtn&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; &#123;     console.log(this.id); &#125;, false);\n\n使用DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序。\nlet btn = document.getElementById(&quot;myBtn&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; &#123;     console.log(this.id); &#125;, false); btn.addEventListener(&quot;click&quot;, () =&gt; &#123;     console.log(&quot;Hello world!&quot;); &#125;, false); \n通过addEventListener()添加的事件处理程序只能使用removeEventListener()并传入与添加时同样的参数来移除。\n\n使用addEventListener()添加的匿名函数无法移除。\n\n\nlet btn = document.getElementById(&quot;myBtn&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; &#123;     console.log(this.id); &#125;, false); // 其他代码btn.removeEventListener(&quot;click&quot;, function() &#123; // 没有效果！    console.log(this.id); &#125;, false); \nlet btn = document.getElementById(&quot;myBtn&quot;); let handler = function() &#123;     console.log(this.id); &#125;; btn.addEventListener(&quot;click&quot;, handler, false); // 其他代码btn.removeEventListener(&quot;click&quot;, handler, false); // 有效果！\n\n4、IE事件处理程序\nattachEvent()和detachEvent()\n接收两个同样的参数：事件处理程序的名字和事件处理函数。\n\n\n\nvar btn = document.getElementById(&quot;myBtn&quot;); btn.attachEvent(&quot;onclick&quot;, function() &#123;     console.log(&quot;Clicked&quot;); &#125;);\n\n5、跨浏览器事件处理程序\naddHandler()和removeHandler()方法\n接收三个参数：目标元素、事件名和事件处理函数\n\n\n\n事件对象1、DOM事件对象\nevent对象是传给事件处理程序的唯一参数。\n\nlet btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function(event) &#123;     console.log(event.type); // &quot;click&quot; &#125;; btn.addEventListener(&quot;click&quot;, (event) =&gt; &#123;     console.log(event.type); // &quot;click&quot; &#125;, false);\n\n\n所有事件对象都会包含下表中的公共属性和方法：\n\n\n\n\n\n在事件处理程序内部，this对象始终等于currentTarget 的值，而target 只包含事件的实际目标。\n如果事件处理程序直接添加在了意图的目标，则this、currentTarget和 target的值是一样的。\n\nlet btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function(event) &#123;     console.log(event.currentTarget === this); // true     console.log(event.target === this); // true &#125;;\n\n\npreventDefault()方法用于阻止特定事件的默认动作。\n比如：链接的默认行为就是在被单击时导航到href属性指定的URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消。\n任何可以通过preventDefault()取消默认行为的事件，其事件对象的cancelable属性都会设置为true。\n\n\nstopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡。\neventPhase属性可以用于确定事件流当前所处的阶段。\n如果事件处理程序在捕获阶段被调用，则eventPhase等于1；\n如果事件处理程序在目标上被调用，则eventPhase等于2；\n如果事件处理程序在冒泡阶段被调用，则eventPhase等于3。\n虽然“到达目标”是在冒泡阶段发生的，但其eventPhase仍然等于2。\n\n\n\n2、IE事件对象\nIE事件对象可以基于事件处理程序被指定的方式以不同方式来访问。\n如果事件处理程序是使用DOM0方式指定的，则event对象只是window对象的一个属性。\n\n","categories":["前端学习笔记","JS","事件"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十五）动画与Canvas图形（一）","url":"/2021/12/14/js-45/","content":"使用requestAnimationFrame1、早期定时动画\n早期使用setInterval()控制动画的执行。\n存在的问题：\n无法准确知晓循环之间的延时。\n不能保证时间精度。\n\n\n\n(function() &#123;     function updateAnimations() &#123;         doAnimation1();         doAnimation2();         // 其他任务    &#125;     setInterval(updateAnimations, 100); &#125;)();\n\n2、requestAnimationFrame\nrequestAnimationFrame()\n\n方法接收一个参数：要在重绘屏幕前调用的函数。这个函数就是修改DOM样式以反映下一次重绘有什么变化的地方。\n为了实现动画循环，可以串联调用。function updateProgress() &#123;     var div = document.getElementById(&quot;status&quot;);     div.style.width = (parseInt(div.style.width, 10) + 5) + &quot;%&quot;;     if (div.style.left != &quot;100%&quot;) &#123;         requestAnimationFrame(updateProgress);     &#125; &#125; requestAnimationFrame(updateProgress);\n\n\n因为requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。\n\n传给requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimestamp 的实例(比如performance.now()返回的值)，表示下次重绘的时间。\n\n\n3、cancelAnimationFrame\n与setTimeout类似，requestAnimationFrame()返回一个请求ID；\ncancelAnimationFrame()来取消重绘任务。\n\nlet requestID = window.requestAnimationFrame(() =&gt; &#123;     console.log(&#x27;Repaint!&#x27;); &#125;); window.cancelAnimationFrame(requestID);\n\n4、通过requestAnimationFrame节流\n支持该方法的浏览器会暴露作为钩子的回调队列。\n钩子就是浏览器在执行下一次重绘前的一个点。\n通过requestAnimationFrame ()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。\n\n\n\n基本的画布功能\n创建&lt;canvas&gt;元素时至少需要width和height属性。\ngetContext()方法可以获取对绘图上下文的引用。\n对于平面图形，需要传入参数：2d。\n\n\ntoDataURL()方法可以导出&lt;canvas&gt;元素上的图像。\n方法接收一个参数：要生成图像的MIME类型。\n\n\n\nlet drawing = document.getElementById(&quot;drawing&quot;); // 确保浏览器支持&lt;canvas&gt; if (drawing.getContext) &#123;     let context = drawing.getContext(&quot;2d&quot;);     // 其他代码&#125;\n\n2D绘图上下文1、填充和描边\n两个属性：fillStyle和strokeStyle。\n可以是字符串】渐变对象或图案对象；\n默认值为”#000000”；\n字符串表示颜色值，可以是CSS支持的任意格式：名称、十六进制代码、rgb、rgba、hsl或hsla。\n\n\n\n2、绘制矩形\nfillRect()、strokeRect()、clearRect()：\n方法都接收4个参数：矩形x坐标、矩形y坐标、矩形宽度和矩形高度（单位均为像素）。\nfillRect()方法用于以指定颜色在画布上绘制并填充矩形；填充颜色使用fillStyle属性指定（实心矩形）。\nstrokeRect()方法可以通过strokeStyle属性指定的颜色绘制举行轮廓（绘制边框，内部空心）。\nclearRect()方法可以擦除画布中某个区域\n方法用于把绘图上下文种的某个区域变透明。\n\n\n\n\n\nlet drawing = document.getElementById(&quot;drawing&quot;); // 确保浏览器支持&lt;canvas&gt; if (drawing.getContext) &#123;     let context = drawing.getContext(&quot;2d&quot;);     /*     * 引自 MDN 文档    */     // 绘制红色矩形    context.fillStyle = &quot;#ff0000&quot;;     context.fillRect(10, 10, 50, 50);     // 绘制半透明蓝色矩形    context.fillStyle = &quot;rgba(0,0,255,0.5)&quot;;     context.fillRect(30, 30, 50, 50);     // 在前两个矩形重叠的区域擦除一个矩形区域    context.clearRect(40, 40, 10, 10); &#125; \n\n3、绘制路径\nbeginPath()方法是开始绘制新路径必须首先调用的方法。\n再用以下方法来绘制路径：\n\n\n\n\n创建路径之后，可以使用closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定fillstyle 属性并调用fill ()方法来填充路径，也可以指定strokeStyle 属性并调用stroke ()方法来描画路径，还可以调用clip()方法基于已有路径创建一 个新剪切区域。\nisPointInPath()方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用\n接收x轴和y轴坐标作为参数。\n\n\n\nlet drawing = document.getElementById(&quot;drawing&quot;); // 确保浏览器支持&lt;canvas&gt; if (drawing.getContext) &#123;     let context = drawing.getContext(&quot;2d&quot;);     // 创建路径    context.beginPath();     // 绘制外圆    context.arc(100, 100, 99, 0, 2 * Math.PI, false);     // 绘制内圆    context.moveTo(194, 100);     context.arc(100, 100, 94, 0, 2 * Math.PI, false);     // 绘制分针    context.moveTo(100, 100);     context.lineTo(100, 15);     // 绘制时针    context.moveTo(100, 100);     context.lineTo(35, 100);     // 描画路径    context.stroke(); &#125; \n\n\n\n4、绘制文本\nfillText()和strokeText()用于绘制文本。\n两个方法接收4个参数：字符串、x坐标、y坐标和可选的最大像素宽度。\nfillText()方法使用fillStyle属性绘制文本；\nstrokeText()方法使用strokeStyle属性；\n两个方法最终绘制的结果都取决于以下3个属性：\n\n\n\n\n\n\nmeasureText()方法\n接收一个参数：要绘制的文本；\n返回一个TextMetrics对象；\n使用font、textAlign和textBaseline属性当前的值计算绘制指定文本后的大小。\n\n\n\nlet fontSize = 100; context.font = fontSize + &quot;px Arial&quot;; while(context.measureText(&quot;Hello world!&quot;).width &gt; 140) &#123;  fontSize--;  context.font = fontSize + &quot;px Arial&quot;; &#125; context.fillText(&quot;Hello world!&quot;, 10, 10); context.fillText(&quot;Font size is &quot; + fontSize + &quot;px&quot;, 10, 50);\n\n5、变换\n以下方法可用于改变绘制上下文的变换矩阵：\n\n\n\n\n所有这些变换，包括fillstyle和strokestyle属性，会一直保留在上下文中，直到再次修改它们。\n\n6、绘制图像\ndrawImage()方法用于把现有图像绘制到画布上。\n方法可以接收3组不同的参数：  1、 传入HTML种img元素/canvas元素、绘制目标的x和y坐标；（直接绘制）  2、 传入HTML img元素、绘制目标的x、y坐标、目标宽度、目标高度；（可用于改变图像大小）  3、 要绘制的图像、源图像x坐标、源图像y坐标、源图像宽度、源图像高度、目标区域x坐标、目标区域y坐标、目标区域宽度、目标区域高度。（只把图像绘制到上下文中的一个区域）\n\n7、阴影\n2D上下文可以根据以下属性的值自动为已有形状或路径生成阴影：\n这些属性都可以通过context对象读写。\n\nlet context = drawing.getContext(&quot;2d&quot;); // 设置阴影context.shadowOffsetX = 5; context.shadowOffsetY = 5; context.shadowBlur = 4; context.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;; // 绘制红色矩形context.fillStyle = &quot;#ff0000&quot;; context.fillRect(10, 10, 50, 50); // 绘制蓝色矩形context.fillStyle = &quot;rgba(0,0,255,1)&quot;; context.fillRect(30, 30, 50, 50);\n\n8、渐变\n渐变通过CanvasGradient的实例表示，在2D上下文中创建和修改都非常简单。\ncreateLinearGradient()方法用于创建线性渐变。\n接收4个参数：起点x坐标、起点y坐标、终点x坐标和终点y坐标。\n调用之后,该方法会以指定大小创建一个新的CanvasGradient对象并返回实例。\n\n\naddColorStop()方法为渐变指定色标。\n方法接收两个参数：色标位置和CSS颜色字符串。\n色标位置通过0~1范围的值表示，0是第一种颜色，1是最后一种颜色。let gradient = context.createLinearGradient(30, 30, 70, 70); gradient.addColorStop(0, &quot;white&quot;); gradient.addColorStop(1, &quot;black&quot;);// 绘制红色矩形context.fillStyle = &quot;#ff0000&quot;; context.fillRect(10, 10, 50, 50); // 绘制渐变矩形context.fillStyle = gradient; context.fillRect(30, 30, 50, 50);\n\n\n\n9、图案\ncreatePattern()方法。\n接收两个参数：一个HTML&lt;img&gt;和一个表示该如何重复图像的字符串。\n第二个参数的值与CSS的background-repeat属性，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。\n第一个参数也可以是&lt;video&gt;元素或者另一个&lt;canvas&gt;元素。\n\n\n\nlet image = document.images[0],  pattern = context.createPattern(image, &quot;repeat&quot;); // 绘制矩形context.fillStyle = pattern; context.fillRect(10, 10, 150, 150); \n\n10、图像数据\ngetImageData()方法获取原始图像数据。\n方法接收4个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。\n返回的对象是一个ImageData的实例。每个对象都包含3个属性：\nwidth：图像宽；\nheight：图像高；\ndata：包含图像的原始像素信息的数组。每个data中的元素都由4个值表示，分别代表红、绿、蓝和透明度。\n\n\n\n\n\n11、合成\nglobalAlpha属性是一个范围在0~1的值(包括0和1),用于指定所有绘制内容的透明度，默认值为0。\nglobalCompositionOperation属性表示新绘制的形状如何与上下文中已有的形状融合。该属性为一个字符串，可以取下列值：\n\n","categories":["前端学习笔记","JS","Canvas"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十四）事件（二）","url":"/2021/12/12/js-44/","content":"事件类型1、用户界面事件1）load事件\n在window对象上，load事件会在整个页面（包括所有外部资源如图片、JavaScript文件和CSS文件)加载完成后触发。\n可以通过两种方式指定load事件处理程序：\nJavaScript方式；\n向&lt;body&gt;元素添加onload属性。\n\n\n\nwindow.addEventListener(&quot;load&quot;, (event) =&gt; &#123;     console.log(&quot;Loaded!&quot;); &#125;);\n&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;Load Event Example&lt;/title&gt; &lt;/head&gt;&lt;body onload=&quot;console.log(&#x27;Loaded!&#x27;)&quot;&gt; &lt;/body&gt; &lt;/html&gt;\n\n2）unload事件\n与load事件相对。\nunload事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。\n使用方法与load完全一样。\n\n3）resize事件\n当浏览器窗口被缩放到新高度或宽度是，会触发resize事件。\n事件在window上触发。\n\nwindow.addEventListener(&quot;resize&quot;, (event) =&gt; &#123;     console.log(&quot;Resized&quot;); &#125;); \n\n4）scroll事件\nscroll事件发生在window上，但实际上反映的是页面中相应元素的变化。\n\n2、焦点事件\n焦点事件在页面元素获得或失去焦点时触发。\n焦点事件有以下6种：\n\n\n\n\n当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件：\nfocuscout在失去焦点的元素上触发。\nfocusin在获得焦点的元素上触发。\nblur在失去焦点的元素上触发。\nDOMFocusOut在失去焦点的元素上触发。\nfocus在获得焦点的元素上触发。\nDOMFocusIn在获得焦点的元素上触发。\n\n\nblur、DOMF ocusOut和focusout的事件目标是失去焦点的元素；\nfocus、DOMFocusIn和focusin的事件目标是获得焦点的元素。\n\n3、鼠标和滚轮事件\nDOM3 Events定义了9种鼠标事件：\n\n\n\n\n\n页面中的所有元素都支持鼠标事件。\n除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。\n\n1）客户端坐标\n客户端坐标使用：event.clientX和event.clientY。\n\n2）页面坐标\n页面坐标使用：event.pageX和event.pageY。\n页面没有滚动时客户端与页面坐标对应相等。\n\n3）屏幕坐标\n客户端坐标使用：event.screenX和event.screenY。\n\n4）修饰键\n键盘上的修饰键：Shift、Ctrl、Alt、Meta。\nDOM规定4个属性表示修饰键状态：\nshiftKey、ctrlKey、altKey 和 metaKey。\n修饰键被按下时包含布尔值true，没有被按下时包含false。\n\n\n\n5）相关元素\n简单解释就是：事件发生存在与事件相关的其他元素。\n涉及到mouseover和mouseout两个事件。\n对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。\n对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。\n\n\nDOM通过event对象的relatedTarget属性提供了相关元素的信息。\n这个属性只有在mouseover和mouseout事件发生时才包含值，其他所有事件的这个属性的值都是 null。\n\n\n\n6）鼠标按键\n只有在元素上单击鼠标主键（或按下键盘上的回车键)时click 事件才会触发，因此按键信息并不是必需的。\n对mousedown 和 mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。\nDOM为这个button 属性定义了3个值:0表示鼠标主键、1表示鼠标中键（通常也是滚轮键)、2表示鼠标副键。\n\n7）额外事件信息\nDOM2 Events规范在event对象上提供了detail 属性，以给出关于事件的更多信息。\n对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少次单击。\n单击相当于在同一个像素上发生一次mousedown 紧跟一次mouseup。detail的值从1开始，每次单击会加1。\n如果鼠标在mousedown和mouseup之间移动了，则detail会重置为0。\n\n\n\n8）mousewheel事件\n事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。\n这个事件会在任何元素上触发,并(在IE8中）冒泡到document和(在所有现代浏览器中) window。\nmousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为 wheelDelta的新属性。\n当鼠标滚轮向前滚动时，wheelDelta每次都是+120；\n当鼠标滚轮向后滚动时，wheelDelta每次都是-120。\n\n\n可以为页面上的任何元素或文档添加onmousewheel 事件处理程序，以处理所有鼠标滚轮交互。document.addEventListener(&quot;mousewheel&quot;, (event) =&gt; &#123;     console.log(event.wheelDelta); &#125;);\n\n4、键盘与输入事件\n键盘事件包含 3 个事件：\nkeydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。\nkeypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了keypress事件，而推荐text Input事件。\nkeyup，用户释放键盘上某个键时触发。\n\n\n输入事件只有一个：textInput\n\n1）键码\n对于keydown和 keyup事件,event对象的keycode属性中会保存一个键码，对应键盘上特定的一个键。\n对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。\n\n\n\n\n2）字符编码\n浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。\n通常，charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。\n\n5、合成事件\n合成事件是DOM3 Events中新增的，用于处理通常使用IME输人时的复杂输入序列。\nIME可以让用户输入物理键盘上没有的字符。\n\n\n合成事件有以下3种：\ncompositionstart，在 IME的文本合成系统打开时触发，表示输入即将开始；\ncompositionupdate，在新字符插入输入字段时触发；\ncompositionend，在 IME的文本合成系统关闭时触发，表示恢复正常键盘输人。\n\n\n合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，其中包含的值视情况而异：\n在compositionstart事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换)；\n在compositionupdate事件中,包含要插人的新字符；\n在compositionend事件中，包含本次合成过程中输入的全部内容。\n\n\n\n6、变化事件\n已废弃\n\n7、HTML5事件1）contextmenu事件\n专门用于表示何时该显示上下文菜单。\n\n&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;ContextMenu Event Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt;    &lt;div id=&quot;myDiv&quot;&gt;Right click or Ctrl+click me to get a custom context menu. Click anywhere else to get the default context menu.&lt;/div&gt;     &lt;ul id=&quot;myMenu&quot; style=&quot;position:absolute;visibility:hidden;background-color:     silver&quot;&gt;     &lt;li&gt;&lt;a href=&quot;http://www.somewhere.com&quot;&gt; somewhere&lt;/a&gt;&lt;/li&gt;     &lt;li&gt;&lt;a href=&quot;http://www.wrox.com&quot;&gt;Wrox site&lt;/a&gt;&lt;/li&gt;     &lt;li&gt;&lt;a href=&quot;http://www.somewhere-else.com&quot;&gt;somewhere-else&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;\nwindow.addEventListener(&quot;load&quot;, (event) =&gt; &#123;     let div = document.getElementById(&quot;myDiv&quot;);     div.addEventListener(&quot;contextmenu&quot;, (event) =&gt; &#123;         event.preventDefault();         let menu = document.getElementById(&quot;myMenu&quot;);         menu.style.left = event.clientX + &quot;px&quot;;         menu.style.top = event.clientY + &quot;px&quot;;         menu.style.visibility = &quot;visible&quot;;     &#125;);     document.addEventListener(&quot;click&quot;, (event) =&gt; &#123;         document.getElementById(&quot;myMenu&quot;).style.visibility = &quot;hidden&quot;;     &#125;); &#125;);\n\n以上代码实现效果如下：这里在&lt;div&gt;元素上指定了一个oncontextmenu事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于event对象的clientx和clientY属性把&lt;ul&gt;元素放到适当位置。最后一步通过将visibility属性设置为”visible”让自定义上下文菜单显示出来。另外，又给document添加了一个onclick事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的)。\n\n\n\n\n当鼠标右键点击/ctrl+点击文字会发生以下变化：\n\n\n\n2）beforeunload事件\nbeforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。\n这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。\n这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。\n\n3）DOMContentLoaded事件\nDOMContentLoaded事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。\n相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。\n要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序：\n\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, (event) =&gt; &#123;     console.log(&quot;Content loaded&quot;); &#125;);\n\n4）readystatechange事件\nreadystatechange 事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。\n支持readystatechange 事件的每个对象都有一个readyState属性，该属性具有一个以下列出的可能的字符串值。\n\n5）pageshow与pagehide事件\n往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。\n这个缓存不仅存储页面数据，也存储 DOM 和JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。\npageshow，其会在页面显示时触发，无论是否来自往返缓存。\n在新加载的页面上，pageshow会在 load事件之后触发；\n在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。\n虽然这个事件的目标是document，但事件处理程序必须添加到window上。\npageshow 的 event 对象中还包含一个名为 persisted 的属性，这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。\n\n\npagehide与pageshow相对，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。\n\n6）hashchange事件\nHTML5增加了hashchange事件，用于在URL散列值(URL最后#后面的部分)发生变化时通知开发者。这是因为开发者经常在Ajax应用程序中使用URL 散列值存储状态信息或路由导航信息。\nonhashchange事件处理程序必须添加给window，每次URL散列值发生变化时会调用它。\nevent对象有两个新属性: oldURL 和newURL。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。\n\n8、设备事件\n设备事件可以用于确定用户使用设备的方式。\n\n1）orientationchange事件\n用于确定用户的设备是处于垂直模式还是水平模式。\n每当用户旋转设备改变了模式，就会触发orientationchange事件。\n可以从window.orientation 属性中获取有用的信息。\n\n2）deviceorientation\ndeviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。\n设备本身处于3D空间即拥有x轴、y轴和z轴的坐标系中。如果把设备静止放在水平的表面上,那么三轴的值均为0，其中，x轴方向为从设备左侧到右侧,y轴方向为从设备底部到上部、z轴方向为从设备背面到正面。\n\n\n\n\n当deviceorientation触发时，event对象中会包含各个轴相对于设备静置时坐标值的变化,主要是以下5个属性。\nalpha：0~360范围内的浮点值，表示围绕z轴旋转时y轴的度数(左右转)。\nbeta：-180~180范围内的浮点值，表示围绕x轴旋转时z轴的度数（前后转)。\ngamma：-90~90范围内的浮点值，表示围绕y轴旋转时z轴的度数（扭转)。\nabsolute：布尔值，表示设备是否返回绝对值。\ncompassCalibrated：布尔值，表示设备的指南针是否正确校准。\n\n\n\n\n\n3）devicemotion事件\nDeviceOrientationEvent规范也定义了devicemotion事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。\n当devicemotion事件触发时，event对象中包含如下额外的属性。\nacceleration：对象，包含x、y和z属性，反映不考虑重力情况下各个维度的加速信息。\naccelerationIncludingGravity：对象，包含x、y和z属性，反映各个维度的加速信息,包含z轴自然重力加速度。\ninterval：毫秒,距离下次触发devicemotion事件的时间。此值在事件之间应为常量。\nrotationRate：对象，包含alpha、beta和l gamma属性，表示设备朝向。\n\n\n\n","categories":["前端学习笔记","JS","事件"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十一）DOM2和DOM3（二）","url":"/2021/12/06/js-41/","content":"样式\nHTML样式有3种定义方法：外部样式表、文档样式表、元素特定样式。\n\n1、存取元素样式\n任何支持style属性的HTML元素在JavaScript中都会有一-个对应的style属性。\nstyle属性是cssstyleDeclaration类型的实例，其中包含通过HTML style属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。\nHTML style属性中的CSS属性在JavaScript style对象中都有对应的属性。\n因为CSS属性名使用连字符表示法（用连字符分隔两个单词，如background-image），所以在JavaScript中这些属性必须转换为驼峰大小写形式（如backgroundImage）。\n大多数属性名会这样直接转换过来。但有一个CSS属性名不能直接转换，它就是float。因为float是JavaScript的保留字，所以不能用作属性名。DOM2 Style 规定它在style对象中对应的属性应该是cssFloat。\n任何时候，只要获得了有效DOM元素的引用，就可以通过JavaScript来设置样式。\n通过style属性设置的值也可以通过style对象获取。\n\n1）DOM样式属性和方法\nDOM2 Style规范也在style对象上定义了一些属性和方法。这些属性和方法提供了元素style属性的信息并支持修改。\n\n\n\n\n属性\n解释\n\n\n\ncssText\n包含 style 属性中的 CSS 代码\n\n\nlength\n应用给元素的 CSS 属性数量\n\n\nparentRule\n表示 CSS 信息的 CSSRule 对象\n\n\ngetPropertyPriority(propertyName)\n如果 CSS 属性 propertyName 使用了!important则返回”important”，否则返回空字符串\n\n\ngetPropertyValue (propertyName)\n返回属性propertyName的字符串值\n\n\nitem(index)\n返回索引为index的CSS属性名\n\n\nremoveProperty (propertyName)\n从样式中删除CSS属性propertyName\n\n\nsetProperty (propertyName, value, priority)\n设置CSS属性propertyName的值为value, priority是” important”或空字符串\n\n\n2）计算样式\nDOM2 Style在document.defaultView上增加了getComputedstyle()方法。\n\n方法接收两个参数：要取得计算样式的元素和伪元素字符串（如”:after” ）。如果不需要查询伪元素，则第二个参数可以传null。\n方法返回一个cssstyleDeclaration对象（与style属性的类型一样 ），包含元素的计算样式。&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;Computed Styles Example&lt;/title&gt;     &lt;style type=&quot;text/css&quot;&gt;         #myDiv &#123;         background-color: blue;         width: 100px;         height: 200px;         &#125;     &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id=&quot;myDiv&quot; style=&quot;background-color: red; border: 1px solid black&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;\n\n\n这里的&lt;div&gt;元素从文档样式表（ &lt;style&gt;元素）和自己的style属性获取了样式。此时，这个元素的style对象中包含backgroundColor和border属性，但不包含（通过样式表规则应用的）width和height属性。下 面的代码从这个元素获取了计算样式:\nlet myDiv = document.getElementById(&quot;myDiv&quot;); let computedStyle = document.defaultView.getComputedStyle(myDiv, null); console.log(computedStyle.backgroundColor); // &quot;red&quot; console.log(computedStyle.width); // &quot;100px&quot; console.log(computedStyle.height); // &quot;200px&quot; console.log(computedStyle.border); // &quot;1px solid black&quot;（在某些浏览器中）\n 在所有浏览器中计算样式都是只读的，不能修改getComputeastyle()方法返回的对象。\n\n计算样式还包含浏览器内部样式表中的信息。\n\n\n2、操作样式表\nCSSStyleSheet类型表示CSS样式表，包括使用&lt;1ink&gt;元素和通过&lt;style&gt;元素定义的样式表。这两个元素本身分别是HTMLLinkElement和HTMLStyleElement。\nCSSStyleSheet类型是一个通用样式表类型，可以表示以任何方式在HTML中定义的样式表。\nCSSStylesheet类型的实例则是一个只读对象(只有一-个属性例外)。\nCSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。以下是CSSStyleSheet从StyleSheet继承的属性（除了disabled，其他属性对后市只读的）。\n\n\n\n\n属性\n解释\n\n\n\ndisabled\n布尔值，表示样式表是否被禁用了(这个属性是可读写的，因此将它设置为true会禁用样式表)\n\n\nhref\n如果是使用&lt;link&gt;包含的样式表，则返回样式表的URL，否则返回null\n\n\nmedia\n样式表支持的媒体类型集合，这个集合有一个length属性和一个item()方法，跟所有DOM集合一样。同样跟所有DOM集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表\n\n\nowmerNode\n指向拥有当前样式表的节点，在HTML中要么是&lt;1ink&gt;元素要么是&lt;sty1e&gt;元素(在XML中可以是处理指令)。如果当前样式表是通过@import被包含在另一个样式表中，则这个属性值为null。\n\n\nparentstylesheet\n如果当前样式表是通过@import被包含在另一个样式表中， 则这个属性指向导人它的样式表\n\n\ntitle\nownerNode 的title属性\n\n\ntype\n字符串，表示样式表的类型。对CSS样式表来说，就是”text/css”\n\n\n\nCSSStyleSheet类型还支持以下属性和方法：\n\n\n\n\n属性\n解释\n\n\n\ncssRules\n当前样式表包含的样式规则的集合\n\n\nownerRule\n如果样式表是使用@import导人的，则指向导人规则；否则为null。\n\n\ndeleteRule(index)\n在指定位置删除cssRules中的规则\n\n\ninsertRule(rule, index)\n在指定位置向cssRules中插人规则\n\n\n1）CSS规则\nCSSRule类型表示样式表中的一条规则。\n这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的cssstyleRule (其他CSS规则还有@import、@font-face、@page和@charset等，不过这些规则很少需要使用脚本来操作)。\nCSSStyleRule对象上的可用属性：\ncssText：返回整条规则的文本。这里的文本可能与样式表中实际的文本不-样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。\nparentRule：如果这条规则被其他规则(如@media)包含，则指向包含规则，否则就是null。\nparentStyleSheet：包含当前规则的样式表。\nselectorText：返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在Firefox、Safari 、Chrome和IE中是只读的，在Opera中是可以修改的。\nstyle：返回cssstyleDeclaration对象，可以设置和获取当前规则中的样式。\ntype：数值常量，表示规则类型。对于样式规则，它始终为1。\n\n\n\ndiv.box &#123;     background-color: blue;     width: 100px;     height: 200px; &#125; \n\n假设这条规则位于页面中的第一个样式表中，而且是该样式表中唯一一条 CSS规则，则下列代码可以获取它的所有信息:\n\nlet sheet = document.styleSheets[0]; let rules = sheet.cssRules || sheet.rules; // 取得规则集合let rule = rules[0]; // 取得第一条规则console.log(rule.selectorText); // &quot;div.box&quot; console.log(rule.style.cssText); // 完整的 CSS 代码console.log(rule.style.backgroundColor); // &quot;blue&quot; console.log(rule.style.width); // &quot;100px&quot; console.log(rule.style.height); // &quot;200px&quot; \n\n2）创建规则\n可以使用insertRule()方法向样式表中添加规则。\n方法接收两个参数：规则的文本和表示插入位置的索引值。sheet.insertRule(&quot;body &#123; background-color: silver &#125;&quot;, 0); // 使用 DOM 方法\n\n\n\n3）删除规则\ndeleteRule()方法支持从样式表中删除规则。\n接受一个参数：要删除规则的索引。\n\n\n\n3、元素尺寸1）偏移尺寸\n元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框(但不包含外边距)。\n以下4个属性用于取得元素的偏移尺寸：\noffsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度(如果可见)和上、下边框的高度。\noffsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。\noffsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。\noffsetwidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。\n\n\n其中，offsetLeft和 offsetTop是相对于包含元素的，包含元素保存在offsetParent属性中。offsetParent不一定是parentNode。\n\n\n\n2）客户端尺寸\n元素的客户端尺寸( client dimensions)包含元素内容及其内边距所占用的空间。\n客户端尺寸只有两个相关属性:clientwidth和 clientHeight。\nclientwidth是内容区宽度加左、右内边距宽度，\nclientHeight是内容区高度加上、下内边距高度。\n\n\n客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。\n这两个属性最常用于确定浏览器视口尺寸,即检测document. documentElement的clientwidth和clientHeight。这两个属性表示视口(&lt;html&gt;或&lt;body&gt;元素)的尺寸。\n\n\n\n3）滚动尺寸\n滚动尺寸( scroll dimensions)，提供了元素内容滚动距离的信息。\n有些元素，比如&lt;html&gt;无须任何代码就可以自动滚动，而其他元素则需要使用CSS的overflow属性令其滚动。\n滚动尺寸相关的属性有如下4个：\nscrollHeight：没有滚动条出现时，元素内容的总高度。\nscrollLeft：内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。\nscrollTop：内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。\nscrollwidth：没有滚动条出现时，元素内容的总宽度。\n\n\n\n\n\n\nscrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。\nscrollWidth和 scrollHeight 与clientwidth和clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollwidth和 scollHeight等于文档内容的宽度，而clientwidth和clientHeight 等于视口的大小。\nscrollLeft和 scrollTop属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于0。如果元素在垂直方向上滚动，则scrollTop 会大于0，表示元素顶部不可见区域的高度。如果元素在水平方向上滚动,则scrollLeft会大于0，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的,所以把它们都设置为О就可以重置元素的滚动位置。\n\n4）确定元素尺寸\n浏览器在每个元素上都暴露了getBoundingclientRect ()方法，返回一个DOMRect对象，包含6个属性:left、 top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视口的位置。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（三十六）DOM（三）","url":"/2021/11/29/js-36/","content":"MutationObserver接口\nMutationObserver接口，可以在DOM被修改时异步执行回调。\nMutati onObserver可以观察整个文档、DOM树的一部分， 或某个元素。此外还可以观察元素属性、子节点、文本，或者前ʻ者任意组合的变化。\n\n基本用法\nMutationObserver的实例要通过调用MutationObserver构造函数并传人一个回调函数来创建。let observer = new MutationObserver(() =&gt; console.log(&#x27;DOM was mutated!&#x27;)); \n\n1、observe方法\n新创建的MutationObserver实例不会关联DOM的任何部分。要把这个observer与DOM关联起来，需要使用observe()方法。\n方法接收两个必需的参数：要观察其变化的DOM节点和一个MutationObserverInit对象。\nMutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;); /*执行以上代码后，&lt;body&gt;元素上任何属性发生变化都会被这个MutationObserver实例发现，然后就会异步执行注册的回调函数。&lt;body&gt;元素后代的修改或其他非属性修改都不会触发回调进入任务队列。*///通过以下代码来验证let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.className = &#x27;foo&#x27;; console.log(&#x27;Changed body class&#x27;); // Changed body class // &lt;body&gt; attributes changed\n\n\n\n2、回调与MutationRecord\n每个回调都会收到一个MutationRecord实例的数组。\nMutationRecord实例包含的信息包括发生了什么变化，以及DOM的哪一部分受到了影响。\n因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的MutationRecord实例的数组。\n\n//反映一个属性变化的 MutationRecord 实例的数组let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords));observer.observe(document.body, &#123; attributes: true &#125;); document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // [     // &#123;         // addedNodes: NodeList [],         // attributeName: &quot;foo&quot;,         // attributeNamespace: null,         // nextSibling: null,         // oldValue: null,         // previousSibling: null         // removedNodes: NodeList [],         // target: body         // type: &quot;attributes&quot;     // &#125; // ] \n\n//一次涉及命名ቆ间的类似变化let observer = new MutationObserver(  (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.setAttributeNS(&#x27;baz&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;); // [     // &#123;         // addedNodes: NodeList [],         // attributeName: &quot;foo&quot;,         // attributeNamespace: &quot;baz&quot;,         // nextSibling: null,         // oldValue: null,         // previousSibling: null         // removedNodes: NodeList [],         // target: body         // type: &quot;attributes&quot;     // &#125; // ] \n/*连续修改会生成多个Mutati onRecord实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序:*/let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.className = &#x27;foo&#x27;; document.body.className = &#x27;bar&#x27;; document.body.className = &#x27;baz&#x27;; // [MutationRecord, MutationRecord, MutationRecord]\n\n\nMutationRecord实例的属性：\n\n\n\n\n\n传给回调函数的第二个参数是观察变化的 MutationObserver 的实例。\n\nlet observer = new MutationObserver( (mutationRecords, mutationObserver) =&gt; console.log(mutationRecords,mutationObserver)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.className = &#x27;foo&#x27;; // [MutationRecord], MutationObserver \n\n3、disconnect()方法\n默认情况下，只要被观察的元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，从而被执行。\ndisconnect()方法可以用来提前终止执行回调。\n不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调。\n\n\n\nlet observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.className = &#x27;foo&#x27;; observer.disconnect(); document.body.className = &#x27;bar&#x27;; //（没有日志输出）\n\n要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用disconnect()。\n\nlet observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;);document.body.className = &#x27;foo&#x27;; setTimeout(() =&gt; &#123;     observer.disconnect();     document.body.className = &#x27;bar&#x27;; &#125;, 0); // &lt;body&gt; attributes changed\n\n4、复用MutationObserver\n多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。\nMutationRecord 的 target 属性可以标识发生变化事件的目标节点。\ndisconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标。\n\nlet observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.target))); // 向页面主体添加两个子节点let childA = document.createElement(&#x27;div&#x27;),  childB = document.createElement(&#x27;span&#x27;); document.body.appendChild(childA); document.body.appendChild(childB); // 观察两个子节点observer.observe(childA, &#123; attributes: true &#125;); observer.observe(childB, &#123; attributes: true &#125;); // 修改两个子节点的属性childA.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); childB.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // [&lt;div&gt;, &lt;span&gt;] \nlet observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.target))); // 向页面主体添加两个子节点let childA = document.createElement(&#x27;div&#x27;),  childB = document.createElement(&#x27;span&#x27;); document.body.appendChild(childA); document.body.appendChild(childB); // 观察两个子节点observer.observe(childA, &#123; attributes: true &#125;); observer.observe(childB, &#123; attributes: true &#125;); observer.disconnect(); // 修改两个子节点的属性childA.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); childB.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // （没有日志输出）\n\n5、重用MutationObserver\n调用disconnect()并不会结束MutationObserver的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。\n下面的示例在两个连续的异步块中先断开然后又恢复了观察者与&lt;body&gt;元素的关联：let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;)); observer.observe(document.body, &#123; attributes: true &#125;); // 这行代码会触发变化事件document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); setTimeout(() =&gt; &#123;     observer.disconnect();     // 这行代码不会触发变化事件    document.body.setAttribute(&#x27;bar&#x27;, &#x27;baz&#x27;); &#125;, 0); setTimeout(() =&gt; &#123;     // Reattach     observer.observe(document.body, &#123; attributes: true &#125;);     // 这行代码会触发变化事件    document.body.setAttribute(&#x27;baz&#x27;, &#x27;qux&#x27;); &#125;, 0); // &lt;body&gt; attributes changed // &lt;body&gt; attributes changed \n\nMutationObserverInit与观察范围\nMutationObserverInit 对象用于控制对目标节点的观察范围。\n粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。\n下表列出了 MutationObserverInit 对象的属性：\n\n在调用observe()时，MutationObserverInit 对象中的attribute、characterData和childList属性必须至少有一项为true（无论是直接设置这几个属性，还是通过设置attributeOldvalue等属性间接导致它们的值转换为true）。否则会抛出错误，因为没有任何变化事件可能触发回调。\n\n1、观察属性\nMutationObserver可以观察节点属性的添加、移除和修改。\n要为属性变化注册回调，需要在MutationObserverInit对象中将attributes属性设置为true。\n\nlet observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributes: true &#125;); // 添加属性 document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // 修改属性document.body.setAttribute(&#x27;foo&#x27;, &#x27;baz&#x27;); // 移除属性document.body.removeAttribute(&#x27;foo&#x27;); // 以上变化都被记录下来了// [MutationRecord, MutationRecord, MutationRecord] \n\n\n\n把attributes设置为true的默认行为是观察所有属性，但不会在MutationRecord对象中记录原来的属性值。\n如果想观察某个或某几个属性，可以使用attributeFilter属性来设置白名单，即一个属性名字符串数组；\n\nlet observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributeFilter: [&#x27;foo&#x27;] &#125;); // 添加白名单属性document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // 添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;, &#x27;qux&#x27;);// 只有 foo 属性的变化被记录了// [MutationRecord] \n\n\n如果想在变化记录中保存属性原来的值，可以将attributeOldValue属性设置为true。\n\nlet observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue))); observer.observe(document.body, &#123; attributeOldValue: true &#125;); document.body.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); document.body.setAttribute(&#x27;foo&#x27;, &#x27;baz&#x27;); document.body.setAttribute(&#x27;foo&#x27;, &#x27;qux&#x27;); // 每次变化都保留了上一次的值// [null, &#x27;bar&#x27;, &#x27;baz&#x27;] \n\n2、观察字符数据\nMutationObserver 可以观察文本节点(如 Text、 Comment或ProcessingInstruction节点)中字符的添加、删除和修改。\n要为字符数据注册回调，需要在MutationObserverInit对象中将characterData 属性设置为true。let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); // 创建要观察的文本节点document.body.firstChild.textContent = &#x27;foo&#x27;; observer.observe(document.body.firstChild, &#123; characterData: true &#125;); // 赋值为相同的字符串document.body.firstChild.textContent = &#x27;foo&#x27;; // 赋值为新字符串document.body.firstChild.textContent = &#x27;bar&#x27;; // 通过节点设置函数赋值document.body.firstChild.textContent = &#x27;baz&#x27;; // 以上变化都被记录下来了// [MutationRecord, MutationRecord, MutationRecord] \n将characterData属性设置为true的默认行为不会在MutationRecord对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据,可以将characterData0ldValue属性设置为true。\n\nlet observer = new MutationObserver(  (mutationRecords) =&gt; console.log(mutationRecords.map((x) =&gt; x.oldValue))); document.body.innerText = &#x27;foo&#x27;; observer.observe(document.body.firstChild, &#123; characterDataOldValue: true &#125;); document.body.innerText = &#x27;foo&#x27;; document.body.innerText = &#x27;bar&#x27;; document.body.firstChild.textContent = &#x27;baz&#x27;; // 每次变化都保留了上一次的值// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;] \n\n3、观察子节点\nMutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在Mutation-ObserverInit对象中将childList属性设置为true。//1、下面的例子演示了添加子节点：// 清空主体document.body.innerHTML = &#x27;&#x27;; let observer = new MutationObserver(  (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; childList: true &#125;); document.body.appendChild(document.createElement(&#x27;div&#x27;)); // [     // &#123;         // addedNodes: NodeList[div],         // attributeName: null,         // attributeNamespace: null,         // oldValue: null,         // nextSibling: null,         // previousSibling: null,         // removedNodes: NodeList[],         // target: body,         // type: &quot;childList&quot;,     // &#125; // ]//2、下面的例子演示了移除子节点：// 清空主体document.body.innerHTML = &#x27;&#x27;; let observer = new MutationObserver(  (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; childList: true &#125;); document.body.appendChild(document.createElement(&#x27;div&#x27;)); // [     // &#123;         // addedNodes: NodeList[],         // attributeName: null,         // attributeNamespace: null,         // oldValue: null,         // nextSibling: null,         // previousSibling: null,         // removedNodes: NodeList[div],         // target: body,         // type: &quot;childList&quot;,     // &#125; // ] \n对子节点重新排序（尽管调用一个方法即可实现)会报告两次变化事件,因为从技术上会涉及先移除和再添加。\n\n// 清空主体document.body.innerHTML = &#x27;&#x27;; let observer = new MutationObserver(  (mutationRecords) =&gt; console.log(mutationRecords)); // 创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;)); document.body.appendChild(document.createElement(&#x27;span&#x27;)); observer.observe(document.body, &#123; childList: true &#125;); // 交换子节点顺序document.body.insertBefore(document.body.lastChild, document.body.firstChild); // 发生了两次变化：第一次是节点被移除，第二次是节点被添加// [     // &#123;         // addedNodes: NodeList[],         // attributeName: null,         // attributeNamespace: null,         // oldValue: null,         // nextSibling: null,         // previousSibling: div,         // removedNodes: NodeList[span],         // target: body,         // type: childList,     // &#125;,     // &#123;         // addedNodes: NodeList[span],         // attributeName: null,         // attributeNamespace: null,         // oldValue: null,         // nextSibling: div,         // previousSibling: null,         // removedNodes: NodeList[],         // target: body,         // type: &quot;childList&quot;,     // &#125; // ]\n\n4、观察子树\n默认情况下，MutationObserver 将观察的范围限定为一个元素及其子节点的变化。\n可以把观察的范围扩展到这个元素的子树(所有后代节点),这需要在MutationObserverInit对象中将subtree属性设置为true。\n\n// 清空主体document.body.innerHTML = &#x27;&#x27;; let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); // 创建一个后代document.body.appendChild(document.createElement(&#x27;div&#x27;));// 观察&lt;body&gt;元素及其子树observer.observe(document.body, &#123; attributes: true, subtree: true &#125;); // 修改&lt;body&gt;元素的子树document.body.firstChild.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // 记录了子树变化的事件// [     // &#123;         // addedNodes: NodeList[],         // attributeName: &quot;foo&quot;,         // attributeNamespace: null,         // oldValue: null,         // nextSibling: null,         // previousSibling: null,         // removedNodes: NodeList[],         // target: div,         // type: &quot;attributes&quot;,     // &#125; // ]\n\n被观察子树中的节点被移出子树之后仍然能够触发变化事件。\n在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。\n\n// 清空主体document.body.innerHTML = &#x27;&#x27;; let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); let subtreeRoot = document.createElement(&#x27;div&#x27;),  subtreeLeaf = document.createElement(&#x27;span&#x27;); // 创建包含两层的子树document.body.appendChild(subtreeRoot); subtreeRoot.appendChild(subtreeLeaf); // 观察子树observer.observe(subtreeRoot, &#123; attributes: true, subtree: true &#125;); // 把节点转移到其他子树document.body.insertBefore(subtreeLeaf, subtreeRoot); subtreeLeaf.setAttribute(&#x27;foo&#x27;, &#x27;bar&#x27;); // 移出的节点仍然触发变化事件// [MutationRecord] \n\n异步回调与记录队列\nMutationObserver接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。\n为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在MutationRecord实例中，然后添加到记录队列。\n这个队列对每个MutationObserver实例都是唯一的，是所有 DOM变化事件的有序列表。\n\n1、记录队列\n每次MutationRecord被添加到MutationObserver的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为0），才会将观察者注册的回调（在初始化Mutation0bserver时传入）作为微任务调度到任务队列上。\n不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些MutationRecord就用不着了，因此记录队列会被清空，其内容会被丢弃。\n\n2、takeRecords()方法\n调用MutationObserver实例的takeRecords()方法可以清空记录队列，取出并返回其中的所有MutationRecord实例。let observer = new MutationObserver( (mutationRecords) =&gt; console.log(mutationRecords)); observer.observe(document.body, &#123; attributes: true &#125;); document.body.className = &#x27;foo&#x27;; document.body.className = &#x27;bar&#x27;; document.body.className = &#x27;baz&#x27;; console.log(observer.takeRecords()); console.log(observer.takeRecords()); // [MutationRecord, MutationRecord, MutationRecord] // []\n\n性能、内存与垃圾回收\nDOM Level 2规范中描述的MutationEvent定义了一组会在各种DOM变化时触发的事件。\n由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3规定废弃了这些事件。Mutationobserver接口就是为替代这些事件而设计的更实用、性能更好的方案。\n将变化回调委托给微任务来执行可以保证事件同步触发,同时避免随之而来的混乱。\n为MutationObserver而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。无论如何，使用Mutationobserver仍然不是没有代价的。\n\n1、MutationObserver的引用\nMutationobserver实例与目标节点之间的引用关系是非对称的。\nMutationObserver拥有对要观察的目标节点的弱引用。因为是弱引用,所以不会妨碍垃圾回收程序回收目标节点。\n目标节点拥有对 Mutationobserver 的强引用。如果目标节点从 DOM中被移除，随后被垃圾回收,则关联的MutationObserver也会被垃圾回收。\n\n2、MutationRecord的引用\n记录队列中的每个MutationRecord 实例至少包含对已有 DOM节点的一个引用。\n如果变化是childList类型，则会包含多个节点的引用。\n记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecora，然后让它们超出作用域并被垃圾回收。\n有时候可能需要保存某个观察者的完整变化记录。保存这些MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。\n如果需要尽快地释放内存，建议从每个MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃MutationRecord。\n\n","categories":["前端学习笔记","JS","DOM"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十六）动画与Canvas图形（二）","url":"/2021/12/20/js-46/","content":"WebGL1、WebGL上下文\n在完全支持的浏览器中：\n**WebGL 2.0上下文的名字叫” webgl2”**；\n**WebGL 1.0上下文的名字叫” webgl1”**。\n\n\n检测浏览器是否支持WebGL：\n\nlet drawing = document.getElementById(&quot;drawing&quot;); // 确保浏览器支持&lt;canvas&gt; if (drawing.getContext) &#123;     let gl = drawing.getContext(&quot;webgl&quot;);     if (gl)&#123;         // 使用 WebGL     &#125; &#125; \n\n2、WebGL基础\n可以在调用getContext ()取得WebGL上下文时指定一些选项。这些选项通过一个参数对象传入，选项就是参数对象的一个或多个属性。\n\n\n\nlet drawing = document.getElementById(&quot;drawing&quot;); // 确保浏览器支持&lt;canvas&gt; if (drawing.getContext) &#123;     let gl = drawing.getContext(&quot;webgl&quot;, &#123; alpha: false &#125;);     if (gl) &#123;         // 使用 WebGL     &#125; &#125; \n\n1）常量\n常量在OpenGL中的名字以GL_开头。在WebGL 中，context对象上的常量则不包含GL_前缀。\n\n2）方法命名\n接收不同类型和不同数量参数的方法，会通过方法名的后缀体现这些信息。\n表示参数数量的数字(1~4)在先，表示数据类型的字符串(“f”表示浮点数,”i”表示整数)在后，还有很多方法接收数组，这类方法用字母“v”(vector )来表示。\n比如，gl.uniform4f()的意思是需要4个浮点数值参数，gl.uniform3iv()就是要接收一个包含3个值的数组参数。\n\n3）准备绘图\n准备使用WebGL上下文之前，通常需要先指定一种实心颜色清除&lt;canvas&gt;。为此，要调用clearcolor()方法并传入4个参数，分别表示红、绿、蓝和透明度值。每个参数必须是0~1范围内的值,表示各个组件在最终颜色的强度。\n\ngl.clearColor(0, 0, 0, 1); // 黑色gl.clear(gl.COLOR_BUFFER_BIT); \n\n4）视口与坐标\n绘图前还要定义WebGL 视口。默认情况下，视口使用整个&lt;canvas&gt;区域。\n要改变视口，可以调用viewport()方法并传入视口相对于&lt;canvas&gt;元素的x、y坐标及宽度和高度。\n\ngl.viewport(0, 0, drawing.width,drawing.height);\n\n\n这个视口的坐标系统与网页中通常的坐标系统不一样。视口的x和y坐标起点(0,0)表示&lt;canvas&gt;元素的左下角，向上、向右增长可以用点(width-1, height-1)定义。\n\n\n\n// 视口是&lt;canvas&gt; 左下角四分之一区域gl.viewport(0, 0, drawing.width/2, drawing.height/2); // 视口是&lt;canvas&gt; 左上角四分之一区域gl.viewport(0, drawing.height/2, drawing.width/2, drawing.height/2); // 视口是&lt;canvas&gt; 右下角四分之一区域gl.viewport(drawing.width/2, 0, drawing.width/2, d\n\n5）缓冲区\ngl.createBuffer()方法用于创建缓冲区。\ngl.bindBuffer()方法用于将缓冲区绑定到WebGL上下文。绑定后就可以用数据填充缓冲区了。\n\nlet buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);//初始化buffergl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0.5, 1]), gl.STATIC_DRAW); \n\n\ndrawElements()方法同时传入gl.ELEMENT_ARRAY_BUFFER可用于输出缓冲区内容。\ngl.bufferData()方法的最后一个参数表示如何使用缓冲区。这个参数可以是以下常量值。\n\n\n\n6）错误\ngl.getError()方法\n方法返回一个常量，表示发生的错误类型，下面列出了这些常量：\n\n\n\n\n\n\n每次调用gl.getError()方法会返回一个错误值。第一次调用之后，再调用gl.getError ()可能会返回另一个错误值。如果有多个错误，则可以重复这个过程，直到 gl.getError ()返回gl.NO_ERROR。\n\n7）着色器\nWebGL 中有两种着色器：顶点着色器和片段(或像素)着色器。\n顶点着色器用于把3D顶点转换为可以渲染的2D点。\n片段着色器用于计算绘制一个像素的正确颜色。\n\n\nWebGL着色器的独特之处在于，它们不是JavaScript实现的，而是使用一种与C或JavaScript完全不同的语言GLSL ( OpenGL Shading Language)写的。\n\n8）绘图\nWebGL只能绘制三种形状：点、线和三角形。\ndrawArrays()方法：使用数组缓冲区\n接收三个参数：常量、数组缓冲区起点索引、数组缓冲区包含的顶点集合的数量。\n\n\ndrawElements()操作元素数组缓冲区。\n\n\n\n9）纹理\ngl.createTexture()方法创建新的纹理，然后将图片绑定到这个纹理。\n如果图片还没有加载，则可以创建一个 Image对象来动态加载。图片加载完成后才能初始化纹理,因此在图片的load事件之后才能使用纹理。\n\nlet image = new Image(),     texture; image.src = &quot;smile.gif&quot;; image.onload = function() &#123;     texture = gl.createTexture();     gl.bindTexture(gl.TEXTURE_2D, texture);     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);     // 除当前纹理    gl.bindTexture(gl.TEXTURE_2D, null); &#125;\n\n10）读取像素\nreadPixels()方法。\n参数包括：x、y坐标、宽度、高度、图像格式、类型和定型数组。\n\n\n\nlet pixels = new Uint8Array(25*25); gl.readPixels(0, 0, 25, 25, gl.RGBA, gl.UNSIGNED_BYTE, pixels);","categories":["前端学习笔记","JS","WebGL"],"tags":["JS学习"]},{"title":"CSS学习笔记（一）背景与边框（一）","url":"/2021/12/30/css-1/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        body &#123;            background: rgb(78, 78, 85);        &#125;        #pic&#123;            width: 300px;            height: 200px;            position: absolute;            top: 100px;            left: 100px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pic&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n一、半透明边框\n假设给一个容器设置一层白色背景和一道半透明的边框。body的背景会从它的半透明边框透上来。\n\n该代码会得到以下效果：\n\n\n#pic&#123;    width: 500px;    height: 250px;    border: 10px solid hsla(0,0%,100%,.5);    background: white;    background-clip: padding-box;&#125;\n\n\n\n\n通过background-clip属性来指定背景绘制区域。\nbackground-clip属性默认值为border-box：背景绘制在边框方框内。\npadding-box：将背景绘制在衬距方框内。\n\n\n\n二、多重边框1、box-shadow方案\n利用box-shadow的第四个参数指定正值或负值来让投影面积加大或减小。\n\n#pic&#123;    background: yellowgreen;    box-shadow: 0 0 0 10px #655;&#125;\n\n\n\n\nbox-shadow支持逗号分隔语法，可以创建任意数量的投影。\nbox-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。\n\n#pic&#123;    background: yellowgreen;    box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;&#125;\n\n\n\n2、outline方案\n用于设置两层边框：先设置一层常规边框，再加上outline属性来产生外层的边框。\n优点：在于边框样式十分灵活，不像box-shadow方案只能模拟实线边框。\n以下代码也可以实现上图效果。\n\n#pic&#123;    background: yellowgreen;    border: 10px solid #655;    outline: 5px solid deeppink;&#125;\n\n三、灵活的背景定位\n难题：\n针对某个角对背景图片做偏移定位。\n在CSS 2.1中，我们只能指定距离左上角的偏移量，或者干脆完全靠齐到其他三个角。如下图：\n\n\n\n\n\n1、background-position的扩展语法方案\nbackground-position属性得到扩展：\n允许我们指定背景图片距离任意角的偏移量；\n只需要在偏移量前面指定关键字。\n\n\n\n#pic&#123;    background: url(code-pirate.svg) no-repeat #58a;    background-position: right 20px bottom 10px;&#125;\n\n\n\n在不支持background-position扩展语法的浏览器中，背景图片会紧贴在左上角（背景图片的默认位置）。\n提供一个回退方案也很简单，就是把老套的bottom right 定位值写进 background 的简写属性中\n\n#pic&#123;    background: url(code-pirate.svg)                no-repeat bottom right #58a;    background-position: right 20px bottom 10px;&#125;\n\n\n默认情况下，background-position是以padding box为准，这样边框才不会遮住背景图片。\n\n2、background-origin方案\nbackground-origin默认情况下，它的值是padding-box。\n如果把它的值改成 content-box ，我们在 background-position 属性中使用的边角关键字将会以内容区的边缘作为基准。\n\n#pic&#123;    background: url(code-pirate.svg)                no-repeat bottom right #58a;    background-position: right 20px bottom 10px;&#125;\n\n\n视觉效果同上。\n\n3、calc()方案\n如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。\ncalc()函数允许我们执行此类运算，它可以完美地在background-position 属性中使用。\n\n#pic&#123;    background: url(&quot;code-pirate.svg&quot;) no-repeat;    background-position: calc(100% - 20px) calc(100% - 10px);&#125;\n\n四、边框内圆角\n有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如图下所示。这是一个有趣的效果，目前还没有被滥用。\n\n\n\n\n用两个元素可以实现这个效果，这并没有什么特别的。\n\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（二）背景与边框（二）","url":"/2022/01/03/css-2/","content":"五、条纹背景难题\n不论是在网页设计中，还是在其他传统媒介中（比如杂志和墙纸等），各种尺寸、颜色、角度的条纹图案在视觉设计中无处不在。\n要想在网页中实现条纹图案，其过程还远远不够理想。通常，我们的方法是创建一个单独的位图文件，然后每次需要做些调整时，都用图像编辑器来修改它。\n可能有人试过用 SVG 来取代位图，但这样还是会有一个独立的文件，而且它的语法也远远不够友好。\n如果可以直接在 CSS 中创建条纹图案，那该有多棒啊！你可能会惊讶地发现，我们居然真的可以。\n\n解决方案\n假设我们有一条基本的垂直线性渐变，颜色从 #fb3 过渡到 #58a。\n\ndiv&#123;    background: linear-gradient(#fb3, #58a);&#125;\n\n\n\n\n现在，让我们试着把这两个色标拉近一点。\n\ndiv&#123;    background: linear-gradient(#fb3 20%, #58a 80%);&#125;\n\n\n\n\n现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被填充为 #58a 实色。真正的渐变只出现在容器 60% 的高度区域。\n如果我们把两个色标继续拉近（分别改为 40% 和 60%），那真正的渐变区域就变得更窄了。\n如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程。\n\ndiv&#123;    background: linear-gradient(#fb3 50%, #58a 50%);&#125;\n\n\n因为渐变是一种由代码生成的图像，我们能像对待其他任何背景图像那样对待它，而且还可以通过 background-size 来调整其尺寸。\n\ndiv&#123;    background: linear-gradient(#fb3 50%, #58a 50%);    background-size: 100% 30px;&#125;\n\n\n\n\n我们还可以用相同的方法来创建不等宽的条纹，只需调整色标的位置值即可。\n\ndiv&#123;    background: linear-gradient(#fb3 30%, #58a 30%);    background-size: 100% 30px;&#125;\n\n\n\n\n为了避免每次改动条纹宽度时都要修改两个数字，我们可以再次从规范那里找到捷径。\n如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。\n\n\n\ndiv&#123;    background: linear-gradient(#fb3 30%, #58a 0);    background-size: 100% 30px;&#125;\n\n\n如果要创建超过两种颜色的条纹，也是很容易的。\n\ndiv&#123;    background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);    background-size: 100% 45px;&#125;\n\n\n\n垂直条纹\n垂直条纹的代码跟水平条纹几乎是一样的，差别主要在于：我们需要在开头加上一个额外的参数来指定渐变的方向。\n在水平条纹的代码中，我们其实也可以加上这个参数，只不过它的默认值 to bottom 本来就跟我们的意图一致，于是就省略了。\n最后，我们还需要把 background-size 的值颠倒一下。\n\ndiv&#123;    background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);    background-size: 30px 100%;&#125;\n\n\n\n斜向条纹\n如果我们再次改变 background-size 的值和渐变的方向，是不是就可以得到斜向（比如45°）的条纹图案。\n\ndiv&#123;    background: linear-gradient(45deg,#fb3 50%, #58a 0);    background-size: 30px 30px;&#125;\n\n\n\n\n这个办法行不通。原因在于我们只是把每个“贴片”内部的渐变旋转了 45°，而不是把整个重复的背景都旋转了。\n单个贴片包含了四条条纹，而不是两条，只有这样才有可能做到无缝拼接它正是我们需要在 CSS 代码中重新实现的贴片，因此我们需要增加一些色标。\n\ndiv&#123;    background: linear-gradient(45deg,                #fb3 25%, #58a 0, #58a 50%,                #fb3 0, #fb3 75%, #58a 0);    background-size: 30px 30px;&#125;\n\n\n\n更好的斜向条纹\n设置任意角度倾斜：\nrepeating-gradient()和repeating-radial-gradient()方法。\n色标是无限循环重复的，直到填满整个背景。\n\n\n\ndiv&#123;    background: repeating-linear-gradient(45deg,#fb3, #58a 30px);&#125;\n\n\n\n\n将斜向45°条纹修改为60°。\n\ndiv&#123;    background: repeating-linear-gradient(60deg,#fb3, #fb3 15px, #58a 0, #58a 30px);&#125;\n\n\n\n灵活的同色系条纹\n不再为每种条纹单独指定颜色，而是把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来得到浅色条纹。\n\ndiv&#123;    background: #58a;    background-image: repeating-linear-gradient(30deg,                    hsla(0,0%,100%,.1),                    hsla(0,0%,100%,.1) 15px,                    transparent 0, transparent 30px);&#125;\n\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"JavaScript学习笔记（四十七）JSON","url":"/2021/12/22/js-47/","content":"一、语法\nJSON语法支持表示3种类型的值：\n简单值：字符串、数值、布尔值和null可以在JSON中出现，就像在JavaScript中一样。特殊值undefined不可以。\n对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。\n数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象,甚至其他数组。\n\n\nJSON没有变量声明。\nJSON没有变量、函数或对象实例的概念。JSON的所有记号都只为表示结构化数据\n布尔值和null本身也是有效的JSON值。\nJavaScript字符串与JSON字符串的主要区别是：JSON字符串必须使用双引号。\n数组在 JSON 中使用 JavaScript 的数组字面量形式表示。\n\n二、解析与序列化1、JSON对象\nstringify()和parse()方法可用于将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。\n如果给JSON.parse()传入的JSON字符串无效，则会导致抛出错误。\n\n\n\nlet book = &#123;     title: &quot;Professional JavaScript&quot;,     authors: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     edition: 4,     year: 2017 &#125;; let jsonText = JSON.stringify(book); /*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;], &quot;edition&quot;:4,&quot;year&quot;:2017&#125; */\n\n2、序列化选项\nJSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化JavaScript对象的方式。\n第一个参数是过滤器，可以是数组或函数；\n第二个参数是用于缩进结果JSON字符串的选项。\n单独或组合使用这些参数可以更好地控制JSON序列化。\n\n\n\n1）过滤结果\n如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性。\n\nlet book = &#123;     title: &quot;Professional JavaScript&quot;,     authors: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     edition: 4,     year: 2017 &#125;; let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); /*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:4&#125;*/\n\n\n如果第二个参数是一个函数，提供的函数接收两个参数:属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作。\n函数过滤器会应用到要序列化的对象所包含的所有对象，因此如果数组中包含多个具有这些属性的对象，则序列化之后每个对象都只会剩下上面这些属性。\n\nlet book = &#123;     title: &quot;Professional JavaScript&quot;,     authors: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     edition: 4,     year: 2017 &#125;;let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;     switch(key) &#123;         case &quot;authors&quot;:             return value.join(&quot;,&quot;)         case &quot;year&quot;:             return 5000;         case &quot;edition&quot;:             return undefined;         default:             return value;     &#125; &#125;);/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,Matt Frisbie&quot;,&quot;year&quot;:5000&#125; */\n\n2）字符串缩进\nJSON.stringify()方法的第三个参数控制缩进和空格。\n在这个参数是数值时，表示每一级缩进的空格数。\n\n\nJSON.stringify()方法还为方便阅读插入了换行符。\n最大缩进值为10，大于10的值会自动设置为10。\n如果缩进参数是一个字符串而非数值，那么JSON字符串中就会使用这个字符串而不是空格来缩进。\n\nlet book = &#123;     title: &quot;Professional JavaScript&quot;,     authors: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     edition: 4,     year: 2017 &#125;;let jsonText = JSON.stringify(book, null, 4); /*&#123;     &quot;title&quot;: &quot;Professional JavaScript&quot;,     &quot;authors&quot;: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     &quot;edition&quot;: 4,     &quot;year&quot;: 2017 &#125; */\n\n3）toJSON()方法let book = &#123;     title: &quot;Professional JavaScript&quot;,     authors: [         &quot;Nicholas C. Zakas&quot;,         &quot;Matt Frisbie&quot;     ],     edition: 4,     year: 2017,     toJSON: function() &#123;         return this.title;     &#125;&#125;; let jsonText = JSON.stringify(book); \n这里book对象中定义的toJSON()方法简单地返回了图书的书名(this.title)。\n\n箭头函数不能用来定义toJSON()方法。\n主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。\n\n\ntoJSON()方法可以与过滤函数一起使用，在把对象传给JSON.stringify()时会执行如下步骤。  (1)如果可以获取实际的值，则调用toJSON()方法获取实际的值，否则使用默认的序列化。  (2)如果提供了第二个参数，则应用过滤。传人过滤函数的值就是第(1)步返回的值。  (3)第(2)步返回的每个值都会相应地进行序列化。  (4) 如果提供了第三个参数，则相应地进行缩进。\n\n3、解析选项\nJSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。\n为区别于传给JSON.stringify()的起过滤作用的替代函数(replacer)，这个函数被称为还原函数(reviver)。实际上它们的格式完全一样。\n\n","categories":["前端学习笔记","JS","Json"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十八）网络请求与远程资源（一）","url":"/2021/12/22/js-48/","content":"一、XMLHttpRequest对象1、使用XHR\nopen()方法\n接收3个参数：请求类型、请求URL、表示请求是否异步的布尔值。\n调用open不会实际发送请求，只是为发送请求做好准备。\n\n\nsend()方法用于发送定义好的请求\n方法接收一个参数：作为请求体发送的数据。\n该请求为同步请求，JavaScript代码会等待服务器响应之后再继续执行。\n\n\n\nlet xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;example.php&quot;, false); xhr.send(null);\n\n\n收到响应后，XHR对象的以下属性会被填充上数据。\n\n\n\n\n收到响应后，第一步要检查status属性以确保响应成功返回。\n\n一般来说，HTTP 状态码为2xx表示成功。此时，responseText 或responseXML (如果内容类型正确)属性中会有内容。\n如果HTTP状态码是304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。\n\n\nXHR对象有一个readyState属性，表示当前处在请求/响应过程的哪个阶段。属性有如下可能的值：\n\n每次readyState从一个值变成另一个值，都会触发readystatechange事件。为保证跨浏览器兼容，onreadystatechange事件处理程序应该在调用open()之前赋值。\n\n在收到响应之前如果想取消异步请求，可以调用 abort()方法。\n\n\n2、HTTP头部\n默认情况下，XHR请求会发送以下头部字段。\n\n\n\n\nsetRequestHeader方法可以发送额外的请求头部。\n接收两个参数：头部字段的名称和值。\n为保证请求头部被发送，必须在open()之后、send()之前调用。\n\n\n\nlet xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123;     if (xhr.readyState == 4) &#123;         if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;             alert(xhr.responseText);         &#125; else &#123;             alert(&quot;Request was unsuccessful: &quot; + xhr.status);         &#125;     &#125; &#125;; xhr.open(&quot;get&quot;, &quot;example.php&quot;, true); xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;); xhr.send(null);\n\n\ngetResponseHeader()方法可以从XHR对象获取响应头部。\ngetAllResponseHeaders()方法获取所有响应头部。\n\nlet myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;); let allHeaders xhr.getAllResponseHeaders(); \n\n3、GET请求\nGET请求用于向服务器查询某些信息。必要时，需要在GET请求的URL后面添加查询字符串参数。\n对XHR而言，查询字符串必须正确编码后添加到URL后面，然后再传给open()方法。\n查询字符串中的每个名和值都必须使用encodeURIComponent ()编码，所有名/值对必须以和号(&amp;)分隔。\n\nxhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true); \n\n4、POST请求\nPOST请求，用于向服务器发送应该保存的数据。\n每个POST请求都应该在请求体中携带提交的数据，而GET请求则不然。\nPOST请求的请求体可以包含非常多的数据，而且数据可以是任意格式。\n\nxhr.open(&quot;post&quot;, &quot;example.php&quot;, true); \n\n\nPOST请求相比GET请求要占用更多资源。\n从性能方面说，发送相同数量的数据，GET请求比POST请求要快两倍。\n\n5、XMLHttpRequest Level 21）FormData类型\nFormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送。\n\nlet data = new FormData(); data.append(&quot;name&quot;, &quot;Nicholas&quot;);\n\n\nappend()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。\n通过直接给FormData构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去。\n\nlet data = new FormData(document.forms[0]);let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123;     if (xhr.readyState == 4) &#123;         if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;             alert(xhr.responseText);         &#125; else &#123;             alert(&quot;Request was unsuccessful: &quot; + xhr.status);         &#125;     &#125; &#125;; xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true); let form = document.getElementById(&quot;user-info&quot;); xhr.send(new FormData(form)); \n\n2）超时\nXHR对象有一个timeout属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。\n当超时后，XHR对象就会触发timeout事件，调用ontimeout事件处理程序。\n\n/*下面这个例子演示了使用timeout设置超时。给timeout设置1000 毫秒意味着，如果请求没有在1秒钟内返回则会中断。此时则会触发ont imeout事件处理程序，readyState 仍然会变成4，因此也会调用onreadystatechange事件处理程序。不过，如果在超时之后访问status属性则会发生错误。为做好防护，可以把检查status属性的代码封装在try/catch语句中。*/let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123;     if (xhr.readyState == 4) &#123;         try &#123;         if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;             alert(xhr.responseText);         &#125; else &#123;             alert(&quot;Request was unsuccessful: &quot; + xhr.status);         &#125;         &#125; catch (ex) &#123;             // 假设由 ontimeout 处理        &#125;     &#125; &#125;; xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true); xhr.timeout = 1000; // 设置 1 秒超时xhr.ontimeout = function() &#123;     alert(&quot;Request did not return in a second.&quot;); &#125;; xhr.send(null);\n\n3）overrideMineType()方法\noverrideMineType()方法用于重写XHR响应的MIME类型。\n假设服务器实际发送了XML数据，但响应头设置的MIME类型是text/plain。结果就会导致虽然数据是XML，但responseXML属性值是null。此时调用overrideMimeType()可以保证将响应当成XML而不是纯文本来处理。\n\nlet xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;text.php&quot;, true); xhr.overrideMimeType(&quot;text/xml&quot;); xhr.send(null);\n\n二、进度事件\n\n\n每次请求都会首先触发loadstart事件，之后是一个或多个progress事件，接着是error、abort或load中的一个，最后以loadend事件结束。\n\n","categories":["前端学习笔记","JS"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十八）网络请求与远程资源（二）","url":"/2021/12/24/js-49/","content":"三、跨源资源共享\n跨源资源共享(CORS, Cross-Origin Resource Sharing)定义了浏览器与服务器如何实现跨源通信。\n\nCORS背后的基本思路就是使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。\n\n对于简单的请求，比如GET或POST请求，没有自定义头部，而且请求体是text/plain类型，这样的请求在发送时会有一个额外的头部叫Origin。Origin头部包含发送请求的页面的源(协议域名和端口)，以便服务器确定是否为其提供响应。\n\n现代浏览器通过XMLHttpRequest对象原生支持CORS。\n\n要向不同域的源发送请求，可以使用标准XHR对象并给open()方法传入一个绝对URL。\n\n跨域XHR对象允许访问status和statusText属性，也允许同步请求。\n\n跨域XHR对象有以下额外限制：\n\n不能使用setRequestHeader()设置自定义头部。\n不能发送和接收cookie。\ngetAllResponseHeaders()方法始终返回空字符串。\n\n\n\n1、预检请求\nCORS通过一种叫预检请求的服务器验证机制，允许使用自定义头部、除GET和POST之外的方法，以及不同请求体内容类型。\n这个请求使用OPTIONS方法发送并包含以下头部。\n\n\n\n\n在这个请求发送后，服务器可以确定是否允许这种类型的请求。\n服务器会通过在响应中发送如下头部与浏览器沟通这些信息。\n\n\n\n2、凭据请求\n默认情况下，跨源请求不提供凭据（cookie、HTTP认证和客户端SSL证书）。\n可以通过将withCredentials属性设置为true来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：\n\nAccess-Control-Allow-Credentials: true \n四、替代性跨源技术1、图片探测\n图片探测是利用&lt;img&gt;标签实现跨域通信的最早的一种技术。\n原理是：任何页面都可以跨域加载图片而不必担心限制。\n图片探测是与服务器之间简单、跨域、单向的通信。\n数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为204的状态码。\n\n2、JSONP\nJSONP是JSON with padding 的简写，是在Web服务上流行的一种JSON变体。\nJSONP格式包含两个部分：回调和数据：\n回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。\n数据就是作为参数传给回调函数的JSON数据。\n\n\n优点：相比于图片探测，使用JSONP可以直接访问响应，实现浏览器与服务器的双向通信。\n缺点：①JSONP是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加人恶意内容。②不好确定JSONP请求是否失败。\n\n","categories":["前端学习笔记","JS","跨域问题"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十八）网络请求与远程资源（四）","url":"/2021/12/30/js-51/","content":"Web Socket\nWeb Socket (套接字)的目标是通过一个长时连接实现与服务器全双工、双向的通信。\n\n1、API\n要创建一个新的WebSocket，就要实例化一个WebSocket对象并传人提供连接的URL。\n必须给WebSocket构造函数传人一个绝对URL。\n\nlet socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);\n\n\n同源策略不适用于Web Socket，因此可以打开到任意站点的连接。\n至于是否与来自特定源的页面通信，则完全取决于服务器。(在握手阶段就可以确定请求来自哪里。)\n浏览器会在初始化WebSocket对象之后立即创建连接。\n与XHR类似，WebSocket也有一个readyState属性表示当前状态。不过，这个值与XHR中相应的值不一样。\n\n\n\n\nWebSocket对象没有readystatechange 事件，而是有与上述不同状态对应的其他事件。readyState值从0开始。\n任何时候都可以调用close()方法关闭Web Socket连接，调用close()之后，readyState立即变为2 (连接正在关闭),并会在关闭后变为3 (连接已经关闭)。\n\n2、发送和接收数据\n打开Web Socket之后，可以通过连接发送和接收数据。\n要向服务器发送数据，使用send()方法并传入一个字符串、ArrayBuffer或Blob。\n\nlet socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); let stringData = &quot;Hello world!&quot;; let arrayBufferData = Uint8Array.from([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]); let blobData = new Blob([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]); socket.send(stringData); socket.send(arrayBufferData.buffer); socket.send(blobData);\n\n\n服务器向客户端发送消息时，WebSocket 对象上会触发message事件。这个message事件与其他消息协议类似，可以通过event.data属性访问到有效载荷。\n\nsocket.onmessage = function(event) &#123;     let data = event.data;     // 对数据执行某些操作&#125;; \n\n\n与通过send()方法发送的数据类似，event.data返回的数据也可能是ArrayBuffer或Blob。这由WebSocket对象的binaryType属性决定，该属性可能是”blob”或” arraybuffer”。\n\n3、其他事件\nopen：在连接成功建立时触发。\nerror：在发生错误时触发。连接无法存续。\nclose：在连接关闭时触发。\n\nlet socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;); socket.onopen = function() &#123;  alert(&quot;Connection established.&quot;); &#125;; socket.onerror = function() &#123;  alert(&quot;Connection error.&quot;); &#125;; socket.onclose = function() &#123;  alert(&quot;Connection closed.&quot;); &#125;; ","categories":["前端学习笔记","JS","Web Socket"],"tags":["JS学习"]},{"title":"JavaScript学习笔记（四十八）网络请求与远程资源（三）","url":"/2021/12/25/js-50/","content":"五、Fetch API\nFetch API则必须是异步\n\n1、基本用法\nfetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。\n\n1）分派请求\nfetch()只有一个必需的参数input。多数情况下，这个参数是要获取资源的URL。\n这个方法返回一个期约。\n\nlet r = fetch(&#x27;/bar&#x27;); console.log(r); // Promise &lt;pending&gt;\n\n\n请求完成、资源可用时，期约会解决为一个Response对象。\n这个对象是API的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式。\n\nfetch(&#x27;bar.txt&#x27;)  .then((response) =&gt; &#123;     console.log(response); &#125;); // Response &#123; type: &quot;basic&quot;, url: ... &#125;\n\n2、读取响应\n读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。\n这个方法返回一个期约，会解决为取得资源的完整内容。\n\n\n\nfetch(&#x27;bar.txt&#x27;)     .then((response) =&gt; &#123;         response.text().then((data) =&gt; &#123;             console.log(data);         &#125;);     &#125;); // bar.txt 的内容\n\n内容的结构通常是打平的：fetch(&#x27;bar.txt&#x27;)     .then((response) =&gt; response.text())     .then((data) =&gt; console.log(data)); // bar.txt 的内容\n\n3）处理状态码和请求失败\nFetch API支持通过Response的status ( 状态码)和statusText (状态文本)属性检查响应状态。\n成功获取响应的请求通常会产生值为200的状态码。\n请求不存在的资源通常会产生值为 404 的状态码。\n请求的 URL 如果抛出服务器错误会产生值为 500 的状态码。\n只要服务器返回了响应，fetch()期约都会解决。\n\nfetch(&#x27;/bar&#x27;)  .then((response) =&gt; &#123;     console.log(response.status); // 200     console.log(response.statusText); // OK  &#125;);\n\n\n通常状态码为200时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非200-299时检查Response对象的ok属性。\n\nfetch(&#x27;/bar&#x27;)  .then((response) =&gt; &#123;     console.log(response.status); // 200     console.log(response.ok); // true  &#125;); fetch(&#x27;/does-not-exist&#x27;)  .then((response) =&gt; &#123;     console.log(response.status); // 404     console.log(response.ok); // false  &#125;); \n\n\n违反CORS、无网络连接、HTTPS错配及其他浏览器/网络策略问题都会导致期约被拒绝。\n可以通过url属性检查通过fetch()发送请求时使用的完整URL。\n\n// foo.com/bar/baz 发送的请求console.log(window.location.href); // https://foo.com/bar/baz fetch(&#x27;qux&#x27;).then((response) =&gt; console.log(response.url)); // https://foo.com/bar/quxfetch(&#x27;/qux&#x27;).then((response) =&gt; console.log(response.url)); // https://foo.com/quxfetch(&#x27;//qux.com&#x27;).then((response) =&gt; console.log(response.url)); // https://qux.comfetch(&#x27;https://qux.com&#x27;).then((response) =&gt; console.log(response.url)); // https://qux.com\n\n4）自定义选项\n只使用URL时，fetch()会发送GET请求，只包含最低限度的请求头。\n要进一步配置如何发送请求，需要传入可选的第二个参数init对象。\n\n2、常见Fetch请求模式1）发送JSON数据let payload = JSON.stringify(&#123;     foo: &#x27;bar&#x27; &#125;); let jsonHeaders = new Headers(&#123;     &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;); fetch(&#x27;/send-me-json&#x27;, &#123;     method: &#x27;POST&#x27;, // 发送请求体时必须使用一种 HTTP 方法    body: payload,     headers: jsonHeaders &#125;);\n\n2）在请求体中发送参数let payload = &#x27;foo=bar&amp;baz=qux&#x27;; let paramHeaders = new Headers(&#123;     &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27; &#125;); fetch(&#x27;/send-me-params&#x27;, &#123;     method: &#x27;POST&#x27;, // 发送请求体时必须使用一种 HTTP 方法    body: payload,     headers: paramHeaders &#125;);\n\n3）发送文件\n因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文件。\n\nlet imageFormData = new FormData(); let imageInput = document.querySelector(&quot;input[type=&#x27;file&#x27;]&quot;); imageFormData.append(&#x27;image&#x27;, imageInput.files[0]); fetch(&#x27;/img-upload&#x27;, &#123;     method: &#x27;POST&#x27;,     body: imageFormData &#125;);\n\n4）加载Blob文件\nFetch API也能提供Blob类型的响应，而Blob又可以兼容多种浏览器API。\n可以使用响应对象上暴露的blob()方法。\n方法返回一个期约，解决为一个Blob的实例。可以将这个实例传给URL.create0bjectUrl()以生成可以添加给图片元素src属性的值。\n\n\n\nconst imageElement = document.querySelector(&#x27;img&#x27;); fetch(&#x27;my-image.png&#x27;)     .then((response) =&gt; response.blob())     .then((blob) =&gt; &#123;         imageElement.src = URL.createObjectURL(blob);     &#125;); \n\n5）发送跨源请求\n从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。\n\nfetch(&#x27;//cross-origin.com&#x27;); // TypeError: Failed to fetch // No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. \n\n\n如果代码不需要访问响应，也可以发送no-cors请求。此时响应的type属性值为opaque，因此无法读取相应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。\n\nfetch(&#x27;//cross-origin.com&#x27;, &#123; method: &#x27;no-cors&#x27; &#125;)     .then((response) =&gt; console.log(response.type)); // opaque\n\n6）中断请求\nFetch API支持通过AbortController/AbortSignal 对中断请求。\n调用AbortController.abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。\n中断进行中的fetch()请求会导致包含错误的拒绝。\n\nlet abortController = new AbortController(); fetch(&#x27;wikipedia.zip&#x27;, &#123; signal: abortController.signal &#125;)     .catch(() =&gt; console.log(&#x27;aborted!&#x27;); // 10 毫秒后中断请求setTimeout(() =&gt; abortController.abort(), 10); // 已经中断\n\n3、Headers对象\nHeaders对象是所有外发请求和入站响应头部的容器。\n每个外发的Request实例都包含一个空的Headers实例，可以通过Request.prototype.headers 访问，每个入站Response实例也可以通过Response.prototype.headers访问包含着响应头部的Headers对象。这两个属性都是可修改属性。\n使用new Headers()也可以创建一个新实例。\n\n1）Headers与Map的相似之处\n因为HTTP头部本质上是序列化后的键/值对，它们的JavaScript表示则是中间接口。\nHeaders与Map类型都有get()、set()、has()和delete()等实例方法。\nHeaders和Map都可以使用一个可迭代对象来初始化。\n都有相同的keys()、values()和entries()迭代器接口。\n\n2）Headers独有的特性1、 在初始化Headers对象时，可以使用键/值对形式的对象，而Map不可以。2、 Headers对象通过append()方法支持添加多个值。在Headers实例中还不存在的头部上调用append()方法相当于调用set ()。\nlet seed = &#123;foo: &#x27;bar&#x27;&#125;; let h = new Headers(seed); console.log(h.get(&#x27;foo&#x27;)); // bar let m = new Map(seed); // TypeError: object is not iterable //==================================let h = new Headers(); h.append(&#x27;foo&#x27;, &#x27;bar&#x27;); console.log(h.get(&#x27;foo&#x27;)); // &quot;bar&quot;h.append(&#x27;foo&#x27;, &#x27;baz&#x27;); console.log(h.get(&#x27;foo&#x27;)); // &quot;bar, baz&quot; \n\n3）头部护卫\nHeaders对象使用护卫来防止不被允许的修改。\n不同的护卫设置会改变set()、append()和 delete()的行为。违反护卫限制会抛出TypeError。\n\n\n\n4、Request对象\nRequest对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。\n\n1）创建Request对象\n通过构造函数初始化Request对象，为此需要传入一个input参数，一般是URL。\n\nlet r = new Request(&#x27;https://foo.com&#x27;); console.log(r); // Request &#123;...&#125; \n\n\nRequest构造函数也接收第二个参数一个 init 对象。\n没有在init对象中涉及的值则会使用默认值。\n\n2）克隆Request对象\nFetch API提供了两种不太一样的方式用于创建Request对象的副本：\n使用Request构造函数；\n使用clone()方法。\n\n\n将Request实例作为input参数传给Request构造函数，会得到该请求的一个副本：\n\nlet r1 = new Request(&#x27;https://foo.com&#x27;); let r2 = new Request(r1); console.log(r2.url); // https://foo.com/ \n\n\n如果再传入init对象，则init对象的值会覆盖源对象中同名的值：\n\nlet r1 = new Request(&#x27;https://foo.com&#x27;); let r2 = new Request(r1, &#123;method: &#x27;POST&#x27;&#125;); console.log(r1.method); // GETconsole.log(r2.method); // POST \n\n\n这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”：\n\nlet r1 = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;); let r2 = new Request(r1); console.log(r1.bodyUsed); // true console.log(r2.bodyUsed); // false\n\n\n第二种克隆Request对象的方式是使用clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。\n与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”。\n如果请求对象的bodyUsed属性为true (即请求体已被读取),那么上述任何一种方式都不能用来创建这个对象的副本。\n\nlet r1 = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;); let r2 = r1.clone(); console.log(r1.url); // https://foo.com/ console.log(r2.url); // https://foo.com/ console.log(r1.bodyUsed); // false console.log(r2.bodyUsed); // false \n\n3）在fetch()中使用Request对象\n在调用fetch()时，可以传入已经创建好的Request实例而不是URL。\nfetch()会在内部克隆传入的Requeat对象。\nfetch()也不能拿请求体已经用过的Request对象来发送请求。\n有请求体的Request只能在一次fetch中使用。\n\nlet r = new Request(&#x27;https://foo.com&#x27;); // 向 foo.com 发送 GET 请求fetch(r); // 向 foo.com 发送 POST 请求fetch(r, &#123; method: &#x27;POST&#x27; &#125;); \n\n\n要想基于包含请求体的相同Request对象多次调用fetch(),必须在第一次发送fetch()请求前调用clone()。\n\nlet r = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;); // 3 个都会成功fetch(r.clone()); fetch(r.clone()); fetch(r); \n\n5、Response对象\nResponse 对象是获取资源响应的接口。\n这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。\n\n1）创建Response对象\n可以通过构造函数初始化Response对象且不需要参数。\n此时响应实例的属性均为默认值，因为它并不代表实际的HTTP响应。\n\nlet r = new Response(); console.log(r); /*Response &#123;     body: (...)     bodyUsed: false     headers: Headers &#123;&#125;     ok: true     redirected: false     status: 200     statusText: &quot;OK&quot;     type: &quot;default&quot;     url: &quot;&quot; &#125; */\n\n\nResponse构造函数接收一个可选的body参数。\n这个body可以是null，等同于fetch()参数init中的body。\n\n\n还可以接收一个可选的init对象，这个对象可以包含下表所列的键和值。\n\n\n\nlet r = new Response(&#x27;foobar&#x27;, &#123;     status: 418,     statusText: &#x27;I\\&#x27;m a teapot&#x27; &#125;); console.log(r); /*Response &#123;     body: (...)     bodyUsed: false     headers: Headers &#123;&#125;     ok: false     redirected: false     status: 418    statusText: &quot;I&#x27;m a teapot&quot;    type: &quot;default&quot;     url: &quot;&quot; &#125;*/\n\n\n**大多数情况下，产生Response 对象的主要方式是调用fetch()**， 它返回一个最后会解决为Response对象的期约，这个Response 对象代表实际的HTTP响应。\n\nfetch(&#x27;https://foo.com&#x27;)  .then((response) =&gt; &#123;  console.log(response);  &#125;); /*Response &#123;     body: (...)     bodyUsed: false     headers: Headers &#123;&#125;     ok: true     redirected: false     status: 200     statusText: &quot;OK&quot;     type: &quot;basic&quot;     url: &quot;https://foo.com/&quot; &#125;*/\n\n\nResponse类还有两个用于生成Response对象的静态方法: Response.redirect()和Response.error()。\n前者接收一个URL和一个重定向状态码(301、302、303、307或308)，返回重定向的Response对象。\n提供的状态码必须对应重定向，否则会抛出错误。\n\n\n另一个静态方法Response.error()用于产生表示网络错误的Response 对象。\n\nconsole.log(Response.redirect(&#x27;https://foo.com&#x27;, 301)); /*Response &#123;     body: (...)     bodyUsed: false     headers: Headers &#123;&#125;     ok: false     redirected: false     status: 301     statusText: &quot;&quot;     type: &quot;default&quot;     url: &quot;&quot; &#125;*/\n\n2）读取响应状态信息\nResponse对象包含一组只读属性，描述了请求完成后的状态，如下表所示。\n\n\n\n\n以下代码演示了返回200、302、404和500状态码的URL对应的响应：\n\nfetch(&#x27;//foo.com&#x27;).then(console.log); // Response &#123;     // body: (...)     // bodyUsed: false     // headers: Headers &#123;&#125;     // ok: true     // redirected: false     // status: 200     // statusText: &quot;OK&quot;     // type: &quot;basic&quot;     // url: &quot;https://foo.com/&quot; // &#125; fetch(&#x27;//foo.com/redirect-me&#x27;).then(console.log); // Response &#123;     // body: (...)     // bodyUsed: false     // headers: Headers &#123;&#125;     // ok: true     // redirected: true    // status: 200     // statusText: &quot;OK&quot;     // type: &quot;basic&quot;     // url: &quot;https://foo.com/redirected-url/&quot; // &#125; fetch(&#x27;//foo.com/does-not-exist&#x27;).then(console.log); // Response &#123;     // body: (...)     // bodyUsed: false     // headers: Headers &#123;&#125;     // ok: false     // redirected: true     // status: 404     // statusText: &quot;Not Found&quot;    // type: &quot;basic&quot;     // url: &quot;https://foo.com/does-not-exist/&quot; // &#125; fetch(&#x27;//foo.com/throws-error&#x27;).then(console.log); // Response &#123;     // body: (...)     // bodyUsed: false     // headers: Headers &#123;&#125;     // ok: false     // redirected: true     // status: 500     // statusText: &quot;Internal Server Error&quot;    // type: &quot;basic&quot;     // url: &quot;https://foo.com/throws-error/&quot; // &#125; \n\n3）克隆Response对象\n克隆Response对象的主要方式是使用clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用。\n\nlet r1 = new Response(&#x27;foobar&#x27;); let r2 = r1.clone(); console.log(r1.bodyUsed); // false console.log(r2.bodyUsed); // false\n\n\n如果响应对象的bodyUsed属性为true (即响应体已被读取),则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出TypeError。\n\nlet r = new Response(&#x27;foobar&#x27;); r.clone(); // 没有错误r.text(); // 设置 bodyUsed 为 true r.clone(); // TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Response&#x27;: Response body is already used \n\n\n有响应体的Response对象只能读取一次。\n\nlet r = new Response(&#x27;foobar&#x27;); r.text().then(console.log); // foobar r.text().then(console.log); // TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked\n\n\n要多次读取包含响应体的同一个Response对象，必须在第一次读取前调用clone()：\n\nlet r = new Response(&#x27;foobar&#x27;); r.clone().text().then(console.log); // foobar r.clone().text().then(console.log); // foobar r.text().then(console.log); // foobar \n\n6、Request、Response及Body混入1）Body.text()\nBody.text ()方法返回期约，解决为将缓冲区转存得到的UTF-8 格式字符串。下面的代码展示了在Response对象上使用Body.text()：\n\nfetch(&#x27;https://foo.com&#x27;)     .then((response) =&gt; response.text())     .then(console.log); // &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; // &lt;head&gt; // &lt;meta charset=&quot;utf-8&quot;&gt; // ... \n\n\n以下代码展示了在Request对象上使用Body.text()：\n\nlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;barbazqux&#x27; &#125;); request.text()     .then(console.log); // barbazqux\n\n2）Body.json()\nBody.json()方法返回期约，解决为将缓冲区转存得到的JSON。下面的代码展示了在Response对象上使用Body.json()：\n\nfetch(&#x27;https://foo.com/foo.json&#x27;)     .then((response) =&gt; response.json())     .then(console.log); // &#123;&quot;foo&quot;: &quot;bar&quot;&#125;\n\n\n以下代码展示了在Request对象上使用Body.json()：\n\nlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: JSON.stringify(&#123; bar: &#x27;baz&#x27; &#125;) &#125;); request.json().then(console.log); // &#123;bar: &#x27;baz&#x27;&#125; \n\n3）Body.formData()\n浏览器可以将FormData对象序列化/反序列化为主体。\n\nlet myFormData = new FormData(); myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;); \n\n\nBody.formData()方法返回期约，解决为将缓冲区转存得到的FormData实例。\n下面的代码展示了在Response对象上使用Body.formData()：\n\nfetch(&#x27;https://foo.com/form-data&#x27;)  .then((response) =&gt; response.formData())  .then((formData) =&gt; console.log(formData.get(&#x27;foo&#x27;)); // bar \n\n\n以下代码展示了在Request对象上使用Body.formData()：\n\nlet myFormData = new FormData(); myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;); let request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: myFormData &#125;); request.formData() .then((formData) =&gt; console.log(formData.get(&#x27;foo&#x27;)); // bar \n\n4）Body.arrayBuffer()\n可以使用Body.arrayBuffer()将主体内容转换为ArrayBuffer实例。\nBody.arrayBuffer()方法返回期约，解决为将缓冲区转存得到的ArrayBuffer实例。\n下面的代码展示了在Response对象上使用Body.arrayBuffer()：\n\nfetch(&#x27;https://foo.com&#x27;)     .then((response) =&gt; response.arrayBuffer())     .then(console.log); // ArrayBuffer(...) &#123;&#125;\n\n\n以下代码展示了在Request对象上使用Body.arrayBuffer()：\n\nlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: &#x27;abcdefg&#x27; &#125;); // 以整数形式打印二进制编码的字符串request.arrayBuffer() .then((buf) =&gt; console.log(new Int8Array(buf))); // Int8Array(7) [97, 98, 99, 100, 101, 102, 103] \n\n5）Body.blob()\n有时候，可能需要以原始二进制格式使用主体，不用查看和修改。\n可以使用Body.blob()将主体内容转换为Blob实例。\nBody.blob()方法返回期约，解决为将缓冲区转存得到的Blob实例。\n下面的代码展示了在Response对象上使用Body.blob()：\n\nfetch(&#x27;https://foo.com&#x27;)     .then((response) =&gt; response.blob())     .then(console.log); // Blob(...) &#123;size:..., type: &quot;...&quot;&#125;\n\n\n以下代码展示了在Request对象上使用Body.blob()：\n\nlet request = new Request(&#x27;https://foo.com&#x27;, &#123; method:&#x27;POST&#x27;, body: &#x27;abcdefg&#x27; &#125;); request.blob().then(console.log); // Blob(7) &#123;size: 7, type: &quot;text/plain;charset=utf-8&quot;&#125;\n\n6）一次性流\n因为Body混入是构建在ReadableStream之上的，所以主体流只能使用一次。\n这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。\n\nfetch(&#x27;https://foo.com&#x27;)     .then((response) =&gt; response.blob().then(() =&gt; response.blob())); // TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked let request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;); request.blob().then(() =&gt; request.blob()); // TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked \n\n\n即使是在读取流的过程中，所有这些方法也会在它们被调用时给ReadableStream加锁，以阻止其他读取器访问：\n\nfetch(&#x27;https://foo.com&#x27;)     .then((response) =&gt; &#123;         response.blob(); // 第一次调用给流加锁        response.blob(); // 第二次调用再次加锁会失败    &#125;); // TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked let request = new Request(&#x27;https://foo.com&#x27;, &#123; method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; &#125;); request.blob(); // 第一次调用给流加锁request.blob(); // 第二次调用再次加锁会失败// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked \n\n","categories":["前端学习笔记","JS","Fetch"],"tags":["JS学习"]},{"title":"CSS学习笔记（十一）字体排印（二）","url":"/2022/01/24/css-11/","content":"二十三、调整tab的宽度问题提出\n由于tab导致文本间间隙过大进而影响视觉效果。\n\n解决方案\ntab-size属性：\n接受一个数字（表示字符数）或者一个长度值。\n通常希望把它设置为 4（表示 4 个字符的宽度）或2。pre &#123;    tab-size: 2;&#125;\n\n\n视觉效果对比：\n\n\n\n\n二十四、连字问题提出\n由于字形间的相互影响，导致字形模糊不清。\n\n解决方案\nfont-variant-ligatures属性：\n该属性专门用来控制连字效果的开启和关闭。\n如果要启用所有可能的连字，需要同时指定这三个标识符。\n如果要把 font-variant-ligatures 属性复位为初始值，应该使用 normal 而不是 none。\n\n\n\ndiv&#123;    font-variant-ligatures: common-ligatures        discretionary-ligatures        historical-ligatures;&#125;\n\n二十五、华丽的&amp;符号\n通过@font-face规则实现基本的字体嵌入。\n\n无法通过单一的字符实现不同样式的&amp;。\n\n\n解决方案\n原理：如果某款字体可用，但仅包括某几个字符，那它就只会用来显示这几个字符；而在显示其他字符时，浏览器就会回退到其他字体。\n方法：创建一种只包含 &amp; 字形的 Web 字体，通过 @font-face 将其引入网页，然后把它排在字体队列中的第一位。\n@font-face 规则中的 src 描述符还可以接受 local()函数，用于指定本地字体的名称。\n\n\n\n@font-face &#123;    font-family: Ampersand;    src: local(&#x27;Baskerville-Italic&#x27;),    local(&#x27;GoudyOldStyleT-Italic&#x27;),    local(&#x27;Palatino-Italic&#x27;),    local(&#x27;BookAntiqua-Italic&#x27;);    unicode-range: U+26;&#125;h1 &#123;    font-family: Ampersand, Helvetica, sans-serif;&#125;\n\n二十六、自定义下划线知识点\nCSS 渐变；\nbackground-size；\ntext-shadow；\n“条纹背景”。\n\n问题提出\n默认样式往往太过扎眼，更不要提在不同浏览器下的渲染效果大相径庭。\n\n解决方案h1 &#123;    background: linear-gradient(gray, gray) no-repeat;    background-size: 100% 1px;    background-position: 0 1.15em;    text-shadow: .05em 0 white, -.05em 0 white;&#125;\n\n\n通过渐变和background-size两个属性来产生灰色细线，然后使用background-position调整位置。\n由于这样产生的下划线会穿过某些字母（比如 p 和 y）的降部。所以此时设置两层与背景色相同的 text-shadow 来模拟下划线在遇到字母时会自动断开避让这种效果。\n生成一条虚线下划线：\n\nh1 &#123;    background: linear-gradient(90deg,gray 66%, transparent 0) repeat-x;    background-size: .2em 2px;    background-position: 0 1em;&#125;\n\n二十七、现实中的文字效果凸版印刷效果\n当我们在浅色背景上使用深色文字时（比如眼前的这个例子），在底部加上浅色投影通常效果最佳。\n如果把文字和背景的颜色深度对调，在这种情况下，给文字顶部加深色投影是最佳方案。\n\np &#123;    background: hsl(210, 13%, 60%);    color: hsl(210, 13%, 30%);    text-shadow: 0 1px 1px hsla(0,0%,100%,.8);&#125;\n\n\n\np &#123;    background: hsl(210, 13%, 40%);    color: hsl(210, 13%, 75%);    text-shadow: 0 -1px 1px black;&#125;\n\n\n\n空心字效果\n使用 text-shadows 属性的扩张参数就可让投影变大，看起来就像给文字勾边了一样。\n方法一：使用多个 text-shadow 分别为这些投影加上不同方向的少量偏移。\n\np &#123;    background: deeppink;    color: white;    text-shadow: 1px 1px black, -1px -1px black,                1px -1px black, -1px 1px black;&#125;\n\n\n\n\n方法二：重叠多层轻微模糊的投影来模拟描边。\n\np &#123;    background: deeppink;    color: white;    text-shadow: 0 0 1px black, 0 0 1px black,                0 0 1px black, 0 0 1px black,                0 0 1px black, 0 0 1px black;&#125;\n\n文字外发光效果\n方法一：只需要准备几层重叠的 text-shadow 即可，不需要考虑偏移量，颜色也只需跟文字保持一致。\n\np &#123;    background: #203;    color: #ffc;    text-shadow: 0 0 .1em, 0 0 .3em;&#125;\n\n\n\n\n依赖 text-shadow 来实现文字显示的做法无法实现平稳退化：如果浏览器不支持 text-shadow，那就什么字也看不见了。\n方法二：使用 CSS 滤镜来实现文字的模糊效果\n\na &#123;    background: #203;    color: white;    transition: 1s;&#125; a:hover &#123;    filter: blur(.1em); &#125;\n\n文字突起效果\n思路：使用一长串累加的投影，不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影，从而模拟完整的立体效果。\n\ndiv&#123;    background: #58a;    color: white;    text-shadow: 0 1px hsl(0,0%,85%),                0 2px hsl(0,0%,80%),                0 3px hsl(0,0%,75%),                0 4px hsl(0,0%,70%),                0 5px hsl(0,0%,65%),                0 5px 10px black;&#125;\n\n\n\n二十八、环形文字\n使用svg解决。\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（十三）结构与布局","url":"/2022/02/03/css-13/","content":"自适应内部元素\n关键字：min-content\n将解析为这个容器内部最大的不可断行元素的宽度\n\n\n把 figure 设置为恰当的宽度，并让它水平居中。\n\nfigure &#123;    width: min-content;    margin: auto;&#125;\n\n精确控制表格列宽\n对于不固定的内容，表格布局很难预测。\ntable-layout属性：\n默认值是 auto，其行为模式被称作自动表格布局算法。\n接受另外一个值fixed，这个值的行为要明显可控一些。它把更多的控制权交给了网页开发者。\n\n\n\ntable &#123;    table-layout: fixed;    width: 100%;&#125;\n\n根据兄弟元素的数量来设置样式\n在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。\n对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child。\n:only-child 等效于 :first-child:last-child。li:only-child &#123;    /* 只有一个列表项时的样式 */&#125;\n:last-child 其实也是一个快捷写法，相当于 :nth-last-child(1)。\n这个 1 其实是一个参数，我们可以根据需要来修改这个值。\nli:first-child:nth-last-child(4)\n一个正好有四个列表项的列表中的第一个列表项。\n可以用兄弟选择符（~）来命中它之后的所有兄弟元素：相当于在这个列表正好包含四个列表项时，命中它的每一项。li:first-child:nth-last-child(4),li:first-child:nth-last-child(4) ~ li &#123; /* 当列表正好包含四项时，命中所有列表项 */&#125;\n\n\n\n根据兄弟元素的数量范围来匹配元素\n:nth-child()可以用它来命中一个范围\n参数：an+b，n 表示一个变量，理论上的范围是 0 到 + ∞；\n如果使用 n+b 这种形式的表达式（此时相当于 a 的取值为 1），那么不论 n 如何取值，这个表达式都无法产生一个小于 b 的值。\n因此，n+b 这种形式的表达式可以选中从第 b 个开始的所有子元素。\n\n\n\n满幅的背景，定宽的内容footer &#123;    padding: 1em;    padding: 1em calc(50% - 450px);    background: #333;&#125;\n\n垂直居中基于绝对定位的解决方案\n它要求元素具有固定的宽度和高度。\n\nmain &#123;    position: absolute;    top: 50%;    left: 50%;    margin-top: -3em; /* 6/2 = 3 */    margin-left: -9em; /* 18/2 = 9 */    width: 18em;    height: 6em;&#125;\n或\nmain &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);&#125;\n\n基于视口单位的解决方案main &#123;    width: 18em;    padding: 1em 1.5em;    margin: 50vh auto 0;    transform: translateY(-50%);&#125;\n\n基于 Flexbox 的解决方案\n只需写两行声明即可：先给这个待居中元素的父元素设置 display: flex，再给这个元素自身设置我们再熟悉不过的 margin: auto。\n\nbody &#123;    display: flex;    min-height: 100vh;    margin: 0;&#125;main &#123;    margin: auto;&#125;","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（十）字体排印（一）","url":"/2022/01/15/css-10/","content":"二十、连字符断行\n在对文本进行两端对齐处理时，需要调整单词的间距，此时会出现“单词孤岛”现象。这个结果不仅看起来很糟糕，而且损伤了可读性。\n\na &#123;    text-align: justify;&#125;\n\n\n\n\n解决方案：\nhyphens属性：接受三个值none、manual、auto。\n默认值为manual。\n\n\n\na &#123;    hyphens: auto;&#125;\n\n\n\n二十一、插入换行\n由于&lt;dt&gt;、&lt;dd&gt;都是块级元素，当我们需要指定其在一行时会造成困难，如下所示：\n\n我们需要创建以下格式列表：\n\n应用如下代码和样式，会得到这样的效果。\n&lt;dl&gt;    &lt;dt&gt;Name:&lt;/dt&gt;    &lt;dd&gt;Lea Verou&lt;/dd&gt;    &lt;dt&gt;Email:&lt;/dt&gt;    &lt;dd&gt;lea@verou.me&lt;/dd&gt;    &lt;dt&gt;Location:&lt;/dt&gt;    &lt;dd&gt;Earth&lt;/dd&gt;&lt;/dl&gt;\ndd &#123;    margin: 0;    font-weight: bold;&#125;\n\n外加display:inline则会出现以下效果：\n\n\n\n\n解决方案\n利用伪元素来实现。\n有一个 Unicode 字符是专门代表换行符的：0x000A。在 CSS 中，这个字符可以写作 “\\000A”，或简化为 “\\A”。\n我们可以用它来作为 ::after 伪元素的内容，并将其添加到每个 &lt;dd&gt; 元素的尾部。\n由于换行符会与空白符合并导致整体视觉效果压缩，所以需要保留换行符。（如果不保留，则结果与上图没有任何变化）\n使用white-space: pre实现以上结果。\n\n实现步骤\n针对单对单采取以下步骤：  1、 将块级元素转换为行级元素；  2、 利用伪元素给每个&lt;dd&gt;添加换行；  3、 使用white-space:pre属性来处理空白。\n\ndt, dd &#123; display: inline; &#125;dd &#123;    margin: 0;    font-weight: bold;&#125;dd::after &#123;    content: &quot;\\A&quot;;    white-space: pre;&#125;\n\n\n\n\n如果有一对多情况则需要调整一下第二步：\n在每个前面有&lt;dd&gt;的&lt;dd&gt;头部插入逗号；\n在每个前面有&lt;dd&gt;的&lt;dt&gt;头部插入换行。\n\n\n\ndt, dd &#123; display: inline; &#125;dd &#123;    margin: 0;    font-weight: bold;&#125;dd + dt::before &#123;    content: &#x27;\\A&#x27;;    white-space: pre;&#125;dd + dd::before &#123;    content: &#x27;, &#x27;;    font-weight: normal;&#125;\n\n\n\n二十二、文本行的斑马条纹知识点\nCSS 渐变；\nbackground-size；\n“条纹背景”；\n“灵活的背景定位”。\n\n存在的问题\n无法在文本行中应用斑马纹效果；\n\n解决方案\n利用背景图像来做到模拟斑马纹的效果。\n直接上代码：\n\ndiv&#123;    padding: .5em;    line-height: 1.5;    background: beige;    background-size: auto 3em;    background-origin: content-box;    background-image: linear-gradient(rgba(0,0,0,.2) 50%,transparent 0);&#125;\n\n1、 在利用background设置整体背景色后，利用background-image属性创建渐变来实现不同行不同颜色的效果。2、 这里需要设置background-size为行高line-height的两倍，因为每个背景贴片需要覆盖两行代码（一行有实际颜色，一行为透明）。3、 padding属性将整体的文本调整位置不至于太过于靠边影响视觉效果。4、 由于文本调整了位置，这里我们需要将背景进行些调整：让它的默认外沿padding box调整为content box。\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（十二）用户体验（一）","url":"/2022/01/28/css-12/","content":"二十九、选用合适的鼠标光标\n鼠标指针的用途不仅在于显示鼠标在屏幕上的位置，还可以告诉用户当前可以执行什么动作。\n\n1、提示禁用状态\n提示某个控件因为某些原因而变得无法交互（即控件已被禁用），用这个光标就再合适不过。\n\n:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123;    cursor: not-allowed;&#125;\n\n\n\n2、隐藏鼠标光标video &#123;    cursor: url(transparent.gif);    cursor: none;&#125;\n\n三十、扩大可点击区域\n针对按钮或者选择框扩大可点击区域，提高用户体验感。\n使用内嵌投影+外边框实现。\n\nbutton &#123;    border: 10px solid transparent;    box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;    background-clip: padding-box;&#125;\n\n\nbox-shadow 可以同时指定多层投影。\n伪元素同样可以代表其宿主元素来响应鼠标交互。\n\nbutton &#123;    position: relative;    /* [其余样式] */&#125;button::before &#123;    content: &#x27;&#x27;;    position: absolute;    top: -10px; right: -10px;    bottom: -10px; left: -10px;&#125;\n\n三十一、自定义复选框\n新的伪类 :checked。\n这个伪类只在复选框被勾选时才会匹配，不论这个勾选状态是由用户交互触发，还是由脚本触发。\n\n\n可以基于复选框的勾选状态借助组合选择符来给其他元素设置样式。\n当 &lt;label&gt; 元素与复选框关联之后，也可以起到触发开关的作用。\n\ninput[type=&quot;checkbox&quot;] &#123;\tposition: absolute;\tclip: rect(0,0,0,0);&#125;input[type=&quot;checkbox&quot;] + label::before &#123;\tcontent: &#x27;\\a0&#x27;;\tdisplay: inline-block;\tvertical-align: .2em;\twidth: .8em;\theight: .8em;\tmargin-right: .2em;\tborder-radius: .2em;\tbackground: silver;\ttext-indent: .15em;\tline-height: .65;&#125;input[type=&quot;checkbox&quot;]:checked + label::before &#123;\tcontent: &#x27;\\2713&#x27;;\tbackground: yellowgreen;&#125;input[type=&quot;checkbox&quot;]:focus + label::before &#123;\tbox-shadow: 0 0 .1em .1em #58a;&#125;input[type=&quot;checkbox&quot;]:disabled + label::before &#123;\tbackground: gray;\tbox-shadow: none;\tcolor: #555;\tcursor: not-allowed;&#125;\n\n\n\n开关式按钮\n利用“复选框 hack”的思路来模拟。\n只需要把 label 设置为按钮的样式即可，并不需要用到伪元素。\n\ninput[type=&quot;checkbox&quot;] &#123;    position: absolute;    clip: rect(0,0,0,0);&#125;input[type=&quot;checkbox&quot;] + label &#123;    display: inline-block;    padding: .3em .5em;    background: #ccc;    background-image: linear-gradient(#ddd, #bbb);    border: 1px solid rgba(0,0,0,.2);    border-radius: .3em;    box-shadow: 0 1px white inset;    text-align: center;    text-shadow: 0 1px 1px white;&#125;input[type=&quot;checkbox&quot;]:checked + label,input[type=&quot;checkbox&quot;]:active + label &#123;    box-shadow: .05em .1em .2em rgba(0,0,0,.6) inset;    border-color: rgba(0,0,0,.3);    background: #bbb;&#125;\n\n三十二、通过阴影来弱化背景\n通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注。\n最常见的实现方法就是增加一个额外的 HTML 元素用于遮挡背景，这个方法稳定可靠，但需要增加一个额外的 HTML 元素，这意味着该效果无法由 CSS 单独实现。\n\n伪元素方案\n用伪元素来消除额外的 HTML 元素。\n\nbody.dimmed::before &#123;    position: fixed;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 1;    background: rgba(0,0,0,.8);&#125;\n\n\n存在的问题：\n这个方法的可移植性还不够好；因为 &lt;body&gt;元素上可能有其他需求已经占用了 ::before 伪元素；\n在使用这个效果时，我们往往还需要一点 JavaScript 来给 &lt;body&gt; 添加 dimmed 这个类.\n伪元素无法绑定独立的 JavaScript 事件处理函数。\n\n\n\nbox-shadow方案\n对于简单的应用场景和产品原型来说，box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。\n存在的问题：\n由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们滚动页面时，遮罩层的边缘就露出来了，除非给它加上 position: fixed;这个样式，或者页面并没有长到需要滚动的程度。\n当使用一个独立的元素（或伪元素）来实现遮罩层时，这个遮罩层不仅可以从视觉上把用户的注意力引导到关键元素上，还可以防止用户的鼠标与页面的其他部分发生交互，因为遮罩层会捕获所有指针事件。\n\n\n\nbody &#123;    box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);&#125;\n\nbackdrop方案\n如果你想引导用户关注的元素就是一个模态的 &lt;dialog&gt; 元素，那么根据浏览器的默认样式，它会自带一个遮罩层。\n借助 ::backdrop 伪元素，这个原生的遮罩层也是可以设置样式的。\n\ndialog::backdrop &#123;    background: rgba(0, 0, 0, .8);&#125;\n\n三十三、通过模糊来弱化背景\n用一个额外的 HTML 元素来实现这个效果：\n需要把页面上除了关键元素之外的一切都包裹起来，这样就可以只对这个容器元素进行模糊处理了。\n&lt;main&gt; 元素在这里是极为合适的。\n\n\n结构代码基本上如下所示：\n\n&lt;main&gt;Bacon Ipsum dolor sit amet...&lt;/main&gt;&lt;dialog&gt;    O HAI, I&#x27;m a dialog. Click on me to dismiss.&lt;/dialog&gt;&lt;!-- 其他对话框都写在这里 --&gt;\n\n\n每当弹出一个对话框，都需要给 &lt;main&gt; 元素增加一个类，以便对它应用模糊滤镜。\n\nmain.de-emphasized &#123;    filter: blur(5px);&#125;\n\n使用 brightness() 和 / 或 contrast() 滤镜：\n\nmain.de-emphasized &#123;    filter: blur(3px) contrast(.8) brightness(.8);&#125;","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（三）背景与边框（三）","url":"/2022/01/04/css-3/","content":"六、复杂的背景图案\n水平渐变图案跟垂直渐变图案配合实现简单的蓝图网格图案。\n\n0、知识点\nlinear-gradient(direction, color-stop1 position, color-stop2  position, …)：\n用于创建一个表示两种或多种颜色线性渐变的图片。\ndirection：用角度值指定渐变的方向（或角度）。\ncolor-stop1, color-stop2,…：用于指定渐变的起止颜色。\n\n\nradial-gradient\nrepeating-linear-gradient\nrepeating-radial-gradient\n\n1、网格\n把多个渐变图案组合起来，将其透过彼此的透明区域显现。\n\ndiv&#123;    background: white;    background-image: linear-gradient(90deg,                    rgba(200,0,0,.5) 50%, transparent 0),                linear-gradient(                    rgba(200,0,0,.5) 50%, transparent 0);    background-size: 30px 30px;&#125;\n\n\n\n\n网格中每个格子的大小可以调整，而网格线条的粗细同时保持固定。\n\ndiv&#123;    background: #58a;    background-image:        linear-gradient(white 1px, transparent 0),        linear-gradient(90deg, white 1px, transparent 0);    background-size: 30px 30px;&#125;\n\n\n\n\n把两幅不同线宽、不同颜色的网格图案叠加起来，得到一个更加逼真的蓝图网格。\n\ndiv&#123;    background: #58a;    background-image:        linear-gradient(white 2px, transparent 0),        linear-gradient(90deg, white 2px, transparent 0),        linear-gradient(hsla(0,0%,100%,.3) 1px,transparent 0),        linear-gradient(90deg, hsla(0,0%,100%,.3) 1px,transparent 0);    background-size: 75px 75px, 75px 75px,    15px 15px, 15px 15px;&#125;\n\n\n\n2、波点\n径向渐变创建最简单的圆点的阵列。\n\ndiv&#123;    background: #655;    background-image: radial-gradient(tan 30%, transparent 0);    background-size: 30px 30px;&#125;\n\n\n\n\n通过两层圆点阵列图案的错位排列可以实现真正的波点图案，第二个背景图片的偏移量正好等于贴片宽高的一半。\n\ndiv&#123;    background: #655;    background-image:         radial-gradient(tan 30%, transparent 0),        radial-gradient(tan 30%, transparent 0);    background-size: 30px 30px;    background-position: 0 0, 15px 15px;&#125;\n\n\n\n3、棋盘\n棋盘图案是可以通过平铺生成的，平铺成这个图案的典型贴片包含两种不同颜色的方块，且相互间隔。\n实现技巧在于用两个直角三角形来拼合出一个方块。\n创建直角三角形渐变。\n\ndiv&#123;    background: #eee;    background-image:        linear-gradient(45deg, transparent 75%, #bbb 0);    background-size: 30px 30px;&#125;\n\n\n\ndiv&#123;    background: #eee;    background-image:        linear-gradient(45deg, #bbb 25%, transparent 0),        linear-gradient(45deg, transparent 75%, #bbb 0);    background-size: 30px 30px;&#125;\n\n\n\n\n把第二层渐变在水平和垂直方向均移动贴片长度的一半，把它们拼合成一个完整的方块。\n\ndiv&#123;    background: #eee;    background-image:        linear-gradient(45deg, #bbb 25%, transparent 0),        linear-gradient(45deg, transparent 75%, #bbb 0);    background-position: 0 0, 15px 15px;    background-size: 30px 30px;&#125;\n\n\n\n\n要把现有的这一组渐变重复一份，创建出另一组正方形，并且偏移它们的定位值。\n\ndiv&#123;    background: #eee;    background-image:        linear-gradient(45deg, #bbb 25%, transparent 0),        linear-gradient(45deg, transparent 75%, #bbb 0),        linear-gradient(45deg, #bbb 25%, transparent 0),        linear-gradient(45deg, transparent 75%, #bbb 0);    background-position: 0 0, 15px 15px,                        15px 15px, 30px 30px;    background-size: 30px 30px;&#125;\n\n\n\n\n以把深灰色改成半透明的黑色，这样我们只需要修改底色就可以改变整个棋盘的色调，不需要单独调整各层渐变的色标了。\n\ndiv&#123;    background: #eee;    background-image:    linear-gradient(45deg,        rgba(0,0,0,.25) 25%, transparent 0,        transparent 75%, rgba(0,0,0,.25) 0),    linear-gradient(45deg,        rgba(0,0,0,.25) 25%, transparent 0,        transparent 75%, rgba(0,0,0,.25) 0);    background-position: 0 0, 15px 15px;    background-size: 30px 30px;&#125;\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（五）形状（一）","url":"/2022/01/10/css-5/","content":"九、自适应的椭圆提出问题\n如果它的宽高相等，就显示为一个圆；如果宽高不等，就显示为一个椭圆。\n\n解决问题\nborder-radius：它可以单独指定水平和垂直半径，只要用一个斜杠（/）分隔这两个值即可。\n同时，它不仅可以接受长度值，还可以接受百分比值。这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。\n\ndiv&#123;    border-radius: 50%;&#125;\n\n半椭圆\nborder-radius是一个简写属性。我们可以为元素的每个角指定不同的值，而且还有两种方法可以做到这一点。第一种方法就是使用它所对应的各个展开式属性：\n\nborder-top-left-radius\nborder-top-right-radius\nborder-bottom-right-radius\nborder-bottom-left-radius\n\n\n一次性提供用空格分开的多个值。\n\n如果我们传给它四个值，这四个值就会被分别从左上角开始以顺时针顺序应用到元素的各个拐角。\n如果我们提供的值少于四个，则它们会以 CSS 的常规方式重复，类似于 border-width 的值。\n如果只提供了三个值，则意味着第四个值与第二值相同；如果只有两个值，则意味着第三个值与第一个相同。\n我们甚至可以为所有四个角提供完全不同的水平和垂直半径，方法是在斜杠前指定 14 个值，在斜杠后指定另外 14 个值。\n\n\n沿横轴劈开的上半椭圆：\n\n\ndiv&#123;   border-radius: 50% / 100% 100% 0 0; &#125;\n\n\n沿横轴劈开的下半椭圆：\n\ndiv&#123;   border-radius: 50% / 0 0 100% 100% ; &#125;\n\n\n沿横轴劈开的左半椭圆：\n\ndiv&#123;   border-radius: 100% 0 0 100% / 50%; &#125;\n\n\n沿横轴劈开的右半椭圆：\n\ndiv&#123;   border-radius:  0 100% 100% 0/ 50%; &#125;\n\n四分之一椭圆\n其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。\n\ndiv&#123;   border-radius: 100% 0 0 0;&#125;","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（四）背景与边框（四）","url":"/2022/01/08/css-4/","content":"七、伪随机背景\n通过质数来增加随机真实性。\n\n1、问题提出\n自然界中的事物都不是以无限平铺的方式存在的。即使重复，也往往伴随着多样性和随机性。\n当你注意到一个有辨识度的特征（比如，木纹上的节疤）在以固定的规律循环重复时，那它试图营造的自然随机性就会立刻崩塌。\n重现大自然的随机性是一个挑战，因为 CSS 本身没有提供任何随机功能。\n\n2、解决方案\n把这组条纹从一个平面拆散为多个图层：一种颜色作为底色，另三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺。\n操作步骤：\n创建指定宽度的条纹；\n使用background-size来控制条纹的间距。\n\n\n\n#pic&#123;    background: hsl(20, 40%, 90%);    background-image:        linear-gradient(90deg, #fb3 10px, transparent 0),        linear-gradient(90deg, #ab4 20px, transparent 0),        linear-gradient(90deg, #655 20px, transparent 0);    background-size: 80px 100%, 60px 100%, 40px 100%;&#125;\n\n\n\n\n因为最顶层贴片的重复规律最容易被察觉（它没有被任何东西遮挡），我们应该把平铺间距最大的贴片安排在最顶层。\n这个组合图案中第一个贴片的终点，就是各层背景图像以不同间距重复数次后再次统一对齐的点。\n因此，这里贴片的尺寸实际上就是所有 background-size 的最小公倍数，而 40、60 和 80的最小公倍数正是 240。\n为了让最小公倍数最大化，这些数字最好是“相对质数”。\n要达成相对质数，最简单的办法就是尽量选择质数，因为质数跟其他任意数字都是相对质数。\n\n#pic&#123;    background: hsl(20, 40%, 90%);    background-image:        linear-gradient(90deg, #fb3 11px, transparent 0),        linear-gradient(90deg, #ab4 23px, transparent 0),        linear-gradient(90deg, #655 41px, transparent 0);    background-size: 41px 100%, 61px 100%, 83px 100%;&#125;\n\n\n\n八、连续的图像边框1、提出问题\n把一幅图案或图片应用为边框，而不是背景。\n我们期望望出现在拐角处的图片区域是随着元素宽高和边框厚度的变化而变化的，并不想让图片的某个特定部分固定在拐角处。\n\n\n\n\nborder-image 工作原理：\n\n九宫格伸缩法：把图片切割成九块，然后把它们应用到元素边框相应的边和角。\n\n\n最简单的办法是使用两个 HTML 元素：一个元素用来把我们的石雕图片设为背景，另一个元素用来存放内容，并设置纯白背景，然后覆盖在前者之上：\n\n\n&lt;div class=&quot;something-meaningful&quot;&gt;    &lt;div&gt;        I have a nice stone art border,        don&#x27;t I look pretty?    &lt;/div&gt;&lt;/div&gt;\n.something-meaningful &#123;    background: url(stone-art.jpg);    background-size: cover;    padding: 1em;&#125;.something-meaningful &gt; div &#123;    background: white;    padding: 1em;&#125;\n\n\n如果只用一个元素，我们能做到这个效果吗？\n\n2、解决问题\n主要思路：在石雕背景图片之上，再叠加一层纯白的实色背景。\n为了让下层的图片背景透过边框区域显示出来，我们需要给两层背景指定不同的 background-clip 值。\n最后一个要点在于，我们只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的 CSS 渐变来模拟出纯白实色背景的效果。\n\n&lt;div class=&quot;something-meaningful&quot;&gt;    I have a nice stone art border,    don&#x27;t I look pretty?&lt;/div&gt;\n.something-meaningful &#123;    padding: 1em;    border: 1em solid transparent;    background: linear-gradient(white, white),                url(stone-art.jpg);    background-size: cover;    background-clip: padding-box, border-box;    background-origin: border-box;&#125;\n\n这些新属性也是可以整合到 background 这个简写属性中的，这样可以显著地减少代码量：\n\n.something-meaningful &#123;    padding: 1em;    border: 1em solid transparent;    background:        linear-gradient(white, white) padding-box,        url(stone-art.jpg) border-box 0 / cover;&#125;\n\n实现一个老式信封：\n\ndiv&#123;    padding: 1em;    border: 1em solid transparent;    background: linear-gradient(white, white) padding-box,                repeating-linear-gradient(-45deg,                red 0, red 12.5%,                transparent 0, transparent 25%,                #58a 0, #58a 37.5%,                transparent 0, transparent 50%)                0 / 5em 5em;&#125;\n\n代码讲解：\n\n创建两层背景：\n\nlinear-gradient(white, white) padding-box：用于创建第一层背景纯白色覆盖在最上层；\nrepeating-linear-gradient：用于创建重复线性梯度渐变。效果如下：\n\n\nrepeating-linear-gradient中参数解释：\n\n-45deg：用于将整个条纹旋转-45度；\nred 0,red 12%：从0~12.5%位置均为红色；\ntransparent 0, transparent 25%：从上次的最大位置至25%的位置均为透明；\n#58a 0, #58a 37.5%：从上次的最大位置至37.5%的位置均为#58；\ntransparent 0, transparent 50%：从上次的最大位置至50%的位置均为透明。\n\n\n0/ ：background-position的值为0 0。\n\n5em 5em：background-size大小。\n\n\n蚂蚁行军效果@keyframes ants &#123; to &#123; background-position: 100% &#125; &#125;div&#123;    padding: 1em;    border: 1px solid transparent;    background:        linear-gradient(white, white) padding-box,        repeating-linear-gradient(-45deg,            black 0, black 25%, white 0, white 50%        ) 0 / .6em .6em;    animation: ants 12s linear infinite;&#125;\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（七）形状（三）","url":"/2022/01/10/css-7/","content":"十二、切角效果\n使用渐变来达到目的。\n一个角使用一层渐变，两个角使用两层渐变，以此类推。\n\ndiv&#123;    background: #58a;    background:        linear-gradient(-45deg, transparent 15px, #58a 0);&#125;\n\n\n\n\n左下角和右下角的切角效果。\n\ndiv&#123;    background: #58a;    background:        linear-gradient(-45deg, transparent 15px, #58a 0) right,        linear-gradient(45deg, transparent 15px, #655 0) left;    background-size: 50% 100%;    background-repeat: no-repeat;&#125;\n\n\n\n\n四个角都切。\n\ndiv&#123;    background: #58a;    background:        linear-gradient(135deg, transparent 15px, #58a 0) top left,        linear-gradient(-135deg, transparent 15px, #58a 0) top right,        linear-gradient(-45deg, transparent 15px, #58a 0) bottom right,        linear-gradient(45deg, transparent 15px, #58a 0) bottom left;    background-size: 50% 50%;    background-repeat: no-repeat;&#125;\n\n\n\n\nSCSS如下，可以直接调用，并传入2~5个参数。\n\n@mixin beveled-corners($bg,$tl:0, $tr:$tl, $br:$tl, $bl:$tr) &#123;    background: $bg;    background:        linear-gradient(135deg, transparent $tl, $bg 0)        top left,        linear-gradient(225deg, transparent $tr, $bg 0)        top right,        linear-gradient(-45deg, transparent $br, $bg 0)        bottom right,        linear-gradient(45deg, transparent $bl, $bg 0)        bottom left;    background-size: 50% 50%;    background-repeat: no-repeat;&#125;\n\n弧形切角\n使用径向渐变来替代上述线性渐变。\n\ndiv&#123;    background: #58a;    background:        radial-gradient(circle at top left,transparent 15px, #58a 0) top left,        radial-gradient(circle at top right,transparent 15px, #58a 0) top right,        radial-gradient(circle at bottom right,transparent 15px, #58a 0) bottom right,        radial-gradient(circle at bottom left,transparent 15px, #58a 0) bottom left;    background-size: 50% 50%;    background-repeat: no-repeat;&#125;\n\n\n\n内联SVG与border-image方案略\n裁切路径方案div&#123;    background: #58a;    clip-path: polygon(        20px 0, calc(100% - 20px) 0, 100% 20px,        100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px    );&#125;\n\n补充方案\ncorner-shape属性。\n为容器的四个角指定 15px 的斜面切角。\n\ndiv&#123;    border-radius: 15px;    corner-shape: bevel;&#125;\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（八）形状（四）","url":"/2022/01/10/css-8/","content":"十三、梯形标签页\n在 CSS 中用 3D 旋转来模拟出这个效果。\n\ndiv&#123;    transform: perspective(.5em) rotateX(5deg);&#125;\n\n\n对元素使用了 3D 变形之后，其内部的变形效应是“不可逆转”的。\n所以唯一可行的途径就是把变形效果作用在伪元素上。\n\n.tab &#123;    position: relative;    display: inline-block;    padding: .5em 1em .35em;    color: white;&#125;.tab::before &#123;    content: &#x27;&#x27;; /* 用伪元素来生成一个矩形 */    position: absolute;    top: 0; right: 0; bottom: 0; left: 0;    z-index: -1;    background: #58a;    transform: scaleY(1.3) perspective(.5em)                rotateX(5deg);    transform-origin: bottom;&#125;\n\n\n下面这段代码会给标签页添加图中的那些样式。\n\nnav &gt; a &#123;    position: relative;    display: inline-block;    padding: .3em 1em 0;&#125;nav &gt; a::before &#123;    content: &#x27;&#x27;;    position: absolute;    top: 0; right: 0; bottom: 0; left: 0;    z-index: -1;    background: #ccc;    background-image: linear-gradient(                        hsla(0,0%,100%,.6),                        hsla(0,0%,100%,0));    border: 1px solid rgba(0,0,0,.4);    border-bottom: none;    border-radius: .5em .5em 0 0;    box-shadow: 0 .15em white inset;    transform: perspective(.5em) rotateX(5deg);    transform-origin: bottom;&#125;\n\n\n\n十四、简单的饼图基于transform的解决方案&lt;div class=&quot;pie&quot;&gt;&lt;/div&gt;\n\n.pie &#123;    width: 100px; height: 100px;    border-radius: 50%;    background: yellowgreen;&#125;\n\n\n\n\n把圆形的左右两部分指定为上述两种颜色，然后用伪元素覆盖上去，通过旋转来决定露出多大的扇区。\n\n.pie &#123;    width: 100px; height: 100px;    border-radius: 50%;    background: yellowgreen;    background-image:        linear-gradient(to right, transparent 50%, #655 0);&#125;.pie::before &#123;    content: &#x27;&#x27;;    display: block;    margin-left: 50%;    height: 100%;&#125;\n\n\n伪元素现在相对于整个饼图进行了重叠。不过现在还没有设置任何样式，它还起不到遮盖的作用：暂时只是一个透明的矩形。在开始为它设置样式之前，我们还要再做一些观察和分析。\n我们希望它能遮盖圆形中的棕色部分，因此应该给它指定绿色背景。在这里使用 background-color: inherit 声明可以避免代码的重复，因为我们希望它的背景色与其宿主元素保持一致。\n我们希望它是绕着圆形的圆心来旋转的，对它自己来说，这个点就是它左边缘的中心点。因此，我们应该把它的 transform-origin 设置为 0 50%，或者干脆写成 left。\n我们不希望它呈现出矩形的形状，否则它会突破整个饼图的圆形范围。因此要么给 .pie 设置 overflow: hidden 的样式，要么给这个伪元素指定合适的 border-radius 属性来把它变成一个半圆。\n\n\n\n.pie &#123;    width: 100px; height: 100px;    border-radius: 50%;    background: yellowgreen;    overflow: hidden;    background-image:        linear-gradient(to right, transparent 50%, #655 0);&#125;.pie::before &#123;    content: &#x27;&#x27;;    display: block;    margin-left: 50%;    height: 100%;    border-radius: 0 100% 100% 0 / 50%;    background-color: inherit;    transform-origin: left;&#125;\n\n\n用虚线框表示伪元素覆盖位置。\n\n\n\n\n如果把 50%~100% 的比率看作另外一个问题，我们就会发现，可以使用上述技巧的一个反向版本来实现这个范围内的比率：设置一个棕色的伪元素，让它在 0 至 .5turn 的范围内旋转。因此，要得到一个 60% 比率的饼图，伪元素的代码可能是这样的：\n\n.pie &#123;    width: 100px; height: 100px;    border-radius: 50%;    background: yellowgreen;    overflow: hidden;    background-image:        linear-gradient(to right, transparent 50%, #655 0);&#125;.pie::before &#123;    content: &#x27;&#x27;;    display: block;    margin-left: 50%;    height: 100%;    border-radius: 0 100% 100% 0 / 50%;    background: #655;    transform-origin: left;    transform: rotate(.1turn);&#125;\n\n\n用 CSS 动画来实现一个饼图从 0 变化到 100% 的动画，从而得到一个炫酷的进度指示器：\n\n.pie &#123;    width: 100px; height: 100px;    border-radius: 50%;    background: yellowgreen;    overflow: hidden;    background-image:        linear-gradient(to right, transparent 50%, #655 0);&#125;@keyframes spin &#123; to &#123; transform: rotate(.5turn); &#125;&#125;@keyframes bg &#123; 50% &#123; background: #655; &#125;&#125;.pie::before &#123;    content: &#x27;&#x27;;    display: block;    margin-left: 50%;    height: 100%;    border-radius: 0 100% 100% 0 / 50%;    background-color: inherit;    transform-origin: left;    animation: spin 3s linear infinite,                bg 6s step-end infinite;&#125;\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]},{"title":"CSS学习笔记（九）视觉效果","url":"/2022/01/11/css-9/","content":"十五、单侧投影\n使用 box-shadow 的方法是，指定三个长度值和一个颜色值：\n\ndiv&#123;    box-shadow: 2px 3px 4px rgba(0,0,0,.5);&#125;\n\n\nbox-shadow绘制原理：\n\n以选定的元素a为准，在相同的位置处绘制尺寸相同的元素b（a，b颜色不同）；\n将元素b进行移动，移动大小由参数决定（第一二个参数）；\n使用高斯模糊算法进行模糊处理（第三个参数决定）；\n模糊后的元素b与元素a交集的部分会被切除掉。\n\n\n如何只在元素的一侧设置投影。\n\nbox-shadow的第四个长度参数，这个参数会根据你指定的值去扩大或缩小投影的尺寸\n\n\n\ndiv&#123;    box-shadow: 0 5px 4px -4px black;&#125;\n\n邻边投影\n如何在元素的两条边上设置投影。\n扩张半径应该设为模糊半径相反值的一半。\n两个偏移量它们的值需要大于或等于模糊半径的一半。\n\ndiv&#123;    box-shadow: 3px 3px 6px -3px black;&#125;\n\n双侧投影\n将投影设置在元素的两条对边。\n将单侧投影使用两次来达到效果\n\ndiv&#123;    box-shadow: 5px 0 5px -5px black,                -5px 0 5px -5px black;&#125;\n\n十六、不规则投影\n使用 drop-shadow 滤镜实现投影，任何非透明的部分都会被一视同仁地打上投影，包括文本，并且无法通过text-shadow:none; 来取消掉文本上的投影。\n\n十七、染色效果基于滤镜的方案\n叠加滤镜效果的方式实现染色效果。\nsepia()：它会给图片增加一种降饱和度的橙黄色染色效果，几乎所有像素的色相值会被收敛到 35~40。\nsaturate()：他会给每个像素提升饱和度。\nhue-rotate()：把每个像素的色相以指定的度数进行偏移。\n\nimg&#123;    filter: sepia(1) saturate(4) hue-rotate(295deg);&#125;\n\n\n\n\n基于混合模式的方案\n“混合模式”控制了上层元素的颜色与下层颜色进行混合的方式。\n用它来实现染色效果时，需要用到的混合模式是 luminosity。\nluminosity 混合模式会保留上层元素的 HSL 亮度信息，并从它的下层吸取色相和饱和度信息。\n\n\n要对一个元素设置混合模式，有两个属性可以派上用场：\nmix-blend-mode 可以为整个元素设置混合模式；mix-blend-mode 是把整个元素向下进行混合，而不管它的下层是什么。\nbackground-blend-mode 可以为每层背景单独指定混合模式。\n\n\n\n&lt;a href=&quot;#something&quot;&gt;    &lt;img src=&quot;tiger.jpg&quot; alt=&quot;Rawrrr!&quot; /&gt;&lt;/a&gt;\n\na &#123;    background: hsl(335, 100%, 50%);&#125;img &#123;    mix-blend-mode: luminosity;&#125;\n\n&lt;div class=&quot;tinted-image&quot;    style=&quot;background-image:url(tiger.jpg)&quot;&gt;&lt;/div&gt;\n\n.tinted-image &#123;    width: 640px; height: 440px;    background-size: cover;    background-color: hsl(335, 100%, 50%);    background-blend-mode: luminosity;    transition: .5s background-color;&#125;.tinted-image:hover &#123;    background-color: transparent;&#125;\n\n十八、毛玻璃效果\n半透明颜色背景：\n\n&lt;main&gt;    &lt;blockquote&gt;        &quot;The only way to get rid of a temptation[...]&quot;        &lt;footer&gt;－            &lt;cite&gt;                Oscar Wilde,                The Picture of Dorian Gray            &lt;/cite&gt;        &lt;/footer&gt;    &lt;/blockquote&gt;&lt;/main&gt;\nbody &#123;    background: url(&quot;tiger.jpg&quot;) 0 / cover fixed;&#125;main &#123;    background: hsla(0,0%,100%,.3);&#125;\n\n\n\n解决方案\n由于我们不能直接对元素本身进行模糊处理，就对一个伪元素进行处理，然后将其定位到元素的下层，它的背景将会无缝匹配 &lt;body&gt; 的背景。\n首先，我们添加一个伪元素，将其绝对定位，并把所有偏移量置为 0，这样就可以将它完整地覆盖到 &lt;main&gt; 元素之上：\n\nmain &#123;    position: relative;    /* [其余样式] */&#125;main::before &#123;    content: &#x27;&#x27;;    position: absolute;    top: 0; right: 0; bottom: 0; left: 0;    background: rgba(255,0,0,.5); /* 仅用于调试 */&#125;\n\n\n\n\n使用 z-index: -1; 来把伪元素移动到宿主元素的后面。\n\n\n\n\n现在该把半透明红色背景换掉了，换成跟背层完全匹配的背景。要实现这一点，我们要么把 &lt;body&gt; 的背景复制过来，要么把伪元素的背景声明合并过去。\n\nbody, main::before &#123;    background: url(&quot;tiger.jpg&quot;) 0 / cover fixed;&#125;main &#123;    position: relative;    background: hsla(0,0%,100%,.3);&#125;main::before &#123;    content: &#x27;&#x27;;    position: absolute;    top: 0; right: 0; bottom: 0; left: 0;    filter: blur(20px);&#125;\n\n\n\n\n模糊效果在中心区域看起来非常完美，但在接近边缘处会逐渐消退。这是因为模糊效果会削减实色像素所能覆盖的范围，削减的幅度正是模糊半径的长度。\n\n\n\n\n为了补偿这种情况，我们需要让伪元素相对其宿主元素的尺寸再向外扩大至少 20px（即它的模糊半径）。可以通过 -20px 的外边距来达到目的，由于不同浏览器的模糊算法可能存在差异，用一个更大的绝对值（比如 -30px）会更保险一些。\n这个方法可以修复边缘模糊消退的问题，但现在的情况是有一圈模糊效果超出了容器，这让它看起来不像毛玻璃，而更像是玻璃脏了。\n\n\n\n\n不过幸运的是，这个问题也很容易修复：只要对 main 元素应用overflow: hidden;，就可以把多余的模糊区域裁切掉了。\n\nbody, main::before &#123;    background: url(&quot;tiger.jpg&quot;) 0 / cover fixed;&#125;main &#123;    position: relative;    background: hsla(0,0%,100%,.3);    overflow: hidden;&#125;main::before &#123;    content: &#x27;&#x27;;    position: absolute;    top: 0; right: 0; bottom: 0; left: 0;    filter: blur(20px);    margin: -30px;&#125;\n\n","categories":["前端学习笔记","CSS"],"tags":["CSS学习"]}]